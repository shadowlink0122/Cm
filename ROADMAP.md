# Cm言語 開発ロードマップ

## 開発方針

> **LLVMベースアーキテクチャ**: 2024年12月より、LLVM IRを唯一のコード生成バックエンドとして採用。
> Rust/TypeScript/C++へのトランスパイルは今後行いません。

## Version 0.1.0 (現在) ✅

### 完成済み機能
- ✅ 基本的な式と文の実行（インタプリタ）
- ✅ フォーマット文字列（変数自動キャプチャ）
- ✅ MIRインタプリタ
- ✅ コマンドベースCLI
- ✅ デバッグシステム
- ✅ LLVMバックエンド基本実装
- ✅ LLVM Native/WASM出力
- ✅ 構造体定義とフィールドアクセス
- ✅ switch文（整数型、char型対応）
- ✅ 基本型システム（int, uint, char, string, bool, double, etc.）

## Version 0.2.0 - スコープとリソース管理 ✅

### 目標
ブロックスコープの完全サポートとリソース管理基盤の構築

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| スコープトラッキング | ✅ | ✅ | ✅ |
| StorageDead自動発行 | ✅ | ✅ | ✅ |
| defer文 | ✅ | ✅ | ✅ |
| ブロック終了時処理 | ✅ | ✅ | ✅ |

### 技術詳細
```cm
// defer: ブロック終了時に逆順で実行
void example() {
    defer println("3rd");
    defer println("2nd");
    defer println("1st");
    // 出力: 1st, 2nd, 3rd
}

// スコープによる変数の有効範囲
void scope_test() {
    {
        int x = 10;
        // StorageLive(x)
    }
    // StorageDead(x) - ここで自動発行
}
```

## Version 0.3.0 - Interface/Impl/Self（現在の目標）

### 目標
型に振る舞いを付与するインターフェースシステムの実装

### 設計原則
- **構造体には直接メソッドを定義できない**
- 全てのメソッドは`interface`を通じて定義される
- `impl Type for Interface`で実装を提供

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| interface定義 | ⬜ | ⬜ | ⬜ |
| impl Type for Interface | ⬜ | ⬜ | ⬜ |
| selfキーワード | ⬜ | ⬜ | ⬜ |
| メソッド呼び出し | ⬜ | ⬜ | ⬜ |
| 静的ディスパッチ | ⬜ | ⬜ | ⬜ |

### 構文例
```cm
// インターフェース定義
interface Printable {
    void print();
}

interface Container<T> {
    void push(T item);
    T pop();
    bool is_empty();
}

// 構造体定義（メソッドは書けない）
struct Point {
    double x;
    double y;
}

// インターフェース実装
impl Point for Printable {
    void print() {
        println("({}, {})", self.x, self.y);
    }
}
```

## Version 0.4.0 - コンストラクタ/デストラクタ

### 目標
オブジェクトのライフサイクル管理

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| impl Type（基本impl） | ⬜ | ⬜ | ⬜ |
| self()コンストラクタ | ⬜ | ⬜ | ⬜ |
| ~self()デストラクタ | ⬜ | ⬜ | ⬜ |
| overloadコンストラクタ | ⬜ | ⬜ | ⬜ |
| RAII自動呼び出し | ⬜ | ⬜ | ⬜ |

### 構文例
```cm
struct Vec<T> {
    private T* data;
    private size_t size;
    private size_t capacity;
}

// コンストラクタ/デストラクタ専用impl
impl<T> Vec<T> {
    self() {
        this.data = null;
        this.size = 0;
    }

    overload self(size_t capacity) {
        this.data = new T[capacity];
        this.size = 0;
        this.capacity = capacity;
    }

    ~self() {
        delete[] this.data;
    }
}

// メソッドはinterfaceを通じて実装
impl<T> Vec<T> for Container<T> {
    void push(T item) { /* ... */ }
    T pop() { /* ... */ }
}
```

## Version 0.5.0 - エラーハンドリングとResult型

### 目標
安全なエラーハンドリングの実装

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| Result<T, E>型 | ⬜ | ⬜ | ⬜ |
| Option<T>型 | ⬜ | ⬜ | ⬜ |
| ?演算子 | ⬜ | ⬜ | ⬜ |
| パニックハンドリング | ⬜ | ⬜ | ⬜ |

## Version 0.6.0 - 配列とコレクション

### 目標
動的・静的配列とベクター型の実装

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| 固定長配列 [T; N] | ⬜ | ⬜ | ⬜ |
| 動的配列 Vec<T> | ⬜ | ⬜ | ⬜ |
| 文字列操作 | ⬜ | ⬜ | ⬜ |
| スライス操作 | ⬜ | ⬜ | ⬜ |
| イテレータ | ⬜ | ⬜ | ⬜ |

## Version 0.7.0 - ジェネリクス

### 目標
型パラメータとジェネリックプログラミング

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| 関数ジェネリクス | ⬜ | ⬜ | ⬜ |
| 構造体ジェネリクス | ⬜ | ⬜ | ⬜ |
| 型制約 where句 | ⬜ | ⬜ | ⬜ |
| 関連型 | ⬜ | ⬜ | ⬜ |
| 型推論強化 | ⬜ | ⬜ | ⬜ |

## Version 0.8.0 - モジュールシステム

### 目標
完全なモジュールとパッケージ管理

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| import/export | ⬜ | ⬜ | ⬜ |
| モジュール解決 | ⬜ | ⬜ | ⬜ |
| 標準ライブラリ | ⬜ | ⬜ | ⬜ |
| genパッケージマネージャ | ⬜ | ⬜ | ⬜ |
| 依存関係管理 | ⬜ | ⬜ | ⬜ |

## Version 0.9.0 - パターンマッチングと列挙型

### 目標
強力なパターンマッチング機能

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| match式 | ⬜ | ⬜ | ⬜ |
| enum型 | ⬜ | ⬜ | ⬜ |
| パターンガード | ⬜ | ⬜ | ⬜ |
| 構造化束縛 | ⬜ | ⬜ | ⬜ |
| 網羅性チェック | ⬜ | ⬜ | ⬜ |

## Version 0.10.0 - 非同期処理

### 目標
async/awaitとFuture型の実装

### 実装項目
| 機能 | インタプリタ | LLVM | テスト |
|------|-------------|------|--------|
| async関数 | ⬜ | ⬜ | ⬜ |
| await式 | ⬜ | ⬜ | ⬜ |
| Future型 | ⬜ | ⬜ | ⬜ |
| ランタイム統合 | ⬜ | ⬜ | ⬜ |
| 並行処理 | ⬜ | ⬜ | ⬜ |

## Version 1.0.0 - 安定版リリース

### 達成条件
- ✅ すべてのコア機能の実装完了
- ✅ インタプリタとLLVMバックエンドの動作一致
- ✅ 包括的なテストスイート（>90%カバレッジ）
- ✅ ドキュメント完備
- ✅ genパッケージマネージャ完成
- ✅ エディタサポート（VSCode, Vim）
- ✅ 標準ライブラリ安定版

### 最終チェックリスト
- [ ] 言語仕様書の完成
- [ ] APIドキュメント
- [ ] チュートリアル
- [ ] サンプルプロジェクト
- [ ] パフォーマンスベンチマーク
- [ ] セキュリティ監査

## 並行開発の原則

### 1. 機能実装フロー
```
1. 言語機能の仕様策定
2. テストケース作成（期待される動作の定義）
3. インタプリタ実装
4. LLVMバックエンド実装
5. 両実装の出力比較テスト
6. 不一致があれば修正
7. ドキュメント更新
```

### 2. テスト戦略
- **ゴールデンテスト**: 同一入力に対する出力の完全一致確認
- **プロパティベーステスト**: ランダム入力での動作一致
- **境界値テスト**: エッジケースでの動作確認
- **パフォーマンステスト**: 実行速度の比較

### 3. CI/CDパイプライン
```yaml
test:
  - stage: unit_test
    - interpreter_tests
    - llvm_tests
  - stage: integration_test
    - compare_outputs
    - golden_tests
  - stage: benchmark
    - performance_comparison
```

## リスクと緩和策

| リスク | 影響度 | 緩和策 |
|--------|-------|--------|
| インタプリタ/LLVMの動作不一致 | 高 | 各機能実装時に徹底的な比較テスト |
| パフォーマンス差が大きい | 中 | 最適化は別フェーズで実施 |
| 仕様変更による手戻り | 中 | 早期のプロトタイプと検証 |
| 依存関係の複雑化 | 低 | モジュール間の疎結合設計 |

## 次のアクション（v0.2.0に向けて）

1. **スコープトラッキング実装** - 1週間
   - FunctionContextにスコープスタック追加
   - ブロック開始/終了でスコープをpush/pop

2. **StorageDead自動発行** - 1週間
   - ブロック終了時にスコープ内変数にStorageDeadを発行
   - インタプリタでの検証

3. **defer文の実装** - 2週間
   - AST/HIR/MIRへの追加
   - 逆順実行の保証

4. **テストスイート作成** - 1週間

**目標リリース日**: 2025年1月上旬

---

## 廃止された機能

以下の機能は2024年12月に廃止されました：

- **Rustトランスパイラ** (`--emit-rust`): LLVMバックエンドに置き換え
- **TypeScriptトランスパイラ** (`--emit-ts`): LLVMバックエンドに置き換え
- **C++トランスパイラ** (`--emit-cpp`): LLVMバックエンドに置き換え

これらの機能のソースコードは参考のため保持されていますが、
今後のメンテナンスや機能追加は行われません。

---

## 設計原則（重要）

### メソッドは必ずinterfaceを通じて定義
```cm
// ❌ 間違い：構造体に直接メソッドを定義
struct Point {
    double x;
    double y;

    void print() { }  // これは許可されない
}

// ✅ 正しい：interfaceを通じて定義
interface Printable {
    void print();
}

struct Point {
    double x;
    double y;
}

impl Point for Printable {
    void print() {
        println("({}, {})", self.x, self.y);
    }
}
```

### self と this の使い分け
- `self`: implブロック内でのインスタンス参照
- `this`: コンストラクタ/デストラクタ内でのインスタンス参照

```cm
impl<T> Vec<T> {
    self() {
        this.data = null;  // コンストラクタ内では this
    }
}

impl<T> Vec<T> for Container<T> {
    void push(T item) {
        self.data[self.size++] = item;  // メソッド内では self
    }
}
```