//! platform: uefi
// libs::efi_text - UEFI テキスト出力
// ConOut.OutputString をインラインASM経由で呼出し
// ASCII -> UCS-2 変換もASMで実行
//
// 注意: string型は関数パラメータとして渡すとデータが壊れるため、
//       全てのインターフェースは void* + ulong で受け取る
// 注意: ASMに渡す値は全てulongにキャストすること
// 注意: 全てのASMブロックはmust{}で囲むこと（最適化除去防止）
// module efi_text;

// ============================================================
// テキスト出力（低レベル）
// ============================================================

/// ASCIIデータをUCS-2に変換してUEFI ConOutに出力
/// system_table: efi_mainの第2引数
/// msg_data:     ASCII文字列のポインタ（string as void*で取得）
/// msg_len:      文字列長
export void efi_puts_raw(void* system_table, void* msg_data, ulong msg_len) {
    // ConOut取得 (SystemTable + 0x40)
    ulong* st = system_table as ulong*;
    ulong con_out_addr = *(st + 8);
    void* con_out = con_out_addr as void*;

    // ConOut->OutputString 取得 (offset 0x08)
    ulong* co = con_out as ulong*;
    ulong output_fn_addr = *(co + 1);

    // ASMに渡す前にulongにキャスト
    ulong fn_val = output_fn_addr as ulong;
    ulong co_val = con_out as ulong;
    ulong md_val = msg_data as ulong;

    // ASCII -> UCS-2 変換 + OutputString 呼出
    // pushq/popqで入力値を安全にハードコードレジスタへ転送
    // （LLVMのレジスタ割り当てとの競合を防止）
    // 数値ラベル(0:, 1:)でインライン展開時の重複回避
    must {
        __asm__(`
            pushq ${r:fn_val};
            pushq ${r:co_val};
            pushq ${r:md_val};
            pushq ${r:msg_len};
            popq %rbx;
            popq %r12;
            popq %r14;
            popq %r13;
            subq $$512, %rsp;
            xorq %rcx, %rcx;
            0:
                cmpq %rbx, %rcx;
                jge 1f;
                movzbl (%r12, %rcx), %eax;
                movw %ax, (%rsp, %rcx, 2);
                incq %rcx;
                jmp 0b;
            1:
                movw $$0, (%rsp, %rcx, 2);
                movq %r14, %rcx;
                movq %rsp, %rdx;
                subq $$32, %rsp;
                callq *%r13;
                addq $$544, %rsp
        `);
    }
}

/// NUL終端文字列の長さを計算（ASM実装）
/// Cmコンパイラの utiny* デリファレンスバグ回避
export ulong efi_strlen(void* data) {
    ulong data_val = data as ulong;
    ulong result = 0;
    // pushq/popqでLLVMレジスタ割り当てとの競合を防止
    must {
        __asm__(`
            pushq ${r:data_val};
            popq %rdi;
            xorq %rcx, %rcx;
            0:
                movzbl (%rdi, %rcx), %eax;
                testb %al, %al;
                jz 1f;
                incq %rcx;
                jmp 0b;
            1:
                movq %rcx, ${=r:result}
        `);
    }
    return result;
}

/// 文字列を出力（長さ自動計算）
export void efi_print(void* system_table, void* msg_data) {
    ulong len = efi_strlen(msg_data);
    efi_puts_raw(system_table, msg_data, len);
}

/// 文字列を改行付きで出力（長さ自動計算）
export void efi_println(void* system_table, void* msg_data) {
    efi_print(system_table, msg_data);
    // CR+LF を出力
    string crlf = "\r\n";
    void* crlf_data = crlf as void*;
    efi_puts_raw(system_table, crlf_data, 2);
}

/// 画面クリア
export void efi_clear_screen(void* system_table) {
    // ConOut取得 (SystemTable + 0x40)
    ulong* st = system_table as ulong*;
    ulong con_out_addr = *(st + 8);
    void* con_out = con_out_addr as void*;

    // ConOut->ClearScreen 取得 (offset 0x30)
    ulong* co = con_out as ulong*;
    ulong clear_fn_addr = *(co + 6);

    // Win64 ABI: RCX = con_out
    ulong fn_val = clear_fn_addr as ulong;
    ulong co_val = con_out as ulong;
    ulong result = 0;
    // pushq/popqでLLVMレジスタ割り当てとの競合を防止
    must {
        __asm__(`
            pushq ${r:fn_val};
            pushq ${r:co_val};
            popq %rcx;
            popq %r8;
            subq $$32, %rsp;
            callq *%r8;
            addq $$32, %rsp;
            movq %rax, ${=r:result}
        `);
    }
}
