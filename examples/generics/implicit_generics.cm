// 暗黙的ジェネリック推論の例

// ============================================================
// シンプルなジェネリック関数（Tが自動推論）
// ============================================================

// 単一大文字は自動的にジェネリック
T identity(T value) {
    return value;
}

T max(T a, T b) {
    return a > b ? a : b;
}

T min(T a, T b) {
    return a < b ? a : b;
}

// 複数の型パラメータ
U convert(T from, U default_value) {
    // 実装は型に依存
    return default_value;
}

K get_key(Pair<K, V> pair) {
    return pair.first;
}

V get_value(Pair<K, V> pair) {
    return pair.second;
}

// ============================================================
// 型制約付きジェネリック
// ============================================================

// Ordインターフェースを実装した型のみ
T clamp(T value, T min, T max) where T: Ord {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}

// 複数の制約
T process(T item) where T: Clone + Debug {
    debug_print(item);
    return item.clone();
}

// 複雑な制約
U transform(T input) where T: Into<U>, U: Default {
    if (is_valid(input)) {
        return input.into();
    }
    return U::default();
}

// ============================================================
// ジェネリック構造体（暗黙的推論）
// ============================================================

struct Pair {
    K first;   // K はジェネリックと推論
    V second;  // V はジェネリックと推論
}

struct Node {
    T value;        // T はジェネリックと推論
    Node<T>* next;
}

struct Tree {
    T data;
    Tree<T>* left;
    Tree<T>* right;
}

// ============================================================
// impl ブロック（型パラメータ自動推論）
// ============================================================

impl Pair<K, V> {  // K, V は Pair<K, V> から推論
    K first() {
        return this->first;
    }

    V second() {
        return this->second;
    }

    void swap() {
        // K と V を入れ替える（特殊な実装）
        // この場合、K と V が同じ型である必要がある
    }

    Pair<V, K> reverse() {
        return Pair<V, K>{second, first};
    }
}

impl Node<T> {  // T は Node<T> から推論
    void append(T value) {
        if (next == null) {
            next = new Node<T>{value, null};
        } else {
            next->append(value);
        }
    }

    int length() {
        if (next == null) {
            return 1;
        }
        return 1 + next->length();
    }

    bool contains(T target) where T: Eq {
        if (value == target) return true;
        if (next != null) return next->contains(target);
        return false;
    }
}

impl Tree<T> {  // T は Tree<T> から推論
    void insert(T item) where T: Ord {
        if (item < data) {
            if (left == null) {
                left = new Tree<T>{item, null, null};
            } else {
                left->insert(item);
            }
        } else {
            if (right == null) {
                right = new Tree<T>{item, null, null};
            } else {
                right->insert(item);
            }
        }
    }

    T find_min() where T: Ord {
        if (left == null) {
            return data;
        }
        return left->find_min();
    }

    T find_max() where T: Ord {
        if (right == null) {
            return data;
        }
        return right->find_max();
    }

    // 別の型への変換
    Tree<U>* map(U mapper(T)) {
        Tree<U>* result = new Tree<U>{
            mapper(data),
            left ? left->map(mapper) : null,
            right ? right->map(mapper) : null
        };
        return result;
    }
}

// ============================================================
// コレクション操作（高階関数）
// ============================================================

// フィルタリング
Vec<T> filter(Vec<T> items, bool predicate(T)) {
    Vec<T> result;
    for (T item : items) {
        if (predicate(item)) {
            result.push(item);
        }
    }
    return result;
}

// マッピング
Vec<U> map(Vec<T> items, U mapper(T)) {
    Vec<U> result;
    for (T item : items) {
        result.push(mapper(item));
    }
    return result;
}

// 畳み込み
R fold(Vec<T> items, R initial, R reducer(R, T)) {
    R result = initial;
    for (T item : items) {
        result = reducer(result, item);
    }
    return result;
}

// ============================================================
// 実用的な例
// ============================================================

// Option型の実装
struct Option {
    enum Tag { Some, None } tag;
    T value;  // T はジェネリック
}

impl Option<T> {
    bool is_some() {
        return tag == Tag::Some;
    }

    bool is_none() {
        return tag == Tag::None;
    }

    T unwrap() {
        if (tag == Tag::None) {
            panic("Called unwrap on None");
        }
        return value;
    }

    T unwrap_or(T default_value) {
        if (tag == Tag::Some) {
            return value;
        }
        return default_value;
    }

    Option<U> map(U mapper(T)) {
        if (tag == Tag::Some) {
            return Option<U>{Tag::Some, mapper(value)};
        }
        return Option<U>{Tag::None, U()};
    }
}

// Result型の実装
struct Result {
    enum Tag { Ok, Err } tag;
    union {
        T ok_value;   // T はジェネリック
        E err_value;  // E はジェネリック
    };
}

impl Result<T, E> {  // T, E は Result<T, E> から推論
    bool is_ok() {
        return tag == Tag::Ok;
    }

    bool is_err() {
        return tag == Tag::Err;
    }

    T unwrap() {
        if (tag == Tag::Err) {
            panic("Called unwrap on Err");
        }
        return ok_value;
    }

    E unwrap_err() {
        if (tag == Tag::Ok) {
            panic("Called unwrap_err on Ok");
        }
        return err_value;
    }

    Result<U, E> map(U mapper(T)) {
        if (tag == Tag::Ok) {
            return Result<U, E>{Tag::Ok, {.ok_value = mapper(ok_value)}};
        }
        return Result<U, E>{Tag::Err, {.err_value = err_value}};
    }
}

// ============================================================
// 使用例
// ============================================================

int main() {
    // 型は使用時に自動的に具体化
    int x = identity(42);                    // T = int
    string s = identity("hello");            // T = string
    double d = identity(3.14);               // T = double

    // max関数の使用
    int max_int = max(10, 20);              // T = int
    string max_str = max("apple", "banana"); // T = string

    // ペアの作成と使用
    Pair<int, string> pair = {42, "answer"};
    int key = pair.first();                  // K = int, V = string
    string val = pair.second();

    // リンクリストの使用
    Node<int>* list = new Node<int>{1, null};
    list->append(2);
    list->append(3);
    int len = list->length();                // 3

    // ツリーの使用
    Tree<int>* tree = new Tree<int>{50, null, null};
    tree->insert(30);
    tree->insert(70);
    tree->insert(20);
    tree->insert(40);

    int min_val = tree->find_min();          // 20
    int max_val = tree->find_max();          // 70

    // 高階関数の使用
    Vec<int> numbers = {1, 2, 3, 4, 5};

    // フィルタリング（偶数のみ）
    Vec<int> evens = filter(numbers, (int n) -> n % 2 == 0);

    // マッピング（2倍にする）
    Vec<int> doubled = map(numbers, (int n) -> n * 2);

    // 畳み込み（合計を計算）
    int sum = fold(numbers, 0, (int acc, int n) -> acc + n);

    // Option型の使用
    Option<int> some = {Option<int>::Tag::Some, 42};
    Option<int> none = {Option<int>::Tag::None, 0};

    int val1 = some.unwrap_or(0);            // 42
    int val2 = none.unwrap_or(0);            // 0

    // Result型の使用
    Result<int, string> ok = {
        Result<int, string>::Tag::Ok,
        {.ok_value = 42}
    };

    Result<int, string> err = {
        Result<int, string>::Tag::Err,
        {.err_value = "Error occurred"}
    };

    if (ok.is_ok()) {
        println("Success: " + ok.unwrap());
    }

    if (err.is_err()) {
        println("Error: " + err.unwrap_err());
    }

    return 0;
}