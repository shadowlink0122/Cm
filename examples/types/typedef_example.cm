// Typedef と型エイリアスの例

// ============================================================
// 基本的な型エイリアス
// ============================================================

// シンプルな型エイリアス
typedef Int32 = int;
typedef StringPtr = string*;
typedef IntArray = int[];

// 関数ポインタ型
typedef Callback = void (*)(int);
typedef Predicate<T> = bool (*)(T);

// ============================================================
// リテラル型
// ============================================================

// 文字列リテラル型
typedef HttpMethod = "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
typedef Status = "idle" | "loading" | "success" | "error";
typedef LogLevel = "debug" | "info" | "warn" | "error" | "fatal";

// 数値リテラル型
typedef HttpCode = 200 | 201 | 204 | 400 | 401 | 403 | 404 | 500;
typedef Priority = 1 | 2 | 3 | 4 | 5;
typedef Percentage = 0 | 25 | 50 | 75 | 100;

// ============================================================
// ユニオン型（タグ付き）
// ============================================================

// Result型（成功/エラーの表現）
typedef Result<T, E> = Ok(T) | Err(E);
typedef Result<T> = Ok(T) | Err(string);  // デフォルトエラー型

// Option型（値の有無）
typedef Option<T> = Some(T) | None;

// JSON値の表現
typedef JsonValue =
    | Null
    | Bool(bool)
    | Number(double)
    | String(string)
    | Array(Vec<JsonValue>)
    | Object(Map<string, JsonValue>);

// AST ノードの例
typedef Expr =
    | IntLit(int)
    | FloatLit(double)
    | StringLit(string)
    | BinaryOp { op: string, left: Expr*, right: Expr* }
    | UnaryOp { op: string, operand: Expr* }
    | Call { name: string, args: Vec<Expr> }
    | Variable(string);

// ============================================================
// 使用例
// ============================================================

// リテラル型を使った関数
HttpCode makeRequest(HttpMethod method, string url) {
    if (method == "GET") {
        return 200;  // OK
    }
    if (method == "POST") {
        return 201;  // Created
    }
    return 404;  // Not Found
}

// ユニオン型を返す関数
Result<int> divide(int a, int b) {
    if (b == 0) {
        return Err("Division by zero");
    }
    return Ok(a / b);
}

// Option型の使用
Option<string> findUser(int id) {
    if (id == 123) {
        return Some("Alice");
    }
    return None;
}

// パターンマッチング
void processResult(Result<int> result) {
    match (result) {
        Ok(value) => println("Success: " + value),
        Err(msg) => println("Error: " + msg),
    }
}

void processJson(JsonValue json) {
    match (json) {
        Null => println("null"),
        Bool(b) => println("boolean: " + (b ? "true" : "false")),
        Number(n) => println("number: " + n),
        String(s) => println("string: \"" + s + "\""),
        Array(arr) => {
            println("array with " + arr.len() + " elements");
            for (JsonValue item : arr) {
                processJson(item);  // 再帰的処理
            }
        },
        Object(obj) => {
            println("object with " + obj.size() + " keys");
            for ((string key, JsonValue value) : obj) {
                println("  " + key + ":");
                processJson(value);
            }
        },
    }
}

// ============================================================
// ジェネリック型エイリアス
// ============================================================

// コレクション型のエイリアス
typedef List<T> = Vec<T>;
typedef Dict<K, V> = Map<K, V>;
typedef Set<T> = HashSet<T>;

// 関数型のエイリアス
typedef Predicate<T> = bool(T);
typedef Mapper<T, U> = U(T);
typedef Reducer<T, U> = U(U, T);

// 複雑な型の簡略化
typedef EventHandler = void(Event&);
typedef StateUpdater<S> = S(S);
typedef Middleware<T> = T(T, (T) -> T);

// ============================================================
// impl ブロック（簡潔な構文）
// ============================================================

// 型パラメータを暗黙的に推論
impl Result<T, E> {  // T, E は Result<T, E> から推論
    bool is_ok() {
        match (*this) {
            Ok(_) => return true,
            Err(_) => return false,
        }
    }

    bool is_err() {
        return !is_ok();
    }

    T unwrap() {
        match (*this) {
            Ok(value) => return value,
            Err(e) => panic("Called unwrap on Err: " + e),
        }
    }

    T unwrap_or(T default_value) {
        match (*this) {
            Ok(value) => return value,
            Err(_) => return default_value,
        }
    }

    Result<U, E> map<U>(U (*f)(T)) {
        match (*this) {
            Ok(value) => return Ok(f(value)),
            Err(e) => return Err(e),
        }
    }
}

// ============================================================
// メイン関数
// ============================================================

int main() {
    // リテラル型の使用
    HttpMethod method = "GET";  // OK
    // method = "INVALID";  // コンパイルエラー

    HttpCode code = makeRequest(method, "/api/users");
    println("Response code: " + code);

    // ユニオン型の使用
    Result<int> result = divide(10, 2);
    processResult(result);

    Result<int> error = divide(10, 0);
    processResult(error);

    // Option型の使用
    Option<string> user = findUser(123);
    match (user) {
        Some(name) => println("Found user: " + name),
        None => println("User not found"),
    }

    // JSONの例
    JsonValue json = Object({
        {"name", String("Alice")},
        {"age", Number(30)},
        {"active", Bool(true)},
        {"scores", Array({Number(95), Number(87), Number(92)})},
    });

    processJson(json);

    return 0;
}