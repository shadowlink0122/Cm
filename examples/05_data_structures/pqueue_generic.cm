// pqueue_generic.cm - PriorityQueue (AVL木ベース)
// O(log n) の push/pop を保証する平衡二分探索木実装

import std::io::println;
import std::io::print;

use libc {
    void* malloc(ulong size);
    void free(void* ptr);
}

// ============================================================
// AVLノード（平衡二分探索木のノード）
// ============================================================
struct AVLNode {
    int value;
    AVLNode* left;
    AVLNode* right;
    int height;
}

// ============================================================
// PriorityQueue構造体
// ============================================================
struct PQueue {
    AVLNode* root;
    int size;
}

// ============================================================
// AVLノード操作（ヘルパー関数）
// ============================================================

// ノードの高さを取得
int avl_height(AVLNode* node) {
    if (node == null) {
        return 0;
    }
    return node->height;
}

// 高さを更新
void avl_update_height(AVLNode* node) {
    if (node != null) {
        int left_h = avl_height(node->left);
        int right_h = avl_height(node->right);
        if (left_h > right_h) {
            node->height = left_h + 1;
        } else {
            node->height = right_h + 1;
        }
    }
}

// バランスファクター（左高さ - 右高さ）
int avl_balance(AVLNode* node) {
    if (node == null) {
        return 0;
    }
    return avl_height(node->left) - avl_height(node->right);
}

// 右回転 (LL case)
//     y                x
//    / \              / \
//   x   C   =>       A   y
//  / \                  / \
// A   B                B   C
AVLNode* avl_rotate_right(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* B = x->right;
    
    // 回転実行
    x->right = y;
    y->left = B;
    
    // 高さ更新
    avl_update_height(y);
    avl_update_height(x);
    
    return x;
}

// 左回転 (RR case)
//   x                  y
//  / \                / \
// A   y      =>      x   C
//    / \            / \
//   B   C          A   B
AVLNode* avl_rotate_left(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* B = y->left;
    
    // 回転実行
    y->left = x;
    x->right = B;
    
    // 高さ更新
    avl_update_height(x);
    avl_update_height(y);
    
    return y;
}

// 新しいノードを作成
AVLNode* avl_new_node(int value) {
    void* mem = malloc(sizeof(AVLNode));
    AVLNode* node = mem as AVLNode*;
    node->value = value;
    node->left = null as AVLNode*;
    node->right = null as AVLNode*;
    node->height = 1;
    return node;
}

// AVL挿入（再帰）
AVLNode* avl_insert(AVLNode* node, int value) {
    // 1. 標準BST挿入
    if (node == null) {
        return avl_new_node(value);
    }
    
    if (value < node->value) {
        node->left = avl_insert(node->left, value);
    } else {
        // 重複または大きい値は右に挿入
        node->right = avl_insert(node->right, value);
    }
    
    // 2. 高さ更新
    avl_update_height(node);
    
    // 3. バランスファクター確認
    int balance = avl_balance(node);
    
    // 4. 不均衡なら回転
    // LL case
    if (balance > 1 && node->left != null && value < node->left->value) {
        return avl_rotate_right(node);
    }
    
    // RR case
    if (balance < -1 && node->right != null && value >= node->right->value) {
        return avl_rotate_left(node);
    }
    
    // LR case
    if (balance > 1 && node->left != null && value >= node->left->value) {
        node->left = avl_rotate_left(node->left);
        return avl_rotate_right(node);
    }
    
    // RL case
    if (balance < -1 && node->right != null && value < node->right->value) {
        node->right = avl_rotate_right(node->right);
        return avl_rotate_left(node);
    }
    
    return node;
}

// 最小値ノードを見つける
AVLNode* avl_min_node(AVLNode* node) {
    AVLNode* current = node;
    while (current->left != null) {
        current = current->left;
    }
    return current;
}

// AVL削除（最小値を削除）- ポインタ渡しで結果を返す
AVLNode* avl_delete_min(AVLNode* node, int* out_value) {
    if (node == null) {
        *out_value = -1;
        return node;
    }
    
    // 左端まで進む
    if (node->left == null) {
        // このノードが最小値
        *out_value = node->value;
        AVLNode* right_child = node->right;
        free(node as void*);
        return right_child;
    }
    
    // 左に進む
    node->left = avl_delete_min(node->left, out_value);
    
    // 高さ更新
    avl_update_height(node);
    
    // バランス確認
    int balance = avl_balance(node);
    
    // RR case
    if (balance < -1 && avl_balance(node->right) <= 0) {
        return avl_rotate_left(node);
    }
    
    // RL case
    if (balance < -1 && avl_balance(node->right) > 0) {
        node->right = avl_rotate_right(node->right);
        return avl_rotate_left(node);
    }
    
    // LL case
    if (balance > 1 && avl_balance(node->left) >= 0) {
        return avl_rotate_right(node);
    }
    
    // LR case
    if (balance > 1 && avl_balance(node->left) < 0) {
        node->left = avl_rotate_left(node->left);
        return avl_rotate_right(node);
    }
    
    return node;
}

// ============================================================
// PQueue操作（ポインタベースのヘルパー関数）
// ============================================================
void pq_init(PQueue* pq) {
    pq->root = null as AVLNode*;
    pq->size = 0;
}

void pq_push(PQueue* pq, int value) {
    pq->root = avl_insert(pq->root, value);
    pq->size = pq->size + 1;
}

int pq_pop(PQueue* pq) {
    if (pq->root == null) {
        return -1;
    }
    int result = 0;
    pq->root = avl_delete_min(pq->root, &result);
    pq->size = pq->size - 1;
    return result;
}

int pq_peek(PQueue* pq) {
    if (pq->root == null) {
        return -1;
    }
    AVLNode* min = avl_min_node(pq->root);
    return min->value;
}

bool pq_is_empty(PQueue* pq) {
    return pq->size == 0;
}

int pq_len(PQueue* pq) {
    return pq->size;
}

// ============================================================
// メイン関数（デモ）
// ============================================================
int main() {
    println("=== PriorityQueue (AVL Tree) ===");
    
    // 構造体初期化リテラルを使用
    PQueue pq = {root: null as AVLNode*, size: 0};
    
    // ランダム順で挿入
    println("\nPushing items:");
    pq_push(&pq, 50); println("  push(50)");
    pq_push(&pq, 30); println("  push(30)");
    pq_push(&pq, 70); println("  push(70)");
    pq_push(&pq, 20); println("  push(20)");
    pq_push(&pq, 40); println("  push(40)");
    pq_push(&pq, 60); println("  push(60)");
    pq_push(&pq, 80); println("  push(80)");
    pq_push(&pq, 10); println("  push(10)");
    
    int size = pq_len(&pq);
    println("\nQueue size: {size}");
    int min_val = pq_peek(&pq);
    println("Peek (min): {min_val}");
    
    // ソート順で取り出し
    println("\nPopping items (sorted order):");
    while (!pq_is_empty(&pq)) {
        int val = pq_pop(&pq);
        println("  pop() = {val}");
    }
    
    println("\n=== Done ===");
    return 0;
}
