// atomic_test.cm - アトミック操作テスト
// 基本的なアトミック操作の正確性を検証
import std::io::println;
import std::mem::alloc;
import std::mem::dealloc;
import native::sync::atomic::store_i32;
import native::sync::atomic::load_i32;
import native::sync::atomic::fetch_add_i32;
import native::sync::atomic::fetch_sub_i32;
import native::sync::atomic::store_i64;
import native::sync::atomic::load_i64;
import native::sync::atomic::fetch_add_i64;

int main() {
    println("=== Atomic Test ===");

    // ============================================================
    // Test 1: 基本的なi32アトミック操作
    // ============================================================
    int* val = alloc(4) as int*;
    store_i32(val, 42);
    int v1 = load_i32(val);
    println("i32 store/load: {v1}");

    int old1 = fetch_add_i32(val, 10);
    int v2 = load_i32(val);
    println("i32 fetch_add: old={old1}, new={v2}");

    int old2 = fetch_sub_i32(val, 5);
    int v3 = load_i32(val);
    println("i32 fetch_sub: old={old2}, new={v3}");
    dealloc(val as void*);

    // ============================================================
    // Test 2: 基本的なi64アトミック操作
    // ============================================================
    long* lval = alloc(8) as long*;
    store_i64(lval, 100);
    long lv1 = load_i64(lval);
    println("i64 store/load: {lv1}");

    long old3 = fetch_add_i64(lval, 50);
    long lv2 = load_i64(lval);
    println("i64 fetch_add: old={old3}, new={lv2}");
    dealloc(lval as void*);

    // ============================================================
    // Test 3: 連続アトミック操作の一貫性
    // ============================================================
    int* counter = alloc(4) as int*;
    store_i32(counter, 0);

    int i = 0;
    while (i < 100) {
        fetch_add_i32(counter, 1);
        i = i + 1;
    }
    int result = load_i32(counter);
    println("sequential fetch_add x100: {result}");

    dealloc(counter as void*);
    println("=== Done ===");
    return 0;
}
