// thread_channel_atomic_test.cm - スレッド間通信 統合テスト
// thread + channel + atomic の組み合わせで安全なスレッド間通信を検証
//
// テスト構成:
//   1. Producer-Consumer: 複数Producerがchannelに値を送信、Consumerが集約
//   2. Atomic Counter: 複数スレッドでatomic fetch_addによる安全なインクリメント
//   3. Fan-out/Fan-in: 1つのタスクを複数ワーカーに分散、結果をchannelで集約
//   4. Atomic Flag: atomicフラグでスレッドの実行/停止を制御

import std::io::println;
import std::mem::alloc;
import std::mem::dealloc;
import std::thread::spawn;
import std::thread::spawn_with_arg;
import std::thread::join;
import std::thread::join_all;
import std::thread::sleep_ms;
import std::sync::channel::create;
import std::sync::channel::send;
import std::sync::channel::recv;
import std::sync::channel::close;
import std::sync::channel::destroy;
import std::sync::atomic::store_i32;
import std::sync::atomic::load_i32;
import std::sync::atomic::fetch_add_i32;
import std::sync::atomic::store_i64;
import std::sync::atomic::load_i64;
import std::sync::atomic::fetch_add_i64;

// ============================================================
// テスト1: Producer-Consumer パターン
// 3つのProducerスレッドが各10個の値をchannelに送信
// メインスレッドがConsumerとして全30個を受信
// ============================================================

// Producer: IDに基づいた値をchannelに送信
// argレイアウト: [channel_handle: long][producer_id: int]
void* producer(void* arg) {
    long ch = *(arg as long*);
    int id = *((arg as long + 8) as int*);

    int i = 0;
    while (i < 10) {
        // producer_id * 100 + i を送信
        long value = (id * 100 + i) as long;
        send(ch, value);
        i = i + 1;
    }
    return 0 as void*;
}

// ============================================================
// テスト2: Atomic Counter
// 4スレッドが各100回 atomic fetch_add
// 結果は必ず400になるはず
// ============================================================

// argはint*（共有アトミックカウンタへのポインタ）
void* atomic_worker(void* arg) {
    int* counter = arg as int*;
    int i = 0;
    while (i < 25) {
        fetch_add_i32(counter, 1);
        i = i + 1;
    }
    return 0 as void*;
}

// ============================================================
// テスト3: Fan-out/Fan-in パターン
// メインがN個のタスクをchannelで配信
// ワーカーがタスクを受信→処理→結果channelに送信
// ============================================================

// ワーカー: タスクchannelから値を受信し、2倍にして結果channelに送信
// argレイアウト: [task_ch: long][result_ch: long][task_count: int]
void* fanout_worker(void* arg) {
    long task_ch = *(arg as long*);
    long result_ch = *((arg as long + 8) as long*);
    int task_count = *((arg as long + 16) as int*);

    int i = 0;
    while (i < task_count) {
        long task = 0;
        recv(task_ch, &task);
        // 処理: 値を2倍にする
        long result = task * 2;
        send(result_ch, result);
        i = i + 1;
    }
    return 0 as void*;
}

// ============================================================
// テスト4: Atomicフラグによるスレッド制御
// メインスレッドがatomicフラグで子スレッドの実行を制御
// ============================================================

// argレイアウト: [flag_ptr: long][counter_ptr: long]
void* flag_worker(void* arg) {
    long flag_addr = *(arg as long*);
    long counter_addr = *((arg as long + 8) as long*);
    int* flag = flag_addr as int*;
    int* counter = counter_addr as int*;

    // フラグが1になるまでスピンウェイト（CPU負荷軽減）
    while (load_i32(flag) == 0) {
        sleep_ms(1);
    }

    // フラグが1の間カウント
    while (load_i32(flag) == 1) {
        fetch_add_i32(counter, 1);
    }

    return 0 as void*;
}

int main() {
    println("=== Thread Communication Test ===");

    // ============================================================
    // テスト1: Producer-Consumer
    // ============================================================
    println("--- Test 1: Producer-Consumer ---");

    long ch1 = create(64);

    // 3つのProducerスレッドを起動
    // 各Producerに[channel_handle, producer_id]を渡す
    void* p1_arg = alloc(16);
    *(p1_arg as long*) = ch1;
    *((p1_arg as long + 8) as int*) = 1;

    void* p2_arg = alloc(16);
    *(p2_arg as long*) = ch1;
    *((p2_arg as long + 8) as int*) = 2;

    void* p3_arg = alloc(16);
    *(p3_arg as long*) = ch1;
    *((p3_arg as long + 8) as int*) = 3;

    ulong t1 = spawn_with_arg(producer as void*, p1_arg);
    ulong t2 = spawn_with_arg(producer as void*, p2_arg);
    ulong t3 = spawn_with_arg(producer as void*, p3_arg);

    // Consumer: 30個の値を受信
    long total = 0;
    int count = 0;
    while (count < 30) {
        long val = 0;
        recv(ch1, &val);
        total = total + val;
        count = count + 1;
    }

    join(t1);
    join(t2);
    join(t3);
    destroy(ch1);
    dealloc(p1_arg);
    dealloc(p2_arg);
    dealloc(p3_arg);

    // 検証: 全30メッセージ受信
    println("received: {count} messages");
    if (count == 30) {
        println("TEST1: PASS");
    } else {
        println("TEST1: FAIL (count={count})");
    }

    // ============================================================
    // テスト2: Atomic Counter (マルチスレッド)
    // ============================================================
    println("--- Test 2: Atomic Counter ---");

    int* shared_counter = alloc(4) as int*;
    store_i32(shared_counter, 0);

    ulong at1 = spawn_with_arg(atomic_worker as void*, shared_counter as void*);
    ulong at2 = spawn_with_arg(atomic_worker as void*, shared_counter as void*);
    ulong at3 = spawn_with_arg(atomic_worker as void*, shared_counter as void*);
    ulong at4 = spawn_with_arg(atomic_worker as void*, shared_counter as void*);
    join(at1);
    join(at2);
    join(at3);
    join(at4);

    int counter_result = load_i32(shared_counter);
    println("atomic counter: {counter_result}");
    if (counter_result == 100) {
        println("TEST2: PASS");
    } else {
        println("TEST2: FAIL (expected 100)");
    }
    dealloc(shared_counter as void*);

    // ============================================================
    // テスト3: Fan-out/Fan-in
    // ============================================================
    println("--- Test 3: Fan-out/Fan-in ---");

    long task_ch = create(64);
    long result_ch = create(64);

    // 2ワーカー、各5タスク
    void* w1_arg = alloc(24);
    *(w1_arg as long*) = task_ch;
    *((w1_arg as long + 8) as long*) = result_ch;
    *((w1_arg as long + 16) as int*) = 5;

    void* w2_arg = alloc(24);
    *(w2_arg as long*) = task_ch;
    *((w2_arg as long + 8) as long*) = result_ch;
    *((w2_arg as long + 16) as int*) = 5;

    ulong w1 = spawn_with_arg(fanout_worker as void*, w1_arg);
    ulong w2 = spawn_with_arg(fanout_worker as void*, w2_arg);

    // 10個のタスクを配信 (値: 1,2,...,10)
    int ti = 1;
    while (ti <= 10) {
        send(task_ch, ti as long);
        ti = ti + 1;
    }

    // 10個の結果を受信し合計
    long result_sum = 0;
    int ri = 0;
    while (ri < 10) {
        long r = 0;
        recv(result_ch, &r);
        result_sum = result_sum + r;
        ri = ri + 1;
    }

    join(w1);
    join(w2);
    destroy(task_ch);
    destroy(result_ch);
    dealloc(w1_arg);
    dealloc(w2_arg);

    // 検証: sum(1..10) * 2 = 110
    println("fan-out result sum: {result_sum}");
    if (result_sum == 110) {
        println("TEST3: PASS");
    } else {
        println("TEST3: FAIL (expected 110)");
    }

    // ============================================================
    // テスト4: Atomicフラグ制御
    // ============================================================
    println("--- Test 4: Atomic Flag Control ---");

    int* flag = alloc(4) as int*;
    int* flag_counter = alloc(4) as int*;
    store_i32(flag, 0);
    store_i32(flag_counter, 0);

    // ワーカーに[flag_ptr, counter_ptr]を渡す
    void* flag_arg = alloc(16);
    *(flag_arg as long*) = flag as long;
    *((flag_arg as long + 8) as long*) = flag_counter as long;

    ulong ft = spawn_with_arg(flag_worker as void*, flag_arg);

    // フラグを1にしてワーカーを開始
    sleep_ms(5);
    store_i32(flag, 1);
    println("flag set to RUN");

    // 20msカウントさせる
    sleep_ms(20);

    // フラグを2にしてワーカーを停止
    store_i32(flag, 2);
    println("flag set to STOP");

    join(ft);

    int flag_result = load_i32(flag_counter);
    if (flag_result > 0) {
        println("TEST4: PASS (flag counter > 0)");
    } else {
        println("TEST4: FAIL (counter=0)");
    }

    dealloc(flag as void*);
    dealloc(flag_counter as void*);
    dealloc(flag_arg);

    println("=== Done ===");
    return 0;
}
