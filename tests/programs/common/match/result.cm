import std::io::println;
// MyResult<T, E>型とmatch式の複合テスト

// Result型をstructで表現
struct MyResult<T, E> {
    bool is_ok;
    T value;
    E error;
}

// ヘルパー関数
<T, E> MyResult<T, E> ok(T value, E dummy_error) {
    MyResult<T, E> res;
    res.is_ok = true;
    res.value = value;
    return res;
}

<T, E> MyResult<T, E> err(T dummy_value, E error) {
    MyResult<T, E> res;
    res.is_ok = false;
    res.error = error;
    return res;
}

// match式を使ったResult処理
<T, E> T unwrap_or_match(MyResult<T, E> res, T default_value) {
    return match (res.is_ok) {
        true => res.value,
        false => default_value,
    };
}

// Result状態を整数コードに変換
<T, E> int result_to_code(MyResult<T, E> res) {
    return match (res.is_ok) {
        true => 0,    // 成功
        false => -1,  // エラー
    };
}

// 安全な除算
MyResult<int, int> safe_divide(int a, int b) {
    if (b == 0) {
        return err(0, -1);
        // エラーコード -1
    }
    return ok(a / b, 0);
}

// 境界チェック付き配列アクセス（シミュレート）
MyResult<int, int> safe_get(int index, int max_index) {
    if (index < 0) {
        return err(0, -1);
        // index < 0
    }
    if (index >= max_index) {
        return err(0, -2);
        // index >= max
    }
    return ok(index * 10, 0);
    // 値を返す
}

int main() {
    // 正常な除算
    MyResult<int, int> r1 = safe_divide(10, 2);
    int v1 = unwrap_or_match(r1, -999);
    int c1 = result_to_code(r1);
    println("safe_divide(10, 2) = {v1}, code = {c1}");

    // ゼロ除算
    MyResult<int, int> r2 = safe_divide(10, 0);
    int v2 = unwrap_or_match(r2, -999);
    int c2 = result_to_code(r2);
    println("safe_divide(10, 0) = {v2}, code = {c2}");

    // 境界チェック - 正常
    MyResult<int, int> r3 = safe_get(3, 10);
    int v3 = unwrap_or_match(r3, -999);
    println("safe_get(3, 10) = {v3}");

    // 境界チェック - 範囲外
    MyResult<int, int> r4 = safe_get(15, 10);
    int v4 = unwrap_or_match(r4, -999);
    println("safe_get(15, 10) = {v4}");

    // 連鎖処理のシミュレート
    MyResult<int, int> step1 = safe_divide(100, 2);
    MyResult<int, int> step2 = safe_divide(step1.value, 5);
    int final_result = match (step1.is_ok) {
        true => match (step2.is_ok) {
            true => step2.value,
            false => -1,
        },
        false => -1,
    };
    println("100 / 2 / 5 = {final_result}");

    return 0;
}
