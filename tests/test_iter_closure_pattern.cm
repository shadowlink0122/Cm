// iter_closureパターンのテスト
// このパターンはO2/O3で無限ループを引き起こすため、自動的にO0に下げられる

// イテレータ的な構造体
struct Iterator<T> {
    T* data;
    int size;
    int index;
}

impl<T> Iterator<T> {
    self(T* data, int size) {
        self.data = data;
        self.size = size;
        self.index = 0;
    }

    bool has_next() {
        return self.index < self.size;
    }

    T next() {
        T value = self.data[self.index];
        self.index = self.index + 1;
        return value;
    }

    // mapメソッド（クロージャを受け取る）
    <U> Iterator<U> map(U (*transform)(T)) {
        // 簡略化された実装
        Iterator<U> result;
        return result;
    }

    // filterメソッド（クロージャを受け取る）
    Iterator<T> filter(bool (*predicate)(T)) {
        // 簡略化された実装
        return *self;
    }
}

int main() {
    int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    Iterator<int> iter = Iterator<int>(data, 10);

    // iter_closureパターン：イテレータとクロージャの組み合わせ
    // これがO2/O3で無限ループを引き起こす可能性がある

    // クロージャ（ラムダ）を使用
    auto double_it = (int x) => { return x * 2; };
    auto is_even = (int x) => { return x % 2 == 0; };

    // map と filter のチェーン（問題のパターン）
    // iter.map(double_it).filter(is_even);

    // 通常のイテレーション
    while (iter.has_next()) {
        int value = iter.next();
        int doubled = double_it(value);
        if (is_even(doubled)) {
            // 処理
        }
    }

    return 0;
}