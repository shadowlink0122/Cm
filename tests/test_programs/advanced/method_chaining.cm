// メソッドチェーンのテスト
// 現在のCmコンパイラの仕様に合わせて書き換え

import std::io::println;

struct Point {
    int x;
    int y;
}

impl Point {
    self(int x, int y) {
        self.x = x;
        self.y = y;
    }
}

// メソッドを外部関数として定義（チェーン用）
Point Point__move(Point p, int dx, int dy) {
    return Point { x: p.x + dx, y: p.y + dy };
}

int Point__get_sum(Point p) {
    return p.x + p.y;
}

struct Wrapper {
    Point p;
}

impl Wrapper {
    self(Point p) {
        self.p = p;
    }
}

Point Wrapper__get_point(Wrapper w) {
    return w.p;
}

Wrapper Wrapper__clone(Wrapper w) {
    return Wrapper { p: w.p };
}

int main() {
    println("=== Method Chaining Test ===");

    // 1. シンプルなチェーン（外部関数経由）
    Point p = Point(10, 20);
    println("p: ({p.x}, {p.y})");

    // チェーンを分解: p.move(5, 5).get_sum()
    Point moved = Point__move(p, 5, 5);
    int sum = Point__get_sum(moved);
    println("After move(5,5): ({moved.x}, {moved.y})");
    println("Sum: {sum}");

    if (sum == 40) {
        println("Test 1: PASS");
    } else {
        println("Test 1: FAIL (Got {sum})");
    }

    // 2. Wrapper経由
    Wrapper w = Wrapper { p: Point { x: 1, y: 2 } };
    Wrapper cloned = Wrapper__clone(w);
    Point wp = Wrapper__get_point(cloned);
    println("Cloned point: ({wp.x}, {wp.y})");

    if (wp.x == 1) {
        println("Test 2: PASS");
    } else {
        println("Test 2: FAIL (Got {wp.x})");
    }

    // 3. 多重チェーン
    Wrapper w2 = Wrapper__clone(Wrapper__clone(w));
    Point wp2 = Wrapper__get_point(w2);
    Point moved2 = Point__move(wp2, 10, 10);
    int val = Point__get_sum(moved2);
    println("Multiple chain result: {val}");

    if (val == 23) {
        println("Test 3: PASS");
    } else {
        println("Test 3: FAIL (Got {val})");
    }

    println("=== Test Completed ===");
    return 0;
}
