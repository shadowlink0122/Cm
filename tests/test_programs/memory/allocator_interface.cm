// アロケータインターフェースのテスト（値検証付き）
module test;

import std::mem::{Allocator, DefaultAllocator, malloc, free};

struct Data {
    int value;
    int flags;
}

int main() {
    // 直接FFI使用 - int配列で値検証
    void* raw1 = malloc(sizeof(int) * 4);
    int* arr = raw1 as int*;
    arr[0] = 10;
    arr[1] = 20;
    arr[2] = 30;
    arr[3] = 40;
    
    if (arr[0] == 10 && arr[1] == 20 && arr[2] == 30 && arr[3] == 40) {
        println("malloc int array: ok");
    } else {
        println("malloc int array: FAILED");
    }
    free(raw1);
    println("free: ok");
    
    // DefaultAllocator使用 - 構造体で値検証
    DefaultAllocator alloc = DefaultAllocator{};
    
    void* raw2 = alloc.alloc(sizeof(Data));
    Data* d = raw2 as Data*;
    d->value = 42;
    d->flags = 7;
    
    if (d->value == 42 && d->flags == 7) {
        println("alloc struct: ok");
    } else {
        println("alloc struct: FAILED");
    }
    
    // reallocateで拡張後も値が保持されるか検証
    void* raw3 = alloc.reallocate(raw2, sizeof(Data) * 2);
    Data* d2 = raw3 as Data*;
    
    if (d2[0].value == 42 && d2[0].flags == 7) {
        println("reallocate preserves data: ok");
    } else {
        println("reallocate preserves data: FAILED");
    }
    
    // 拡張分に新しい値を設定
    d2[1].value = 100;
    d2[1].flags = 15;
    
    if (d2[1].value == 100 && d2[1].flags == 15) {
        println("reallocate new space: ok");
    } else {
        println("reallocate new space: FAILED");
    }
    
    alloc.dealloc(raw3);
    println("dealloc: ok");
    
    return 0;
}
