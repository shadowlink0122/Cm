// Vector<Vector<T>>ライフサイクルテスト
// ネストコレクションでコンストラクタ・デストラクタが正しく呼ばれることを検証
//
// 現在の制限:
// - Vector<T>のデストラクタは自身のdataポインタをfreeするのみ
// - T=Vector<int>の場合、内側のVectorのデストラクタは呼ばれない（v0.14.0で対応予定）
//
// このテストでは:
// 1. 外側/内側両方のコンストラクタが呼ばれること
// 2. 明示的なスコープ終了でデストラクタが呼ばれること
// を検証する

import std::io::println;
import std::collections::vector::*;

int main() {
    println("=== Nested Vector Lifecycle Test ===");

    // 1. 内側Vector<int>のコンストラクタ
    println("1. Inner Vector<int> construction:");
    Vector<int> inner1();
    inner1.push(1);
    inner1.push(2);
    int len1 = inner1.len();
    println("  inner1.len() = {len1}");
    if (len1 != 2) {
        println("FAIL: expected 2");
        return 1;
    }

    // 2. 外側Vector<Vector<int>>のコンストラクタ
    println("2. Outer Vector<Vector<int>> construction:");
    Vector<Vector<int>> matrix();
    int mlen = matrix.len();
    println("  matrix.len() = {mlen} (empty)");
    if (mlen != 0) {
        println("FAIL: expected 0");
        return 1;
    }

    // 3. 内側を外側にpush（moveセマンティクス）
    println("3. Push inner to outer (with move):");
    matrix.push(move inner1);
    mlen = matrix.len();
    println("  matrix.len() = {mlen}");
    if (mlen != 1) {
        println("FAIL: expected 1");
        return 1;
    }

    // 4. 外側からgetして内側にアクセス（参照を取得）
    println("4. Access inner via get:");
    Vector<int>* row0 = matrix.get(0);
    int r0len = (*row0).len();
    println("  row0.len() = {r0len}");
    if (r0len != 2) {
        println("FAIL: expected 2");
        return 1;
    }

    int v0 = *(*row0).get(0);
    int v1 = *(*row0).get(1);
    println("  row0: [{v0}, {v1}]");
    if (v0 != 1 || v1 != 2) {
        println("FAIL: expected [1, 2]");
        return 1;
    }

    // 5. 2つ目の行を追加
    println("5. Add second row:");
    Vector<int> inner2();
    inner2.push(10);
    inner2.push(20);
    inner2.push(30);
    matrix.push(move inner2);
    mlen = matrix.len();
    println("  matrix.len() = {mlen}");
    if (mlen != 2) {
        println("FAIL: expected 2");
        return 1;
    }

    // 6. 2行目にアクセス（参照を取得）
    println("6. Access second row:");
    Vector<int>* row1 = matrix.get(1);
    int r1len = (*row1).len();
    println("  row1.len() = {r1len}");
    if (r1len != 3) {
        println("FAIL: expected 3");
        return 1;
    }

    int v10 = *(*row1).get(0);
    int v11 = *(*row1).get(1);
    int v12 = *(*row1).get(2);
    println("  row1: [{v10}, {v11}, {v12}]");
    if (v10 != 10 || v11 != 20 || v12 != 30) {
        println("FAIL: expected [10, 20, 30]");
        return 1;
    }

    // 7. 複数操作後の一貫性確認
    println("7. Consistency check:");

    // 再度row0にアクセスして変更されていないこと（参照を取得）
    Vector<int>* row0_again = matrix.get(0);
    int r0v0 = *(*row0_again).get(0);
    int r0v1 = *(*row0_again).get(1);
    println("  row0 again: [{r0v0}, {r0v1}]");
    if (r0v0 != 1 || r0v1 != 2) {
        println("FAIL: row0 was corrupted");
        return 1;
    }

    println("=== All Nested Vector Lifecycle Tests PASSED ===");

    // 注意: ここでmatrix, row0, row1などがスコープを抜ける
    // 外側matrixのデストラクタは呼ばれるが、
    // 現在の実装では内側Vector<int>のデストラクタは呼ばれない
    // これはv0.14.0で対応予定

    return 0;
}
