// 完全LLVMナップサックDP - 2次元配列版
// dp[i][w] = アイテム0..i-1を使って容量wでの最大価値
// println以外は全てLLVMインラインアセンブリで実装

int main() {
#ifdef __x86_64__
    println("=== Pure LLVM Knapsack DP (2D Array) ===");
    println("Items: [(w=2,v=3), (w=3,v=4), (w=4,v=5)]");
    println("Capacity: 7");

    // 2次元DP配列: dp[n_items+1][capacity+1] = dp[4][8]
    // 行優先レイアウト: dp[i][w] = base + (i * 8 + w) * 4
    int[32] dp = [
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[0][0..7] - アイテムなし
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[1][0..7] - アイテム0まで
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[2][0..7] - アイテム1まで
    0, 0, 0, 0, 0, 0, 0, 0   // dp[3][0..7] - アイテム2まで
    ];

    // アイテムの重さと価値
    int[3] weights = [2, 3, 4];
    int[3] values = [3, 4, 5];

    // ポインタを取得
    int* dp_ptr = &dp[0];
    int* w_ptr = &weights[0];
    int* v_ptr = &values[0];

    // ループ変数（Cm側で管理）
    int i = 0;
    int w = 0;

    // 一時変数（全てLLVMにレジスタ割り当てを委譲）
    int wi = 0;     // weights[i-1]
    int vi = 0;     // values[i-1]
    int dp_prev = 0; // dp[i-1][w]
    int cand = 0;   // 候補値
    long idx = 0;   // 64bitインデックス（メモリアクセス用）
    int tmp2 = 0;   // スクラッチ2

    // 2次元DP更新
    // 全レジスタをLLVMオペランド制約で管理（ハードコードレジスタなし）
    __asm__(`
    # 外側ループ: i = 1
    movl $$1, ${+r:i}

    1:  # outer_loop
    # i > 3 なら終了
    cmpl $$3, ${+r:i}
    jg 5f

    # 内側ループ: w = 0
    movl $$0, ${+r:w}

    2:  # inner_loop
    # w > 7 なら次のアイテムへ
    cmpl $$7, ${+r:w}
    jg 4f

    # weights[i-1] を取得
    movl ${+r:i}, ${+r:tmp2}
    decl ${+r:tmp2}
    movslq ${+r:tmp2}, ${+r:idx}
    movl (${r:w_ptr}, ${+r:idx}, 4), ${+r:wi}

    # dp[i-1][w]のオフセット計算: (i-1) * 8 + w
    movl ${+r:i}, ${+r:tmp2}
    decl ${+r:tmp2}
    shll $$3, ${+r:tmp2}
    addl ${+r:w}, ${+r:tmp2}
    movslq ${+r:tmp2}, ${+r:idx}
    movl (${r:dp_ptr}, ${+r:idx}, 4), ${+r:dp_prev}

    # w < weights[i-1] なら dp[i][w] = dp[i-1][w]
    cmpl ${+r:wi}, ${+r:w}
    jl 3f

    # values[i-1] を取得
    movl ${+r:i}, ${+r:tmp2}
    decl ${+r:tmp2}
    movslq ${+r:tmp2}, ${+r:idx}
    movl (${r:v_ptr}, ${+r:idx}, 4), ${+r:vi}

    # dp[i-1][w - weight]のオフセット計算
    movl ${+r:i}, ${+r:tmp2}
    decl ${+r:tmp2}
    shll $$3, ${+r:tmp2}
    movl ${+r:w}, ${+r:cand}
    subl ${+r:wi}, ${+r:cand}
    addl ${+r:cand}, ${+r:tmp2}
    movslq ${+r:tmp2}, ${+r:idx}
    movl (${r:dp_ptr}, ${+r:idx}, 4), ${+r:cand}

    # cand = dp[i-1][w-weight] + value
    addl ${+r:vi}, ${+r:cand}

    # new_val = max(dp[i-1][w], cand)
    cmpl ${+r:dp_prev}, ${+r:cand}
    cmovlel ${+r:dp_prev}, ${+r:cand}
    movl ${+r:cand}, ${+r:dp_prev}

    3:  # store_dp
    # dp[i][w]のオフセット計算: i * 8 + w
    movl ${+r:i}, ${+r:tmp2}
    shll $$3, ${+r:tmp2}
    addl ${+r:w}, ${+r:tmp2}
    movslq ${+r:tmp2}, ${+r:idx}
    movl ${+r:dp_prev}, (${r:dp_ptr}, ${+r:idx}, 4)

    # w++
    incl ${+r:w}
    jmp 2b

    4:  # next_item
    # i++
    incl ${+r:i}
    jmp 1b

    5:  # done
    `);

    // =========================================
    // 最終結果表示
    // =========================================
    println("\n=== 2D DP Table (last row) ===");
    // dp[3][w] = dp[3 * 8 + w] = dp[24 + w]
    for (int k = 2; k <= 7; k++) {
        print("dp[3][");
        print(k);
        print("]=");
        println(dp[24 + k]);
    }

    println("\n=== Verification ===");
    if (dp[31] == 9) {
        println("Knapsack DP: PASS (optimal = 9)");
    } else {
        print("Expected 9, got ");
        println(dp[31]);
    }

#else
    // ARM64版
    println("=== Pure LLVM Knapsack DP (2D Array) ===");
    println("Items: [(w=2,v=3), (w=3,v=4), (w=4,v=5)]");
    println("Capacity: 7");

    int[32] dp = [
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
    ];

    int[3] weights = [2, 3, 4];
    int[3] values = [3, 4, 5];

    int* dp_ptr = &dp[0];
    int* w_ptr = &weights[0];
    int* v_ptr = &values[0];

    int i = 0;
    int w = 0;

    // 一時変数（全てLLVMにレジスタ割り当てを委譲）
    int wi = 0;     // weights[i-1]
    int vi = 0;     // values[i-1]
    int dp_prev = 0; // dp[i-1][w]
    int cand = 0;   // 候補値
    int tmp = 0;    // スクラッチ

    // ARM64版 ナップサックDP
    // 全レジスタをLLVMオペランド制約で管理（ハードコードレジスタなし）
    // 注: LLVMがint変数にxレジスタを割り当てる場合があるため、
    //      ldr/strのlsl #2スケーリングを使わず手動バイトオフセット計算にする
    __asm__(`
    // 外側ループ: i = 1
    mov ${+r:i}, #1

    1:  // outer_loop
    cmp ${+r:i}, #3
    b.gt 5f

    // 内側ループ: w = 0
    mov ${+r:w}, #0

    2:  // inner_loop
    cmp ${+r:w}, #7
    b.gt 4f

    // weights[i-1] を取得
    sub ${+r:tmp}, ${+r:i}, #1
    lsl ${+r:tmp}, ${+r:tmp}, #2
    ldr ${+r:wi}, [${r:w_ptr}, ${+r:tmp}]

    // dp[i-1][w]のオフセット計算: ((i-1) * 8 + w) * 4
    sub ${+r:tmp}, ${+r:i}, #1
    lsl ${+r:tmp}, ${+r:tmp}, #3
    add ${+r:tmp}, ${+r:tmp}, ${+r:w}
    lsl ${+r:tmp}, ${+r:tmp}, #2
    ldr ${+r:dp_prev}, [${r:dp_ptr}, ${+r:tmp}]

    // w < weights[i-1] なら dp[i][w] = dp[i-1][w]
    cmp ${+r:w}, ${+r:wi}
    b.lt 3f

    // values[i-1] を取得
    sub ${+r:tmp}, ${+r:i}, #1
    lsl ${+r:tmp}, ${+r:tmp}, #2
    ldr ${+r:vi}, [${r:v_ptr}, ${+r:tmp}]

    // dp[i-1][w - weight]のオフセット計算
    sub ${+r:tmp}, ${+r:i}, #1
    lsl ${+r:tmp}, ${+r:tmp}, #3
    sub ${+r:cand}, ${+r:w}, ${+r:wi}
    add ${+r:tmp}, ${+r:tmp}, ${+r:cand}
    lsl ${+r:tmp}, ${+r:tmp}, #2
    ldr ${+r:cand}, [${r:dp_ptr}, ${+r:tmp}]

    // cand = dp[i-1][w-weight] + value
    add ${+r:cand}, ${+r:cand}, ${+r:vi}

    // new_val = max(dp[i-1][w], cand)
    cmp ${+r:cand}, ${+r:dp_prev}
    csel ${+r:dp_prev}, ${+r:cand}, ${+r:dp_prev}, gt

    3:  // store_dp
    // dp[i][w]のオフセット計算: (i * 8 + w) * 4
    lsl ${+r:tmp}, ${+r:i}, #3
    add ${+r:tmp}, ${+r:tmp}, ${+r:w}
    lsl ${+r:tmp}, ${+r:tmp}, #2
    str ${+r:dp_prev}, [${r:dp_ptr}, ${+r:tmp}]

    // w++
    add ${+r:w}, ${+r:w}, #1
    b 2b

    4:  // next_item
    add ${+r:i}, ${+r:i}, #1
    b 1b

    5:  // done
    `);

    println("\n=== 2D DP Table (last row) ===");
    for (int k = 2; k <= 7; k++) {
        print("dp[3][");
        print(k);
        print("]=");
        println(dp[24 + k]);
    }

    println("\n=== Verification ===");
    if (dp[31] == 9) {
        println("Knapsack DP: PASS (optimal = 9)");
    } else {
        print("Expected 9, got ");
        println(dp[31]);
    }

#end
    return 0;
}
