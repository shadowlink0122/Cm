// 完全LLVMナップサックDP - 2次元配列版
// dp[i][w] = アイテム0..i-1を使って容量wでの最大価値
// println以外は全てLLVMインラインアセンブリで実装

int main() {
#ifdef __x86_64__
    println("=== Pure LLVM Knapsack DP (2D Array) ===");
    println("Items: [(w=2,v=3), (w=3,v=4), (w=4,v=5)]");
    println("Capacity: 7");

    // 2次元DP配列: dp[n_items+1][capacity+1] = dp[4][8]
    // 行優先レイアウト: dp[i][w] = base + (i * 8 + w) * 4
    int[32] dp = [
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[0][0..7] - アイテムなし
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[1][0..7] - アイテム0まで
    0, 0, 0, 0, 0, 0, 0, 0,  // dp[2][0..7] - アイテム1まで
    0, 0, 0, 0, 0, 0, 0, 0   // dp[3][0..7] - アイテム2まで
    ];

    // アイテムの重さと価値
    int[3] weights = [2, 3, 4];
    int[3] values = [3, 4, 5];

    // ポインタを取得
    int* dp_ptr = &dp[0];
    int* w_ptr = &weights[0];
    int* v_ptr = &values[0];

    // ループ変数（Cm側で管理）
    int i = 0;
    int w = 0;

    // 2次元DP更新
    // 最小限の+r制約（i, wのみ）
    __asm__(`
    # callee-savedレジスタを保存
    pushq %r12
    pushq %r13
    pushq %r14
    pushq %r15
    pushq %rbx

    # ポインタをr8-r10に保存（r制約）
    movq ${r:dp_ptr}, %r8
    movq ${r:w_ptr}, %r12
    movq ${r:v_ptr}, %r13

    # 定数: n_items=3, capacity=7, row_size=8

    # 外側ループ: i = 1
    movl $$1, ${+r:i}

    1:  # outer_loop
    # i > 3 なら終了
    cmpl $$3, ${+r:i}
    jg 5f

    # 内側ループ: w = 0
    movl $$0, ${+r:w}

    2:  # inner_loop
    # w > 7 なら次のアイテムへ
    cmpl $$7, ${+r:w}
    jg 4f

    # weights[i-1] を %r14d に取得
    movl ${+r:i}, %eax
    decl %eax
    movslq %eax, %rax
    movl (%r12, %rax, 4), %r14d

    # dp[i-1][w]のオフセット計算: (i-1) * 8 + w
    movl ${+r:i}, %eax
    decl %eax
    shll $$3, %eax          # (i-1) * 8
    addl ${+r:w}, %eax
    movslq %eax, %rax
    movl (%r8, %rax, 4), %r15d   # dp[i-1][w]

    # w < weights[i-1] なら dp[i][w] = dp[i-1][w]
    cmpl %r14d, ${+r:w}
    jl 3f

    # values[i-1] を %ebx に取得
    movl ${+r:i}, %eax
    decl %eax
    movslq %eax, %rax
    movl (%r13, %rax, 4), %ebx

    # dp[i-1][w - weight]のオフセット計算
    movl ${+r:i}, %eax
    decl %eax
    shll $$3, %eax
    movl ${+r:w}, %ecx
    subl %r14d, %ecx
    addl %ecx, %eax
    movslq %eax, %rax
    movl (%r8, %rax, 4), %ecx   # dp[i-1][w-weight]

    # cand = dp[i-1][w-weight] + value
    addl %ebx, %ecx

    # new_val = max(dp[i-1][w], cand)
    cmpl %r15d, %ecx
    cmovlel %r15d, %ecx
    movl %ecx, %r15d

    3:  # store_dp
    # dp[i][w]のオフセット計算: i * 8 + w
    movl ${+r:i}, %eax
    shll $$3, %eax
    addl ${+r:w}, %eax
    movslq %eax, %rax
    movl %r15d, (%r8, %rax, 4)   # dp[i][w] = new_val

    # w++
    incl ${+r:w}
    jmp 2b

    4:  # next_item
    # i++
    incl ${+r:i}
    jmp 1b

    5:  # done
    popq %rbx
    popq %r15
    popq %r14
    popq %r13
    popq %r12
    `);

    // =========================================
    // 最終結果表示
    // =========================================
    println("\n=== 2D DP Table (last row) ===");
    // dp[3][w] = dp[3 * 8 + w] = dp[24 + w]
    for (int k = 2; k <= 7; k++) {
        print("dp[3][");
        print(k);
        print("]=");
        println(dp[24 + k]);
    }

    println("\n=== Verification ===");
    if (dp[31] == 9) {
        println("Knapsack DP: PASS (optimal = 9)");
    } else {
        print("Expected 9, got ");
        println(dp[31]);
    }

#else
    // ARM64版
    println("=== Pure LLVM Knapsack DP (2D Array) ===");
    println("Items: [(w=2,v=3), (w=3,v=4), (w=4,v=5)]");
    println("Capacity: 7");

    int[32] dp = [
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0
    ];

    int[3] weights = [2, 3, 4];
    int[3] values = [3, 4, 5];

    int* dp_ptr = &dp[0];
    int* w_ptr = &weights[0];
    int* v_ptr = &values[0];

    int i = 0;
    int w = 0;

    // ARM64版 ナップサックDP
    // レジスタ割り当て:
    //   x8  = dp_ptr
    //   x9  = w_ptr
    //   x10 = v_ptr
    //   w11 = weights[i-1]
    //   w12 = dp[i-1][w]
    //   w13 = values[i-1]
    //   w14 = dp[i-1][w-weight] / cand
    //   w15 = temp
    __asm__(`
    // ポインタをレジスタに保存
    mov x8, ${r:dp_ptr}
    mov x9, ${r:w_ptr}
    mov x10, ${r:v_ptr}

    // 外側ループ: i = 1
    mov ${+r:i}, #1

    1:  // outer_loop
    cmp ${+r:i}, #3
    b.gt 5f

    // 内側ループ: w = 0
    mov ${+r:w}, #0

    2:  // inner_loop
    cmp ${+r:w}, #7
    b.gt 4f

    // weights[i-1] を w11 に取得
    sub w15, ${+r:i}, #1
    sxtw x15, w15
    ldr w11, [x9, x15, lsl #2]

    // dp[i-1][w]のオフセット計算: (i-1) * 8 + w
    sub w15, ${+r:i}, #1
    lsl w15, w15, #3
    add w15, w15, ${+r:w}
    sxtw x15, w15
    ldr w12, [x8, x15, lsl #2]

    // w < weights[i-1] なら dp[i][w] = dp[i-1][w]
    cmp ${+r:w}, w11
    b.lt 3f

    // values[i-1] を w13 に取得
    sub w15, ${+r:i}, #1
    sxtw x15, w15
    ldr w13, [x10, x15, lsl #2]

    // dp[i-1][w - weight]のオフセット計算
    sub w15, ${+r:i}, #1
    lsl w15, w15, #3
    sub w14, ${+r:w}, w11
    add w15, w15, w14
    sxtw x15, w15
    ldr w14, [x8, x15, lsl #2]

    // cand = dp[i-1][w-weight] + value
    add w14, w14, w13

    // new_val = max(dp[i-1][w], cand)
    cmp w14, w12
    csel w12, w14, w12, gt

    3:  // store_dp
    // dp[i][w]のオフセット計算: i * 8 + w
    lsl w15, ${+r:i}, #3
    add w15, w15, ${+r:w}
    sxtw x15, w15
    str w12, [x8, x15, lsl #2]

    // w++
    add ${+r:w}, ${+r:w}, #1
    b 2b

    4:  // next_item
    add ${+r:i}, ${+r:i}, #1
    b 1b

    5:  // done
    `);

    println("\n=== 2D DP Table (last row) ===");
    for (int k = 2; k <= 7; k++) {
        print("dp[3][");
        print(k);
        print("]=");
        println(dp[24 + k]);
    }

    println("\n=== Verification ===");
    if (dp[31] == 9) {
        println("Knapsack DP: PASS (optimal = 9)");
    } else {
        print("Expected 9, got ");
        println(dp[31]);
    }

#end
    return 0;
}
