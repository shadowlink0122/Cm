// tests/std/asm/advanced.cm
// std::asm 高度なアセンブリ命令テスト
// 演算、ストア、ロード操作

import std::io::println;
import std::asm::{asm, volatile_asm, is_x86, is_arm64};

int main() {
    println("=== asm/advanced test ===");
    
    // ============================================================
    // レジスタ演算テスト
    // ============================================================
    println("--- register ops ---");
    
    if (is_x86()) {
        // x86: xor eax, eax (ゼロクリア)
        asm("xorl %eax, %eax");
        println("x86 xor: ok");
        
        // x86: add/sub
        asm("movl $10, %eax");
        asm("addl $5, %eax");   // eax = 15
        asm("subl $3, %eax");   // eax = 12
        println("x86 add/sub: ok");
        
        // x86: inc/dec
        asm("incl %eax");
        asm("decl %eax");
        println("x86 inc/dec: ok");
        
    } else if (is_arm64()) {
        // ARM64: mov, add, sub
        asm("mov x0, #0");
        println("arm64 mov: ok");
        
        asm("mov x1, #10");
        asm("add x0, x1, #5");   // x0 = 15
        asm("sub x0, x0, #3");   // x0 = 12
        println("arm64 add/sub: ok");
        
    } else {
        println("unknown arch: skip");
    }
    
    // ============================================================
    // ビット演算テスト
    // ============================================================
    println("--- bitwise ops ---");
    
    if (is_x86()) {
        asm("movl $0xFF, %eax");
        asm("andl $0x0F, %eax");  // eax = 0x0F
        asm("orl $0xF0, %eax");   // eax = 0xFF
        asm("xorl $0xFF, %eax");  // eax = 0x00
        println("x86 and/or/xor: ok");
        
        asm("movl $1, %eax");
        asm("shll $4, %eax");    // eax = 16
        asm("shrl $2, %eax");    // eax = 4
        println("x86 shl/shr: ok");
        
    } else if (is_arm64()) {
        asm("mov x0, #0xFF");
        asm("and x0, x0, #0x0F");
        asm("orr x0, x0, #0xF0");
        asm("eor x0, x0, #0xFF");
        println("arm64 and/orr/eor: ok");
        
        asm("mov x0, #1");
        asm("lsl x0, x0, #4");   // x0 = 16
        asm("lsr x0, x0, #2");   // x0 = 4
        println("arm64 lsl/lsr: ok");
        
    } else {
        println("unknown arch: skip");
    }
    
    // ============================================================
    // スタック操作テスト
    // ============================================================
    println("--- stack ops ---");
    
    if (is_x86()) {
        // push/pop（スタック操作）
        asm("pushq %rax");
        asm("popq %rax");
        println("x86 push/pop: ok");
        
    } else if (is_arm64()) {
        // ARM64: stp/ldp（ペアレジスタ）
        asm("stp x0, x1, [sp, #-16]!");
        asm("ldp x0, x1, [sp], #16");
        println("arm64 stp/ldp: ok");
        
    } else {
        println("unknown arch: skip");
    }
    
    // ============================================================
    // 複合テスト - 連続操作
    // ============================================================
    println("--- complex sequence ---");
    
    if (is_x86()) {
        volatile_asm("movl $100, %eax");
        volatile_asm("movl $50, %ebx");
        volatile_asm("addl %ebx, %eax");  // eax = 150
        volatile_asm("imull $2, %eax");   // eax = 300
        println("x86 complex: ok");
        
    } else if (is_arm64()) {
        volatile_asm("mov x0, #100");
        volatile_asm("mov x1, #50");
        volatile_asm("add x0, x0, x1");   // x0 = 150
        volatile_asm("lsl x0, x0, #1");   // x0 = 300
        println("arm64 complex: ok");
        
    } else {
        println("unknown arch: skip");
    }
    
    println("=== advanced complete ===");
    return 0;
}
