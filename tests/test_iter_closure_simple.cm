// シンプルなiter_closureパターンテスト
// 複数のクロージャとイテレータ関数を含む

int double_it(int x) {
    return x * 2;
}

int is_even(int x) {
    return x % 2;
}

// イテレータのシミュレーション
int iter_next(int* data, int index) {
    return data[index];
}

// map関数のシミュレーション
int map_transform(int value) {
    return value * 2;
}

// filter関数のシミュレーション
int filter_predicate(int value) {
    return value % 2 == 0 ? 1 : 0;
}

// クロージャ風の関数を多数定義
int closure_1(int x) { return x + 1; }
int closure_2(int x) { return x + 2; }
int closure_3(int x) { return x + 3; }
int closure_4(int x) { return x + 4; }
int closure_5(int x) { return x + 5; }
int closure_6(int x) { return x + 6; }

// lambda風の関数
int lambda_1(int x) { return x - 1; }
int lambda_2(int x) { return x - 2; }
int lambda_3(int x) { return x - 3; }
int lambda_4(int x) { return x - 4; }

int main() {
    // 複雑なmain関数（100ステートメント以上にする）
    int[10] data;

    // データ初期化
    int i = 0;
    data[0] = 1;
    data[1] = 2;
    data[2] = 3;
    data[3] = 4;
    data[4] = 5;
    data[5] = 6;
    data[6] = 7;
    data[7] = 8;
    data[8] = 9;
    data[9] = 10;

    // iter_closureパターンをシミュレート
    int result = 0;
    int temp = 0;

    // 多数の処理を追加してステートメント数を増やす
    temp = closure_1(data[0]);
    result = result + temp;
    temp = closure_2(data[1]);
    result = result + temp;
    temp = closure_3(data[2]);
    result = result + temp;
    temp = closure_4(data[3]);
    result = result + temp;
    temp = closure_5(data[4]);
    result = result + temp;
    temp = closure_6(data[5]);
    result = result + temp;

    temp = lambda_1(data[6]);
    result = result + temp;
    temp = lambda_2(data[7]);
    result = result + temp;
    temp = lambda_3(data[8]);
    result = result + temp;
    temp = lambda_4(data[9]);
    result = result + temp;

    // イテレータパターン
    int index = 0;
    int val = iter_next(data, index);
    val = map_transform(val);
    if (filter_predicate(val)) {
        result = result + val;
    }

    index = 1;
    val = iter_next(data, index);
    val = map_transform(val);
    if (filter_predicate(val)) {
        result = result + val;
    }

    index = 2;
    val = iter_next(data, index);
    val = map_transform(val);
    if (filter_predicate(val)) {
        result = result + val;
    }

    return result;
}