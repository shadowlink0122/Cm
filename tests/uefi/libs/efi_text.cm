// libs::efi_text - UEFI テキスト出力
// ConOut.OutputString をインラインASM経由で呼出し
// ASCII → UCS-2 変換もASMで実行
//
// 注意: string型は関数パラメータとして渡すとデータが壊れるため、
//       全てのインターフェースは void* + ulong で受け取る
// 注意: ASMに渡す値は全てulongにキャストすること（pushq制約）
module libs.efi_text;

// ============================================================
// テキスト出力（低レベル）
// ============================================================

/// ASCIIデータをUCS-2に変換してUEFI ConOutに出力
/// system_table: efi_mainの第2引数
/// msg_data:     ASCII文字列のポインタ（string as void*で取得）
/// msg_len:      文字列長
export void efi_puts_raw(void* system_table, void* msg_data, ulong msg_len) {
    // ConOut取得 (SystemTable + 0x40)
    ulong* st = system_table as ulong*;
    ulong con_out_addr = *(st + 8);  // 8 * 8 = offset 0x40
    void* con_out = con_out_addr as void*;

    // ConOut->OutputString 取得 (offset 0x08)
    ulong* co = con_out as ulong*;
    ulong output_fn_addr = *(co + 1);
    void* output_fn = output_fn_addr as void*;

    // ASMに渡す前にulongにキャスト（pushq制約対応）
    ulong fn_val = output_fn as ulong;
    ulong co_val = con_out as ulong;
    ulong md_val = msg_data as ulong;

    // ASCII → UCS-2 変換 + OutputString 呼出
    __asm__(`
        pushq ${r:fn_val};
        pushq ${r:co_val};
        pushq ${r:msg_len};
        pushq ${r:md_val};
        popq %r12;
        popq %rbx;
        popq %r13;
        subq $$512, %rsp;
        xorq %rcx, %rcx;
        .L_conv:
            cmpq %rbx, %rcx;
            jge .L_done;
            movzbl (%r12, %rcx), %eax;
            movw %ax, (%rsp, %rcx, 2);
            incq %rcx;
            jmp .L_conv;
        .L_done:
            movw $$0, (%rsp, %rcx, 2);
            movq %r13, %rcx;
            movq %rsp, %rdx;
            subq $$32, %rsp;
            callq *544(%rsp);
            addq $$552, %rsp
    `);
}

/// NUL終端文字列の長さを計算（UEFI環境用、ランタイム不要）
export ulong efi_strlen(void* data) {
    ulong len = 0;
    utiny* p = data as utiny*;
    while (*(p + len) != 0) {
        len += 1;
    }
    return len;
}

/// 文字列を出力（長さ自動計算）
/// system_table: efi_mainの第2引数
/// msg_data:     NUL終端ASCII文字列のポインタ
export void efi_print(void* system_table, void* msg_data) {
    ulong len = efi_strlen(msg_data);
    efi_puts_raw(system_table, msg_data, len);
}

/// 文字列を改行付きで出力（長さ自動計算）
export void efi_println(void* system_table, void* msg_data) {
    efi_print(system_table, msg_data);
    // "\r\n" を直接出力
    string crlf = "\r\n";
    void* crlf_data = crlf as void*;
    efi_puts_raw(system_table, crlf_data, 2);
}

/// 画面クリア
export void efi_clear_screen(void* system_table) {
    // ConOut取得 (SystemTable + 0x40)
    ulong* st = system_table as ulong*;
    ulong con_out_addr = *(st + 8);
    void* con_out = con_out_addr as void*;

    // ConOut->ClearScreen 取得 (offset 0x30)
    ulong* co = con_out as ulong*;
    ulong clear_fn_addr = *(co + 6);  // 6 * 8 = offset 0x30
    void* clear_fn = clear_fn_addr as void*;

    // Win64 ABI: RCX = con_out
    ulong fn_val = clear_fn as ulong;
    ulong co_val = con_out as ulong;
    ulong result = 0;
    __asm__(`
        pushq %rbx;
        pushq %r12;
        movq ${r:fn_val}, %rbx;
        movq ${r:co_val}, %r12;
        movq %r12, %rcx;
        subq $$32, %rsp;
        callq *%rbx;
        addq $$32, %rsp;
        movq %rax, ${=r:result};
        popq %r12;
        popq %rbx
    `);
}
