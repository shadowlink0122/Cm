// std::iter::adapters - イテレータアダプタ
//
// map, filter, fold などの高階関数を提供するイテレータアダプタ。
// メソッドチェーン: iter.map(f).filter(p).collect() のような使用を想定。
//
// 注: 現在は関数ポインタの型パラメータが未サポートのため、
//     一部機能は将来実装となります。

module std.iter.adapters;

// ============================================================
// 現在実装可能な機能
// ============================================================

// TODO: 関数ポインタ型パラメータサポート後に実装
//
// /// MapIterator - 変換イテレータ
// export struct MapIterator<T, U> {
//     Iterator<T>* source;
//     U (*transform)(T);
// }
//
// impl<T, U> MapIterator<T, U> for Iterator<U> {
//     bool has_next() { return source.has_next(); }
//     U next() { return transform(source.next()); }
// }
//
// /// FilterIterator - フィルタイテレータ
// export struct FilterIterator<T> {
//     Iterator<T>* source;
//     bool (*predicate)(T);
// }
//
// impl<T> FilterIterator<T> for Iterator<T> {
//     bool has_next() {
//         while (source.has_next()) {
//             if (predicate(source.peek())) {
//                 return true;
//             }
//             source.next();
//         }
//         return false;
//     }
//     T next() { return source.next(); }
// }

// ============================================================
// ユーティリティ関数
// ============================================================

/// 2つの値をスワップ
export <T> void swap(T* a, T* b) {
    T tmp = *a;
    *a = *b;
    *b = tmp;
}

// ============================================================
// 将来実装: 集約関数
// ============================================================

// /// すべての要素の合計を計算（int専用）
// export int sum(IntIterator* iter) {
//     int total = 0;
//     while (iter.has_next()) {
//         total = total + iter.next();
//     }
//     return total;
// }
//
// /// 要素数をカウント
// export int count(IntIterator* iter) {
//     int n = 0;
//     while (iter.has_next()) {
//         iter.next();
//         n = n + 1;
//     }
//     return n;
// }
//
// /// 最大値を取得（空の場合は0）
// export int max(IntIterator* iter) {
//     if (!iter.has_next()) { return 0; }
//     int result = iter.next();
//     while (iter.has_next()) {
//         int v = iter.next();
//         if (v > result) { result = v; }
//     }
//     return result;
// }
//
// /// 最小値を取得（空の場合は0）
// export int min(IntIterator* iter) {
//     if (!iter.has_next()) { return 0; }
//     int result = iter.next();
//     while (iter.has_next()) {
//         int v = iter.next();
//         if (v < result) { result = v; }
//     }
//     return result;
// }
