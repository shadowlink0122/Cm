# 2次元配列のボトルネック分析

## 実験結果

### 2次元配列（int[500][500]）のパフォーマンス

| 実装方法 | 実行時間 | C++比 | メモリ配置 |
|---------|---------|-------|-----------|
| **2D配列 IJK順** | 24.67秒 | 189倍遅い | スタック（3MB） |
| **2D配列 IKJ順** | 22.77秒 | 175倍遅い | スタック（3MB） |
| **malloc + IKJ順** | 0.11秒 | 1.2倍速い | ヒープ（連続） |
| **C++ vector** | 0.13秒 | 基準 | ヒープ |

## ボトルネック分析

### 1. スタック上の巨大配列（根本原因）

```asm
_main:
subq $0x2dd668, %rsp  # 約3MBのスタック確保
```

**問題点**：
- 3つの500×500配列（各1MB）= 約3MBがスタックに配置
- スタックメモリはキャッシュに収まりにくい
- スタックポインタからの巨大オフセットアクセス

### 2. メモリアクセスパターン

#### 2次元配列のアセンブリコード
```asm
movl 0x7d0(%r14,%rdi,4), %eax    # a[i][j]へのアクセス
movl 0x7d0(%r11,%rdi,4), %ecx    # b[i][j]へのアクセス
movl %eax, 0x7d0(%r10,%rdi,4)    # c[i][j]への書き込み
```

**問題**：
- ベースレジスタ + 大きなオフセット（0x7d0 = 2000）
- インデックス計算が複雑
- キャッシュライン活用が非効率

### 3. コンパイラ最適化の限界

```cm
// Cmの2次元配列
int[500][500] matrix;  // スタック配置が強制される

// mallocの場合
int* matrix = malloc(...);  // ヒープ配置、連続メモリ
```

**LLVMの最適化が効かない理由**：
1. スタック配列は固定位置
2. エイリアス解析が困難
3. ベクトル化が制限される

## 詳細な性能プロファイル

### メモリ階層とレイテンシ

| 階層 | サイズ | レイテンシ | 3MBスタック配列への影響 |
|------|--------|----------|-------------------|
| L1キャッシュ | 32KB | 1ns | ほとんど収まらない |
| L2キャッシュ | 256KB | 4ns | 8%しか収まらない |
| L3キャッシュ | 8MB | 12ns | 全体は収まるが、アクセスパターンが悪い |
| メインメモリ | - | 100ns | 頻繁にアクセス発生 |

### キャッシュミス率の推定

```
2D配列（スタック）の場合：
- L1ミス率: 約95%
- L2ミス率: 約80%
- L3ミス率: 約30%

malloc（ヒープ）の場合：
- L1ミス率: 約60%
- L2ミス率: 約40%
- L3ミス率: 約5%
```

## なぜmallocが200倍速いのか

### 1. メモリ配置の違い

```cm
// スタック版（遅い）
int[500][500] a;  // RSP - 0x2dd668からアクセス

// ヒープ版（速い）
int* a = malloc(500 * 500 * sizeof(int));  // 連続メモリ、単純なポインタ
```

### 2. アクセス効率

```asm
# スタック版のアクセス
movl 0x7d0(%r14,%rdi,4), %eax  # 複雑なアドレス計算

# ヒープ版のアクセス
movl (%rax,%rcx,4), %edx       # シンプルなインデックス
```

### 3. 最適化の可能性

| 特性 | スタック配列 | ヒープ（malloc） |
|-----|------------|--------------|
| アドレス計算 | 複雑（ベース+オフセット） | 単純（ポインタ+インデックス） |
| プリフェッチ | 困難 | 容易 |
| ベクトル化 | 制限あり | 可能 |
| ループ展開 | 効果限定 | 効果的 |

## 推奨される解決策

### 短期対策（即座に実装可能）

1. **大きな配列は自動的にヒープへ**
```cm
// コンパイラで自動変換
int[500][500] matrix;  // → 内部的にmallocを使用
```

2. **警告の追加**
```
Warning: Large array (3MB) on stack may cause performance issues
Consider using heap allocation
```

### 中期対策（設計変更が必要）

1. **スマートアレイ型の導入**
```cm
// 新しい配列型
array<int, 500, 500> matrix;  // 自動的に最適な配置を選択
```

2. **アロケータ戦略の指定**
```cm
#pragma allocator(heap)
int[500][500] matrix;  // ヒープに配置

#pragma allocator(stack)
int[10][10] small;     // スタックに配置
```

### 長期対策（言語レベルの改善）

1. **多次元スライスの実装**
```cm
int[][] matrix = new int[500][500];  // 動的2次元配列
```

2. **コンパイラの自動最適化**
- サイズに基づく自動配置決定
- アクセスパターンの分析
- 自動的なキャッシュブロッキング

## 実験コード（性能確認用）

```cm
// ボトルネックを確認するための最小コード
import std::io;

// スタック版（遅い - 24秒）
void test_stack() {
    int[500][500] a, b, c;
    // 初期化と計算...
}

// ヒープ版（速い - 0.1秒）
void test_heap() {
    int* a = malloc(500 * 500 * sizeof(int));
    int* b = malloc(500 * 500 * sizeof(int));
    int* c = malloc(500 * 500 * sizeof(int));
    // 初期化と計算...
    free(a); free(b); free(c);
}
```

## 結論

1. **2次元配列`int[500][500]`のスタック配置が200倍の性能劣化を引き起こしている**
2. **原因はメモリアクセスの非効率性とキャッシュミス**
3. **malloc使用で即座に解決可能（0.11秒まで高速化）**

### アクションアイテム

- [ ] コンパイラで大きな配列の自動ヒープ配置
- [ ] スタックサイズ警告の実装
- [ ] 多次元スライスのサポート追加
- [ ] ドキュメントでベストプラクティスを明示