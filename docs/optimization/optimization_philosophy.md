# Cm言語の最適化哲学

## 基本理念
> "正しいコードを生成し、可能な限り効率的にする。コンパイル時間は二の次。"

## 最適化レベルの再定義

### -O0: デバッグ優先
- 最適化なし
- デバッグ情報を完全保持
- **用途**: 開発・デバッグ時

### -O1: バランス型
- 基本的な最適化のみ
- コンパイル時間を考慮
- **収束**: 最大3反復
- **用途**: 日常的な開発

### -O2: 実用最適化
- 積極的な最適化
- 実用的な収束を許容
- **収束**: 最大10反復または実用的収束
- **用途**: リリースビルド

### -O3: 最大最適化
- すべての最適化を有効化
- 収束まで徹底的に反復
- **収束**: 完全収束まで（最大20反復）
- **用途**: 性能クリティカルなコード

### -Ox: 実験的最適化
- 実験的な最適化パスも含む
- プロファイルガイド最適化
- **収束**: 制限なし（ユーザー責任）
- **用途**: ベンチマーク・研究

## 最適化パスの分類

```cpp
enum class PassCategory {
    ESSENTIAL,      // 必須（すべてのレベルで実行）
    BASIC,          // 基本（-O1以上）
    AGGRESSIVE,     // 積極的（-O2以上）
    EXPERIMENTAL    // 実験的（-O3以上）
};
```

### 必須パス（ESSENTIAL）
- デッドコード削除（最低限）
- 未使用変数の削除
- 基本的な定数畳み込み

### 基本パス（BASIC）
- 定数伝播
- 共通部分式削除
- 簡単なループ最適化

### 積極的パス（AGGRESSIVE）
- 関数インライン展開
- ループ展開
- ベクトル化
- 高度なデータフロー解析

### 実験的パス（EXPERIMENTAL）
- 投機的最適化
- プロファイルベース最適化
- 機械学習ベースの最適化

## 収束戦略の詳細

### 完全収束を目指す理由
1. **決定論的な出力**: 同じ入力から常に同じ最適化結果
2. **最大の最適化機会**: すべての相互作用を活用
3. **予測可能な性能**: ベンチマークの再現性

### 収束のための工夫
```cpp
class AdaptiveOptimizer {
    // 収束しやすいパス順序
    vector<PassGroup> pass_schedule = {
        {CANONICALIZE},    // 1. 正規化
        {ANALYZE},         // 2. 解析
        {TRANSFORM},       // 3. 変換
        {OPTIMIZE},        // 4. 最適化
        {CLEANUP}          // 5. クリーンアップ
    };

    // 各グループ内で収束するまで反復
    void optimize_with_groups(Program& p) {
        for (auto& group : pass_schedule) {
            run_group_until_convergence(p, group);
        }
    }
};
```

## 効率的なバイナリのための戦略

### 1. コード配置最適化
- ホットパスの連続配置
- キャッシュ効率の改善
- 分岐予測の最適化

### 2. データ配置最適化
- 構造体のパディング最適化
- アライメント調整
- キャッシュラインを意識した配置

### 3. プラットフォーム固有最適化
```cpp
// x86-64向け
- AVX/AVX2命令の活用
- BMI/BMI2命令の活用

// ARM向け
- NEON命令の活用
- SVE/SVE2の活用

// WASM向け
- SIMD命令の活用
- メモリ成長の最小化
```

## パフォーマンス目標

| メトリクス | 目標値 | 現状 |
|-----------|--------|------|
| コードサイズ削減 | 30-40% | 検証中 |
| 実行速度向上 | 2-3x | 検証中 |
| メモリ使用量削減 | 20-30% | 検証中 |

## コンパイル時間の許容範囲

```
小規模プロジェクト（<1000行）:
  -O2: < 1秒
  -O3: < 3秒

中規模プロジェクト（<10000行）:
  -O2: < 10秒
  -O3: < 30秒

大規模プロジェクト（>10000行）:
  -O2: < 1分
  -O3: < 5分
```

## 今後の展望

### フェーズ1（現在）
- MIR最適化の完全実装
- 収束アルゴリズムの改善

### フェーズ2
- LLVM最適化パスとの統合
- プロファイルガイド最適化

### フェーズ3
- 並列最適化
- インクリメンタルコンパイル
- JITコンパイル対応

## 参考指標

```
Rust (release): 100% (基準)
Cm -O2: 95-105% (目標)
Cm -O3: 98-102% (目標)
C++ -O2: 95-100% (参考)
Go: 85-90% (参考)
```

"We optimize for correctness and efficiency, not compile time."