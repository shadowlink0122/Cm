# Cm JS/Web 相互運用性と最適化の設計詳細

本文書は、`#[target]`、`css struct`、および文字列補間の実装に関する詳細な仕様を定義します。

## 1. ビルドターゲットシステム (`#[target]`)

ソースコードレベルでターゲットプラットフォーム（Native, JS, Wasm等）に基づいてコードの包含/除外を制御します。

### 1.1. コンパイルパイプライン
ターゲットによるフィルタリングは、**AST構築後、意味解析（HIR生成）の前**に実施します。

1.  **Parser**: すべてのファイルをパースし、ASTを構築します。この段階ではターゲットに関係なく構文エラーのみをチェックします。
2.  **Attributes Check (AST Visitor)**: 新しいパス `TargetFilteringVisitor` を導入します。
    - 各 AST ノード（特に関数定義、構造体定義、インポート文などのトップレベル宣言）の属性を確認します。
    - `#[target(...)]` が存在する場合、現在のコンパイルターゲットと照合します。
    - マッチしない場合、その AST ノードを無効化（削除、または null化）します。
    - これにより、HIR生成時には無効なターゲットのコードが存在しないため、型エラーや未定義シンボルエラーが発生しません。
3.  **HIR Lowering / Type Check**: 有効なノードのみを対象に通常通り実行します。

### 1.2. 属性構文の詳細
`#[target(arg1, arg2, ...)]`
- 引数リストは `OR` 条件として扱われます（どれか1つでも一致すれば有効）。
- 引数は識別子: `active`, `js`, `web`, `wasm`, `intr` (interpreter)。
- 否定: `!native` は「Native以外」を意味します。

```cm
#[target(js)]
public void web_only_func() { ... }

#[target(!js)]
public void native_only_func() { ... }
```

### 1.3. モジュール/ファイルレベルの制御
ファイル全体の制御のために、ファイルの最初の宣言として属性を許可するか、モジュール宣言に対する属性として扱います。現状のパーサーに合わせて、トップレベルの `Attribute` ノードとして解析し、後続の全ての宣言に適用する、あるいはファイル単位のフラグとして処理します。
**決定**: ファイル単位の制御は実装が複雑になる（ファイルスコープという概念がASTに希薄）ため、まずは **宣言単位（関数、構造体、impl、import）** でのサポートを基本とします。

## 2. CSS統合 (`css struct`)

型安全なCSS定義を提供し、JSオブジェクトとしての生成を最適化します。

### 2.1. 構文と意味論

新しいキーワードではなく、既存の `struct` に `#[css]` 属性を付与する方式を採用します（言語拡張を最小限にするため）。

```cm
#[css]
struct MyStyle {
    string color = "red";
    int margin_top = 10;
    string? background_color;  // Optional
    
    // ネストされたCSS（例: &:hover）
    // フィールド名が文字列リテラルのように扱える必要があるが、
    // Cmの識別子は厳格。
    // 代替案: ネストはサポートせず、フラットなプロパティのみまずはサポート。
    // または `#[key("&:hover")]` のような属性で対応。
}
```

### 2.2. 型と値のマッピング
CSSプロパティの値は柔軟ですが、型安全性とのバランスを取ります。

| Cm型 | CSS/JS値 | 処理 |
|---|---|---|
| `string` | 文字列 | そのまま出力 |
| `int`, `float` | 数値 +単位? | **数値のまま出力** (JSライブラリ側で単位付与を委譲、または `px` をデフォルトとするかは要検討) -> **決定**: 数値のまま出力。React等は `px` を自動付与するが、素のDOMスタイル操作は付与しない。相互運用性を高めるため、数値は数値 (`number`) としてJSオブジェクトに入れる。 |
| `bool` | - | CSSにboolはない。無視するかエラー。 |
| `Option<T>` | `T | undefined` | 値がない(`null`)場合、JSオブジェクトのキー自体を含めない（`undefined`）。 |

### 2.3. プロパティ名の変換
`#[css]` 属性が付いた構造体に対してのみ、JSコード生成時にフィールド名の自動変換を行います。

- **ルール**: スネークケース (`foo_bar`) -> ケバブケース (`foo-bar`)
- **例外**: `_` で始まるフィールドなどはそのまま？ -> 基本全変換でOK。
- **実装**: `JSCodeGen::emitStruct` またはオブジェクトリテラル生成時に `#[css]` 属性を確認し、キー名を変換して出力。

### 2.4. インライン展開とヘルパー
CSS構造体はインスタンス化されると、JSのオブジェクトリテラルとして表現されます。
`MyStyle s = { ... };` -> `let s = { color: "red", "margin-top": 10 };`

## 3. 文字列補間と曖昧さ回避

### 3.1. 問題
JS/CSSコードをバッククォート文字列に埋め込む際、`{...}` がブロックとしても補間としても解釈されうる。
`string css = \`body { color: red; }\`;` -> パーサーは `color: red;` を式としてパースしようとして失敗する。

### 3.2. 解決策: エスケープシーケンス `\{`
Lexerレベルで `\{` を `TokenKind::LBrace` ではなく、文字列の一部としてのリテラル `{` として認識させます。

- **Lexer**: 文字列リテラル内のスキャン中に `\` + `{` を検出した場合、補間モードに入らず、文字 `{` をバッファに追加する。
- **Parser**: 変更不要（Lexerが正しく文字列として返せばOK）。
- **Codegen**: JS出力時、エスケープされた `{` は適切に処理される（JSのテンプレートリテラルは `${` で補間なので、`{` 単体は問題ない。ただしCmの `\` エスケープがJSに残らないように注意）。

### 3.3. 例
```cm
string style = `
    .container \{
        display: flex;
    \}
`;
```

## 4. 実装フェーズ

### Phase 1: ターゲット制御 (`#[target]`)
1.  **Parser**: トップレベル宣言（`FunctionDecl`, `StructDecl`, `ImplDecl`, `UseDecl`）が `Attribute` を保持できるように確認/修正。
2.  **AST**: `ast::Attribute` に引数リストを持たせる解析ロジック追加。
3.  **Semantic Analysis**: `TargetFilteringVisitor` を実装し、HIR生成前に不要なノードを除外。

### Phase 2: 文字列エスケープ
1.  **Lexer**: `\{` および `\}` のサポート追加。

### Phase 3: CSS構造体
1.  **Codegen**: `emitStruct` および構造体インスタンス生成 (`emitAggregate`) において、`#[css]` 属性が付いている場合、フィールド名をケバブケースに変換するロジックを追加。
