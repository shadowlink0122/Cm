[English](001_technical_comparison.en.html)

# v0.13.0 技術選定比較ドキュメント

## 概要

本ドキュメントでは、v0.13.0で実装予定の4つの主要機能について、技術選定の詳細な比較と推奨を提示します。

---

## 1. マクロシステム構文

### 比較: Cスタイル `#macro` vs Rustスタイル `macro_rules!`

| 観点 | Cスタイル `#macro` | Rustスタイル `macro_rules!` |
|------|-------------------|----------------------------|
| **構文** | `#macro void LOG(...)` | `macro_rules! log { ... }` |
| **学習曲線** | C/C++プログラマーに馴染みやすい | Rust経験者に馴染みやすい |
| **プリプロセッサとの関係** | `#define`と統一的 | 完全に別の構文体系 |
| **衛生性** | 明示的に制御 | デフォルトで衛生的 |
| **パターンマッチング** | 限定的 | 強力（メタ変数 `$expr`, `$ty`等） |

### 設計詳細: Cスタイル `#macro`

```cm
// 基本構文
#macro void LOG(string message) {
    printf("[%s:%d] %s\n", __FILE__, __LINE__, message);
}

// 可変引数
#macro void PRINTLN(string fmt, auto... args) {
    printf(fmt, args...);
    printf("\n");
}

// ブロックを受け取るマクロ
#macro void WITH_LOCK(mutex& m, block code) {
    m.lock();
    defer m.unlock();
    code;
}

// 使用例
WITH_LOCK(my_mutex) {
    shared_data += 1;
}

// 型を返すマクロ
#macro auto MAX(auto a, auto b) {
    return (a > b) ? a : b;
}
```

### 拡張構文: 手続き的マクロ（将来）

```cm
// 手続き的マクロ（derive相当）
#derive(Debug, Clone)
struct Point {
    int x;
    int y;
}

// アトリビュートマクロ
#[test]
void test_addition() {
    assert(1 + 1 == 2);
}

#[inline(always)]
int hot_function() { return 42; }
```

### 推奨: **Cスタイル `#macro`**

**理由**:
1. Cm言語の「C++ライク」という設計思想と一致
2. 既存の `#define`, `#ifdef` と統一的な構文体系
3. 学習コストが低い

---

## 2. 非同期処理モデル

### 重要: 根本的なアーキテクチャの違い

**Polled Future**と**Goroutine**は、単なる構文の違いではなく、**プログラムの実行モデル全体**が異なります。

### 2.1 Polled Future（Rust型 / Stackless Coroutine）

```
┌─────────────────────────────────────────────────────────────────┐
│                    Polled Future モデル                          │
├─────────────────────────────────────────────────────────────────┤
│  ┌──────────┐                                                    │
│  │ async fn │ ──コンパイル時変換──▶ ┌────────────────────┐      │
│  │ foo() {  │                        │ struct FooFuture { │      │
│  │   await; │                        │   state: int,      │      │
│  │   ...    │                        │   locals: ...,     │      │
│  │ }        │                        │ }                  │      │
│  └──────────┘                        └────────────────────┘      │
│                                              │                   │
│                                              ▼                   │
│              ┌────────────────────────────────────────────┐      │
│              │           Executor (Runtime)                │      │
│              │  ┌─────────────────────────────────────────┐│      │
│              │  │  Task Queue: [Future1, Future2, ...]   ││      │
│              │  └─────────────────────────────────────────┘│      │
│              │          │                                  │      │
│              │          ▼                                  │      │
│              │  loop {                                     │      │
│              │      task = queue.pop();                   │      │
│              │      match task.poll() {                   │      │
│              │          Ready(val) => complete(task),     │      │
│              │          Pending => // re-enqueue later    │      │
│              │      }                                      │      │
│              │  }                                          │      │
│              └────────────────────────────────────────────┘      │
└─────────────────────────────────────────────────────────────────┘
```

**特徴**:
- **コンパイル時変換**: `async fn` → ステートマシン構造体
- **協調的**: `await`ポイントでのみ中断
- **ゼロコスト**: 手書きステートマシンと同等の性能
- **スタックレス**: 各Futureは自身の状態のみ保持（小さいメモリ）
- **明示的**: 中断ポイントがコード上で明確

**メモリモデル**:
```
┌─────────────────────────────────────────┐
│ FooFuture (on stack or heap)            │
├─────────────────────────────────────────┤
│ state: int = 1                          │  ← 現在の状態
│ arg1: int = 42                          │  ← 引数
│ local_x: int = 0                        │  ← await跨ぎのローカル変数
│ sub_future: BarFuture { ... }           │  ← ネストしたFuture（インライン）
└─────────────────────────────────────────┘
    合計サイズ: コンパイル時確定
```

### 2.2 Goroutine（Go型 / Stackful Coroutine / M:N スケジューリング）

```
┌─────────────────────────────────────────────────────────────────┐
│                    Goroutine モデル                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    Go Runtime                             │   │
│  │  ┌──────────┐ ┌──────────┐ ┌──────────┐                  │   │
│  │  │ Worker 1 │ │ Worker 2 │ │ Worker N │  (OS Threads)    │   │
│  │  └────┬─────┘ └────┬─────┘ └────┬─────┘                  │   │
│  │       │            │            │                         │   │
│  │       ▼            ▼            ▼                         │   │
│  │  ┌─────────────────────────────────────────────────────┐ │   │
│  │  │              Global Run Queue                       │ │   │
│  │  │  [G1] [G2] [G3] [G4] [G5] ...  (millions possible)  │ │   │
│  │  └─────────────────────────────────────────────────────┘ │   │
│  │                                                           │   │
│  │  ┌────────────────────────────────────────────────────┐  │   │
│  │  │ Work Stealing: Worker2 steals from Worker1         │  │   │
│  │  └────────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │ Goroutine (独立したスタックを持つ)                         │   │
│  │ ┌────────────────────────────────┐                        │   │
│  │ │ Stack (2KB-1MB, 動的成長)      │                        │   │
│  │ │ ├── frame1                     │                        │   │
│  │ │ ├── frame2                     │                        │   │
│  │ │ └── ...                        │                        │   │
│  │ └────────────────────────────────┘                        │   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**特徴**:
- **ランタイム主導**: スケジューラが実行を制御
- **M:N マッピング**: M個のGoroutineをN個のOSスレッドで実行
- **スタックフル**: 各Goroutineが独自のスタックを持つ
- **プリエンプティブ**: ランタイムが強制的に中断可能
- **暗黙的**: 中断ポイントがコード上で見えない

**メモリモデル**:
```
┌─────────────────────────────────────────┐
│ Goroutine 1                             │
├─────────────────────────────────────────┤
│ Stack: 2KB (初期) → 最大1MB まで成長     │
│ ├── main.foo() frame                    │
│ │   └── local variables                 │
│ ├── bar() frame                         │
│ │   └── local variables                 │
│ └── baz() frame                         │
│     └── local variables                 │
├─────────────────────────────────────────┤
│ G State: _Grunning / _Gwaiting / ...    │
└─────────────────────────────────────────┘
    合計サイズ: 実行時動的変化
```

### 2.3 詳細比較表

| 観点 | Polled Future (Rust) | Goroutine (Go) |
|------|---------------------|----------------|
| **スタック** | スタックレス（状態のみ保持） | スタックフル（独自スタック） |
| **メモリ効率** | 非常に高い（数十〜数百バイト/タスク） | 低い（2KB〜1MB/タスク） |
| **数百万タスク** | 可能（メモリ制約少） | 可能だがメモリ消費大 |
| **コンテキストスイッチ** | 安価（ポインタ切り替え程度） | 高価（スタック切り替え） |
| **中断ポイント** | 明示的（`await`のみ） | 暗黙的（関数呼び出し等）|
| **プリエンプション** | なし（協調的） | あり（ランタイム制御） |
| **デバッグ** | 難しい（ステートマシン変換後） | 比較的容易（通常スタック） |
| **GC依存** | なし | あり（Goの場合） |
| **ベアメタル** | 対応可能 | 困難 |
| **実装複雑度** | 高（コンパイラ変換必須） | 非常に高（ランタイム実装必須） |
| **CPU使用率** | 低い（明示的待機） | 高い可能性（ポーリング） |

### 2.4 ユースケース別推奨

| ユースケース | 推奨モデル | 理由 |
|-------------|-----------|------|
| Web サーバー | Polled Future | 数万接続、メモリ効率重要 |
| 組み込みシステム | Polled Future | GC不要、スタック制限 |
| スクリプティング | Goroutine | 書きやすさ優先 |
| ゲームループ | Polled Future | 低レイテンシ要求 |
| 分散システム | どちらも可 | 要件次第 |

### 2.5 Cm言語への推奨: **Polled Future**

**理由**:
1. **Cm言語の設計思想との整合性**: ゼロコスト抽象化、GC不要
2. **ベアメタル対応**: 組み込み・OS開発がターゲット
3. **既存設計との継続性**: 既にステートマシン変換の設計ドキュメントあり
4. **所有権システムとの統合**: v0.11.0の所有権モデルと自然に統合

**ただし、将来的にGoスタイルの簡易構文も検討可能**:
```cm
// 将来の拡張: spawn（Goスタイル風の構文糖衣）
spawn {
    // 内部的にはFutureに変換され、Executorで実行
    heavy_computation();
}
```

---

## 3. 非同期HTTP実装

### 比較: 実装アプローチ

| アプローチ | 説明 | メリット | デメリット |
|-----------|------|---------|-----------|
| **Socket直接実装** | TCP + HTTPプロトコル自前実装 | 完全制御、軽量 | 実装コスト大 |
| **libcurl FFI** | 既存ライブラリを呼び出し | 安定、高機能 | 依存関係、非同期統合困難 |
| **システムライブラリ** | Cm標準ライブラリとして提供 | 統一的なAPI | 中程度の実装コスト |

### 推奨: システムライブラリ実装

#### アーキテクチャ

```
┌─────────────────────────────────────────────────────────────────┐
│                    std::net モジュール                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌──────────────────────┐  ┌──────────────────────┐             │
│  │    std::net::tcp     │  │   std::net::http     │             │
│  │  ├── TcpListener     │  │  ├── HttpClient      │             │
│  │  ├── TcpStream       │  │  ├── HttpRequest     │             │
│  │  └── TcpConnect      │  │  ├── HttpResponse    │             │
│  └──────────────────────┘  │  └── Headers         │             │
│            │               └──────────────────────┘             │
│            │                           │                        │
│            ▼                           ▼                        │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │               std::io (async I/O abstraction)           │   │
│  │  ├── AsyncRead                                          │   │
│  │  ├── AsyncWrite                                         │   │
│  │  └── Poll                                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│            │                                                    │
│            ▼                                                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │            Platform Abstraction Layer                   │   │
│  │  ├── Linux: epoll                                       │   │
│  │  ├── macOS: kqueue                                      │   │
│  │  └── Windows: IOCP                                      │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

#### 使用例

```cm
import std::net::http;
import std::runtime;

async HttpResponse fetch_json(string url) {
    HttpClient client = HttpClient::new();
    
    HttpRequest request = HttpRequest::get(url)
        .header("Accept", "application/json")
        .timeout(Duration::seconds(30));
    
    HttpResponse response = await client.send(request);
    return response;
}

int main() {
    runtime::block_on(async {
        HttpResponse res = await fetch_json("https://api.example.com/data");
        
        if (res.status() == 200) {
            println("Body: {}", res.body_text());
        } else {
            println("Error: {}", res.status());
        }
    });
    
    return 0;
}
```

---

## 4. インラインアセンブリ

### 設計: マクロベースのインラインアセンブリ

```cm
// x86_64 システムコール例
int syscall_write(int fd, const char* buf, size_t len) {
    int result;
    
    #asm {
        // 入力オペランド
        in: "rdi" = fd,
            "rsi" = buf,
            "rdx" = len
        
        // 出力オペランド
        out: "rax" => result
        
        // 破壊レジスタ
        clobber: "rcx", "r11", "memory"
        
        // アセンブリ本体
        code:
            "mov rax, 1"      // syscall番号: write
            "syscall"
    }
    
    return result;
}

// ARM64 例
void memory_barrier() {
    #asm {
        code: "dmb sy"
    }
}

// SIMD 例
void vector_add(float* a, float* b, float* c, int n) {
    #asm {
        in: "rdi" = a, "rsi" = b, "rdx" = c, "rcx" = n
        clobber: "ymm0", "ymm1"
        code:
            "vaddps ymm0, ymm0, [rdi]"
            "vmovaps [rdx], ymm0"
    }
}
```

### 代替構文（Rustライク）

```cm
// Rustスタイルの代替案
int syscall_write(int fd, const char* buf, size_t len) {
    int result;
    
    asm!(
        "mov rax, 1",
        "syscall",
        in("rdi") fd,
        in("rsi") buf,
        in("rdx") len,
        out("rax") result,
        clobber_abi("system")
    );
    
    return result;
}
```

### 推奨: `#asm` 構文

**理由**:
1. Cスタイルマクロとの一貫性（`#macro`, `#define`, `#asm`）
2. 構造化された入出力指定が読みやすい
3. 将来のアーキテクチャ拡張に柔軟

---

## 5. 実装ロードマップ

### Phase 1: マクロシステム有効化（2-3週間）
- 既存 `src/macro/` コードの統合
- パーサーへの `#macro` 構文追加
- 基本的なマクロ展開テスト

### Phase 2: インラインアセンブリ（1-2週間）
- `#asm` 構文のパース
- LLVMインラインアセンブリへの変換
- x86_64基本テスト

### Phase 3: 非同期基盤（3-4週間）
- `Future` トレイト定義
- `async`/`await` パーサー拡張
- ステートマシン変換（MIR）
- シングルスレッドExecutor

### Phase 4: ネットワークライブラリ（2-3週間）
- `std::net::tcp` 実装
- epoll/kqueue抽象化
- `std::net::http` クライアント

### 合計: 8-12週間

---

## 6. まとめ

| 機能 | 推奨選択 | 理由 |
|------|---------|------|
| マクロ構文 | `#macro` (Cスタイル) | Cm設計思想との一致 |
| 非同期モデル | Polled Future | ゼロコスト、GC不要 |
| HTTP実装 | システムライブラリ | 統一的API、完全制御 |
| インラインASM | `#asm` ブロック | 構造化、一貫性 |
