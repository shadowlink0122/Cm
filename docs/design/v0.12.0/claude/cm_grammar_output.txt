============================================================
Cm Language Grammar (BNF)
============================================================

Start symbol: program
Productions: 100
Terminals: 133
Nonterminals: 100

------------------------------------------------------------

program
    ::= top_level_decl*

top_level_decl
    ::= import_statement
      | function_decl
      | struct_decl
      | trait_decl
      | impl_decl
      | typedef_decl
      | macro_decl
      | enum_decl
      | operator_decl

import_statement
    ::= 'import' string_literal ';'

function_decl
    ::= generic_params? type identifier '(' param_list? ')' where_clause? block
      | generic_params? type identifier '(' param_list? ')' where_clause? ';'

struct_decl
    ::= 'struct' identifier generic_params? where_clause? '{' struct_member* '}'

struct_member
    ::= type identifier ';'
      | function_decl

trait_decl
    ::= 'trait' identifier generic_params? '{' trait_member* '}'

trait_member
    ::= type identifier '(' param_list? ')' ';'
      | type identifier '(' param_list? ')' block

impl_decl
    ::= 'impl' generic_params? trait_name 'for' type where_clause? '{' impl_member* '}'
      | 'impl' generic_params? type where_clause? '{' impl_member* '}'

impl_member
    ::= function_decl
      | 'type' identifier '=' type ';'

typedef_decl
    ::= 'typedef' identifier generic_params? '=' type ';'

macro_decl
    ::= 'macro' identifier generic_params? '(' param_list? ')' where_clause? block

enum_decl
    ::= 'enum' identifier generic_params? '{' enum_variant (',' enum_variant)* ',' ? '}'

enum_variant
    ::= identifier
      | identifier '(' type_list ')'
      | identifier '{' struct_member* '}'

operator_decl
    ::= 'operator' operator_symbol '(' param_list ')' type block
      | 'operator' operator_symbol '(' param_list ')' type ';'

operator_symbol
    ::= '+' | '-' | '*' | '/' | '%'
      | '==' | '!=' | '<' | '>' | '<=' | '>='
      | '&' | '|' | '^' | '~' | '!'
      | '<<' | '>>'
      | '[]' | '()'

generic_params
    ::= '<' generic_param_list '>'

generic_param_list
    ::= generic_param (',' generic_param)*

generic_param
    ::= type_param
      | const_param

type_param
    ::= identifier (':' type_constraint)? ('=' type)?

const_param
    ::= identifier ':' 'const' type ('=' const_expr)?

type_constraint
    ::= union_type
      | type_name

where_clause
    ::= 'where' where_bound (',' where_bound)*

where_bound
    ::= identifier ':' interface_bound

interface_bound
    ::= trait_name ('+' trait_name)*

type
    ::= primitive_type
      | type_name
      | type_name '<' type_list '>'
      | type '[' const_expr ']'
      | type '*'
      | type '&'
      | '(' type_list ')'
      | union_type
      | 'typeof' '(' expression ')'

primitive_type
    ::= 'int' | 'uint'
      | 'tiny' | 'utiny'
      | 'short' | 'ushort'
      | 'long' | 'ulong'
      | 'double' | 'float'
      | 'bool' | 'char' | 'void'
      | 'string' | 'size_t'

union_type
    ::= type ('|' type)+

type_list
    ::= type (',' type)*

type_name
    ::= identifier ('::' identifier)*

trait_name
    ::= identifier ('::' identifier)*

statement
    ::= declaration_statement
      | expression_statement
      | if_statement
      | switch_statement
      | while_statement
      | for_statement
      | return_statement
      | break_statement
      | continue_statement
      | defer_statement
      | block

declaration_statement
    ::= type identifier ('=' expression)? ';'

expression_statement
    ::= expression ';'

if_statement
    ::= 'if' '(' expression ')' statement ('else' statement)?

switch_statement
    ::= 'switch' '(' expression ')' '{' case_clause* '}'

case_clause
    ::= 'case' const_expr ':' statement*
      | 'default' ':' statement*

while_statement
    ::= 'while' '(' expression ')' statement

for_statement
    ::= 'for' '(' for_init? ';' expression? ';' expression? ')' statement
      | 'for' '(' type identifier ':' expression ')' statement

for_init
    ::= declaration_statement
      | expression

return_statement
    ::= 'return' expression? ';'

break_statement
    ::= 'break' ';'

continue_statement
    ::= 'continue' ';'

defer_statement
    ::= 'defer' statement

block
    ::= '{' statement* '}'

expression
    ::= assignment_expr

assignment_expr
    ::= conditional_expr
      | unary_expr assign_op assignment_expr

assign_op
    ::= '=' | '+=' | '-=' | '*=' | '/=' | '%='
      | '&=' | '|=' | '^=' | '<<=' | '>>='

conditional_expr
    ::= logical_or_expr
      | logical_or_expr '?' expression ':' conditional_expr

logical_or_expr
    ::= logical_and_expr
      | logical_or_expr '||' logical_and_expr

logical_and_expr
    ::= inclusive_or_expr
      | logical_and_expr '&&' inclusive_or_expr

inclusive_or_expr
    ::= exclusive_or_expr
      | inclusive_or_expr '|' exclusive_or_expr

exclusive_or_expr
    ::= and_expr
      | exclusive_or_expr '^' and_expr

and_expr
    ::= equality_expr
      | and_expr '&' equality_expr

equality_expr
    ::= relational_expr
      | equality_expr ('==' | '!=' ) relational_expr

relational_expr
    ::= shift_expr
      | relational_expr ('<' | '>' | '<=' | '>=' ) shift_expr

shift_expr
    ::= additive_expr
      | shift_expr ('<<' | '>>' ) additive_expr

additive_expr
    ::= multiplicative_expr
      | additive_expr ('+' | '-' ) multiplicative_expr

multiplicative_expr
    ::= cast_expr
      | multiplicative_expr ('*' | '/' | '%' ) cast_expr

cast_expr
    ::= unary_expr
      | '(' type ')' cast_expr

unary_expr
    ::= postfix_expr
      | '++' unary_expr
      | '--' unary_expr
      | unary_operator cast_expr
      | 'sizeof' '(' type ')'
      | 'sizeof' unary_expr
      | 'typeof' '(' expression ')'

unary_operator
    ::= '&' | '*' | '+' | '-' | '~' | '!'

postfix_expr
    ::= primary_expr
      | postfix_expr '[' expression ']'
      | postfix_expr '(' argument_list? ')'
      | postfix_expr '.' identifier
      | postfix_expr '->' identifier
      | postfix_expr '++'
      | postfix_expr '--'
      | postfix_expr '<' type_list '>'

primary_expr
    ::= identifier
      | literal
      | '(' expression ')'
      | lambda_expr
      | format_string

lambda_expr
    ::= '[' capture_list? ']' '(' param_list? ')' type? block

capture_list
    ::= capture_item (',' capture_item)*

capture_item
    ::= '&' ? identifier

format_string
    ::= 'f"' format_string_content '"'

format_string_content
    ::= (format_text | format_expr)*

format_text
    ::= [^{}]+

format_expr
    ::= '{' expression '}'
      | '{' expression ':' format_spec '}'

param_list
    ::= parameter (',' parameter)*

parameter
    ::= type identifier ('=' const_expr)?
      | type '...' identifier

argument_list
    ::= expression (',' expression)*

const_expr
    ::= conditional_expr

literal
    ::= integer_literal
      | float_literal
      | char_literal
      | string_literal
      | bool_literal
      | null_literal

integer_literal
    ::= decimal_literal
      | hex_literal
      | binary_literal
      | octal_literal

decimal_literal
    ::= [0-9] [0-9_]*
      | [1-9] [0-9_]* integer_suffix?

hex_literal
    ::= '0x' [0-9a-fA-F] [0-9a-fA-F_]*

binary_literal
    ::= '0b' [01] [01_]*

octal_literal
    ::= '0o' [0-7] [0-7_]*

integer_suffix
    ::= 'u' | 'U' | 'l' | 'L' | 'ul' | 'UL'

float_literal
    ::= [0-9]+ '.' [0-9]+ ([eE] [+-]? [0-9]+)? float_suffix?
      | [0-9]+ [eE] [+-]? [0-9]+ float_suffix?

float_suffix
    ::= 'f' | 'F' | 'd' | 'D'

char_literal
    ::= "'" (escape_sequence | [^'\\\n]) "'"

string_literal
    ::= '"' (escape_sequence | [^"\\\n])* '"'
      | raw_string_literal

raw_string_literal
    ::= 'r"' [^"]* '"'
      | 'r

escape_sequence
    ::= '\\' ['"\\nrtbfav]
      | '\\x' hex_digit hex_digit
      | '\\u' hex_digit{4}
      | '\\U' hex_digit{8}

bool_literal
    ::= 'true' | 'false'

null_literal
    ::= 'null' | 'nullptr'

identifier
    ::= [a-zA-Z_] [a-zA-Z0-9_]*
      | '`' [^`]+ '`'

keyword
    ::= 'if' | 'else' | 'while' | 'for' | 'switch' | 'case' | 'default'
      | 'break' | 'continue' | 'return' | 'defer'
      | 'struct' | 'enum' | 'trait' | 'impl' | 'typedef' | 'macro'
      | 'import' | 'export' | 'module'
      | 'operator' | 'private'
      | 'const' | 'static'
      | 'sizeof' | 'typeof'
      | 'true' | 'false' | 'null' | 'nullptr'
      | 'void' | 'int' | 'uint' | 'tiny' | 'utiny' | 'short' | 'ushort'
      | 'long' | 'ulong' | 'float' | 'double' | 'bool' | 'char' | 'string'
      | 'auto' | 'with' | 'where' | 'as'

delimiter
    ::= '(' | ')' | '[' | ']' | '{' | '}'
      | ';' | ',' | ':'

comment
    ::= '//' [^\n]* '\n'
      | '/*' ([^*] | '*' [^/])* '*/'

whitespace
    ::= [ \t\n\r]+

preprocessor
    ::= '

preprocessor_directive
    ::= 'include' string_literal
      | 'define' identifier replacement?
      | 'ifdef' identifier
      | 'ifndef' identifier
      | 'if' const_expr
      | 'else'
      | 'elif' const_expr
      | 'endif'
      | 'pragma' pragma_args

attribute
    ::= '[[' attribute_list ']]'

attribute_list
    ::= attribute_spec (',' attribute_spec)*

attribute_spec
    ::= identifier
      | identifier '(' argument_list ')'
