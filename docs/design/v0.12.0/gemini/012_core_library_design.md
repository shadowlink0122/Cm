[English](012_core_library_design.en.html)

# Coreライブラリの設計とランタイムの分離

## 1. 目的
現在のコンパイラ実装では、`cm_panic` や基本的なメモリ操作などのランタイム機能がコンパイラ（C++コード）内に文字列としてハードコードされています。
これを解消し、**OSや環境（Native, JS, Wasm）に依存しない最小限の機能群** を `core` パッケージとして切り出します。

これにより、以下のメリットが得られます。
*   **移植性の向上**: ベアメタル（OSなし）、Wasm、JSなど多様な環境で共通の基盤を利用可能。
*   **コンパイラの簡素化**: コンパイラはコード生成に集中し、ランタイムの実装詳細から分離される。
*   **セルフホスティング**: ランタイムの多くをCm言語自身で記述可能になる。

## 2. ライブラリ階層構造

標準ライブラリを明確な階層に分割します。

```text
lib/
├── core/           (No-std / 環境非依存)
│   ├── mod.cm
│   ├── panic.cm    (パニックハンドラの定義)
│   ├── option.cm   (Option型の定義)
│   ├── result.cm   (Result型の定義)
│   ├── mem.cm      (基本的なメモリ操作、配置)
│   └── math.cm     (ハードウェア演算の抽象化)
│
├── std/            (OS / 環境依存機能を含む)
│   ├── mod.cm
│   ├── io.cm       (標準入出力)
│   ├── fs.cm       (ファイルシステム)
│   ├── net.cm      (ネットワーク)
│   ├── collections/(Vec, Mapなどヒープ依存)
│   └── web/        (JSバックエンド特有の機能)
│
└── runtime/        (バックエンド固有のプリミティブ実装)
    ├── native/     (C/Asm: エントリポイント, システムコールラッパー)
    └── js/         (JS: cm-runtime.js)
```

## 3. Coreパッケージの要件

`core` パッケージは以下の制約に従います。

1.  **OS非依存**: ファイルシステム、ネットワーク、スレッド、時刻取得などは含まない。
2.  **アロケータ非依存（推奨）**: ヒープ割り当て（`malloc`）を前提としない。`Box` や `Vec` は `std` または `alloc` パッケージで提供する。
    *   ※ JSバックエンドは本質的にヒープ依存ですが、Cmのセマンティクスとしては `core` はスタックのみで動作するように見せかけます。
3.  **パニックの抽象化**: 致命的エラー時の挙動（`abort` か `throw` か）は、リンクされる `runtime` によって決定される。

## 4. `cm_*` 関数の移行戦略

現在コンパイラが生成しているインライン関数群を、`core` および `runtime` へ移行します。

### 4.1 パニック処理 (`cm_panic`)

*   **Current**: コンパイラが `cm_panic` 関数定義を出力コードに埋め込む。
*   **New**:
    *   `lib/core/panic.cm`:
        ```rust
        // 抽象的なパニック関数
        extern "Runtime" fn __runtime_panic(msg: string) -> !;

        export fn panic(msg: string) -> ! {
            // ここでフックやフォーマットを行う余地がある
            __runtime_panic(msg);
        }
        ```
    *   `lib/runtime/native/panic.c`: `__runtime_panic` を実装し、`abort()` を呼ぶ。
    *   `lib/runtime/js/runtime.js`: `__runtime_panic` を実装し、`throw new Error(msg)` する。

### 4.2 メモリ操作

*   `copy_memory`, `set_memory` などは `core::mem` モジュールで提供。
*   Nativeでは `memcpy`, `memset` に、JSでは `TypedArray.set` や単純なループにマッピング。

## 5. コンパイルフローの変更

ユーザーコードのコンパイル時に、自動的に `core` がリンクされるようにします。

1.  **コンパイル時**: ユーザーコード内で `panic` 等が使われると、コンパイラは `core` パッケージのシンボルを参照するコードを生成。
2.  **リンク時 (Native)**: 事前にコンパイルされた `libcore.rlib` (仮) と `libruntime.a` をリンク。
3.  **バンドル時 (JS)**: 生成されたJSファイルが、`import { ... } from "cm-runtime.js"` を行い、ブラウザ/Node.js環境に適した実装を読み込む。

## 6. まとめ

`core` パッケージの分離は、Cm言語が真のシステムプログラミング言語として自立するために不可欠なステップです。まずはJSコンパイラの実装において、ランタイムを別ファイル（モジュール）として扱う形から着手し、Native側も順次この構成に合わせていくことを推奨します。