# 非協調的マルチタスクとスケジューリングアルゴリズム

## 1. 課題と目標
一般的な `async/await` は「協調的マルチタスク」であり、タスクが自発的に `await` しない限りCPUを解放しません。これは、一つのタスクが無限ループに入るとスレッド全体が停止することを意味します。
本設計では、**`async` 構文を用いつつも、タスクがCPUを独占しない「非協調的（プリエンプティブ）」な挙動** を実現します。

## 2. アルゴリズム選定: コンパイラ支援による強制プリエンプション

OSの割り込み（シグナル）を使う手法はオーバーヘッドが大きく、移植性（特にWASMやベアメタル）に欠けます。
そこで、**コンパイラによる自動計装（Instrumentation）** を採用します。

### 2.1 チェックポイント挿入 (Yield Injection)
コンパイラのMIR/LLVM生成フェーズにおいて、以下の箇所に `runtime::check_yield()` 呼び出しを自動挿入します。

1.  **関数のプロローグ**: すべての関数呼び出しの先頭。
2.  **ループのバックエッジ**: `while`, `for` などのループの戻り地点。

```cm
// ユーザーコード
while (true) {
    calculate();
}

// コンパイラ生成コード（イメージ）
while (true) {
    __cm_runtime_check_yield(); // 割り当て時間（Quantum）超過ならPendingを返す
    calculate();
}
```

### 2.2 ステートマシンへの影響
この「強制Yield」を実現するためには、`async` でない通常の関数も、中断・再開可能である必要があります。しかし、全ての関数をステートマシン化するのはオーバーヘッドが大きすぎます。

**解決策: 非対称コルーチンとスタックハイブリッド**
*   **Async関数**: ステートマシンとしてコンパイル（ヒープ/スタックに状態を持つ）。
*   **通常関数**: 従来のスタックを使用。
*   **強制中断時**:
    *   通常関数内で `check_yield` がトリガーされると、**「スタックレス」ではなく「スタックフル」な中断** を行います。
    *   または、より軽量なアプローチとして、`check_yield` は単にフラグを立て、最寄りの `await` ポイントまでエラー的に脱出（Unwind）し、次回そこからリトライする方式（Goの古い方式に近いが、Cmではリトライコストが高いため非推奨）。

**採用案: 予算ベースのステートマシン分割**
`async` 関数内でのループや重い処理は、MIRレベルで複数のステート（`case`）に細分化されます。
`while` ループの各イテレーションをステートマシンの遷移として表現することで、ループの途中でも `return Poll::Pending` できるようにします。

```cm
// async fn内
while (i < 1000000) {
    // ...
}

// 変換後
case STATE_LOOP_BODY:
    if (runtime::is_timeout()) {
        return Poll::Pending; // 強制中断
    }
    // 処理
    if (i < 1000000) {
        state = STATE_LOOP_BODY;
        goto loop; // または return Poll::Pending (協調的)
    }
```

## 3. スケジューラ設計: Work-Stealing with Vtime

### 3.1 仮想時間 (Vtime)
各タスクは「仮想実行時間」を持ちます。実行されるたびに加算され、一定値を超えると優先度が下がります。

### 3.2 アルゴリズム
1.  **Local Deque**: 各ワーカースレッドは自分のタスクキューを持つ（LIFO）。
2.  **Global Queue**: 溢れたタスクや、新規タスクが入る（FIFO）。
3.  **Stealing**: 自分のキューが空なら、他スレッドからタスクを半分奪う。
4.  **Preemption**: `check_yield()` で実行時間が閾値を超えていたら、タスクを強制的にサスペンド（`Pending`化）し、Global Queueの末尾に回す。

## 4. ベアメタル対応

OSスレッドがない環境では、以下の戦略をとります。

*   **割り込み駆動**: ハードウェアタイマー割り込みでフラグを立てる。
*   **`check_yield`**: フラグを見て、立っていたらコンテキストスイッチ（ステートマシンの保存と復帰）を行う。
*   **WFI (Wait For Interrupt)**: 全タスクが `Pending` なら、CPUをスリープさせる。

この設計により、`async/await` の書きやすさを維持しつつ、システム全体の応答性を保証します。
