# Cm コンパイラアーキテクチャ設計

## 概要

Cm言語処理系は、Cb言語の経験を踏まえ、HIR（High-level Intermediate Representation）を中心とした段階的なコンパイルパイプラインを採用します。

## コンパイルパイプライン

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              Cm Compiler Pipeline                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   Source Code (.cm)                                                         │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │   Lexer     │  字句解析: ソースコード → トークン列                        │
│   └─────────────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │   Parser    │  構文解析: トークン列 → AST                                │
│   └─────────────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │    AST      │  抽象構文木: ソース構造の忠実な表現                        │
│   └─────────────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │ Type Check  │  型検査: 型の整合性検証                                   │
│   └─────────────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │    HIR      │  High-level IR: 型情報付き中間表現                        │
│   └─────────────┘                                                           │
│         │                                                                   │
│         ▼                                                                   │
│   ┌─────────────┐                                                           │
│   │ Interpreter │  実行: HIRの逐次実行（初期実装）                          │
│   └─────────────┘                                                           │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

## 各フェーズの役割

### 1. Lexer（字句解析器）

**入力**: ソースコード（文字列）
**出力**: トークン列

責務:
- 文字列をトークンに分割
- コメントの除去
- 文字列リテラルの処理
- 位置情報（行番号・列番号）の追跡

### 2. Parser（構文解析器）

**入力**: トークン列
**出力**: AST（抽象構文木）

責務:
- 文法規則に従った構文解析
- 構文エラーの検出と報告
- ASTノードの構築

### 3. AST（抽象構文木）

ソースコードの構造を忠実に表現するデータ構造。

特徴:
- ソースコードの構造をそのまま反映
- 位置情報を保持（エラー報告用）
- 糖衣構文はそのまま表現

### 4. Type Checker（型検査器）

**入力**: AST
**出力**: 型付きAST / 型エラー

責務:
- 型の推論と検証
- オーバーロード解決
- ジェネリクスのインスタンス化
- 型エラーの検出と報告

### 5. HIR（High-level Intermediate Representation）

**Cbからの最大の改善点**

特徴:
- 型情報が完全に付与された中間表現
- 糖衣構文が脱糖（desugar）された形式
- 制御フローが明示的
- 最適化に適した形式

HIRで行う処理:
- 定数畳み込み
- 不要コード除去
- インライン展開

### 6. Interpreter（インタープリター）

**入力**: HIR
**出力**: 実行結果

初期実装としてHIRを直接解釈実行するインタープリターを実装。
将来的にはMIR→ネイティブコード生成も検討。

## Cb言語との設計比較

### Cb言語の課題

```
Cb: Source → Parser → AST → Interpreter
                              ↑
                        型検査と実行が混在
```

問題点:
- ASTを直接実行するため、実行時に型情報が必要
- 最適化の機会が限られる
- エラーメッセージが実行時まで遅延することがある

### Cm言語の改善

```
Cm: Source → Parser → AST → Type Check → HIR → Interpreter
                                          ↑
                                    型付き中間表現
```

改善点:
- 型検査が完了してからHIRに変換
- HIRは型情報を持つため、実行時の型チェック不要
- HIRレベルでの最適化が可能
- より良いエラーメッセージの生成

## ディレクトリ構成

```
src/
├── frontend/
│   ├── lexer/
│   │   ├── token.hpp       # トークン定義
│   │   └── lexer.hpp       # Lexerクラス
│   ├── parser/
│   │   ├── parser.hpp      # Parserクラス
│   │   └── grammar.hpp     # 文法定義
│   └── ast/
│       ├── ast.hpp         # ASTノード定義
│       └── visitor.hpp     # Visitorパターン
├── middle/
│   ├── hir/
│   │   ├── hir.hpp         # HIRノード定義
│   │   └── builder.hpp     # HIRビルダー
│   ├── type_check/
│   │   ├── types.hpp       # 型定義
│   │   └── checker.hpp     # 型検査器
│   └── lowering/
│       └── ast_to_hir.hpp  # AST→HIR変換
├── backend/
│   └── interpreter/
│       └── interpreter.hpp # HIRインタープリター
└── common/
    ├── source.hpp          # ソースコード管理
    ├── diagnostics.hpp     # エラー報告
    └── span.hpp            # 位置情報
```

## 将来の拡張

### 1. MIR (Mid-level IR) の追加

初期実装ではHIRから直接インタープリターを実行しますが、将来的にはMIRを導入する可能性があります。

```
現在: Source → AST → HIR → Interpreter
将来: Source → AST → HIR → MIR → Codegen
```

MIRの特徴:
- よりローレベルな最適化
- バックエンド非依存の最適化
- 制御フローグラフ（CFG）ベースの表現

2. **ネイティブコード生成**
   - LLVM IRへの変換
   - 直接的なアセンブリ生成

3. **LSP (Language Server Protocol)** 対応
   - HIRを活用した高精度な補完
   - リアルタイム型検査
