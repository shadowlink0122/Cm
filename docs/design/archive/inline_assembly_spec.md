# Cm言語 インラインアセンブリ仕様書

## 概要
Cm言語のインラインアセンブリ機能は、低レベルの最適化やハードウェア固有の命令を使用するために提供されます。

## 現在の実装状況

### 基本構文
```cm
asm("assembly_code_string");
```

### 変数補間
Cm変数をアセンブリコード内で参照できます：
```cm
int x = 42;
asm("movl {x}, %eax");  // {x}がCm変数xの値に置換される
```

## 実装の詳細

### 1. コンパイラ（LLVMバックエンド）での動作

#### 現在の実装（シンプル版）
- **変数補間**: `{var}` を `$N` (N=0,1,2...) に置換
- **制約**: すべての変数に "r" (レジスタ)制約を適用
- **構文**: AT&T構文をデフォルトとして使用
- **即値**: `$$` でエスケープ（例：`$$7` → リテラル `$7`）

#### 制限事項
- 出力変数への書き込みが動作しない（すべて入力制約 "r" のため）
- メモリ制約（"m"）未対応
- クロバーリスト未対応
- Intel構文未対応

### 2. インタープリタでの動作
```
[WARNING] Inline assembly is not supported in interpreter mode.
ASM instructions will be skipped. Use compiled mode for ASM execution.
```
- ASM命令は完全にスキップ
- 変数の値は変更されない
- 警告メッセージを表示（初回のみ）

## 使用例と制限

### ✅ 動作する例

#### 1. 単純な命令実行
```cm
asm("nop");           // No Operation
asm("mfence");        // メモリフェンス
```

#### 2. レジスタへの値の読み込み
```cm
int a = 10;
asm("movl {a}, %eax");  // 変数aの値を%eaxに読み込み
```

#### 3. レジスタ間の演算
```cm
asm("addl %ebx, %eax");  // レジスタ同士の加算
asm("imull $$7, %eax");  // 即値との乗算（$$でエスケープ）
```

### ❌ 現在動作しない例

#### 1. 変数への書き込み
```cm
int result = 0;
asm("movl %eax, {result}");  // ← 動作しない（出力制約なし）
```

#### 2. メモリ参照
```cm
int* ptr = &x;
asm("movl ({ptr}), %eax");  // ← 動作しない（メモリ制約なし）
```

#### 3. 複雑な制約
```cm
// GCC/Clang形式の制約（未実装）
asm("movl %1, %0"
    : "=r"(result)    // 出力
    : "r"(input)      // 入力
    : "%eax");        // クロバー
```

## 提案する改善案

### Phase 1: 基本的な入出力対応
```cm
// 提案1: 明示的な方向指定
asm_in("movl {x}, %eax");     // 入力のみ
asm_out("movl %eax, {result}");  // 出力あり
asm_inout("addl {x}, {y}");   // 入出力両方

// 提案2: プレフィックスによる指定
asm("movl {in:x}, %eax");     // 入力
asm("movl %eax, {out:result}");  // 出力
asm("addl {inout:x}, %ebx");  // 入出力
```

### Phase 2: 制約の明示的指定
```cm
// 提案: 変数ごとに制約を指定
asm("movl {x:r}, %eax");      // レジスタ制約
asm("movl {ptr:m}, %eax");     // メモリ制約
asm("movl $${val:i}, %eax");  // 即値制約
```

### Phase 3: 完全なGCC形式サポート（将来）
```cm
int result;
int input = 42;

asm("imull %%ebx, %%eax"
    : "=a"(result)           // %eax に結果を出力
    : "a"(input), "b"(7)     // %eax, %ebx に入力
    : "cc");                 // 条件コードを破壊
```

## セキュリティと安全性

### 制限事項
1. **スタック操作の禁止**: スタックポインタの直接操作は未定義動作
2. **システムコールの制限**: 直接的なシステムコール実行は推奨しない
3. **型安全性なし**: アセンブリレベルでの型チェックは行われない

### 推奨事項
1. **最小限の使用**: パフォーマンスクリティカルな部分のみ
2. **十分なテスト**: アセンブリコードは各プラットフォームでテスト
3. **ドキュメント化**: 使用目的と動作を明確に文書化

## プラットフォーム対応

### 現在
- x86-64 (AMD64) のみ
- AT&T構文のみ

### 将来
- ARM64対応
- Intel構文サポート
- WebAssembly（制限付き）

## テスト方法

```bash
# コンパイルモードでのテスト（ASM実行）
./cm compile -o test program.cm
./test

# インタープリタモードでのテスト（警告確認）
./cm run program.cm
# → [WARNING] Inline assembly is not supported...
```

## 既知の問題

1. **変数書き込み不可**: 出力制約が実装されていない
2. **ハング問題（解決済み）**: 複雑な実装をシンプル化して解決
3. **サイズサフィックス**: 一部の命令で必要なサフィックスが自動付与されない

## 今後の実装優先度

1. **高優先度**
   - 出力変数への書き込み対応（"=r" 制約）
   - 基本的な入出力方向の指定

2. **中優先度**
   - メモリ制約（"m"）のサポート
   - クロバーリストの基本サポート

3. **低優先度**
   - 完全なGCC形式制約
   - Intel構文サポート
   - プラットフォーム抽象化