# 所有権システム完成設計

## 概要
v0.10.0で実装した所有権・借用システムを完成させる。

## 実装済み機能

| 機能 | 状況 | 備考 |
|------|------|------|
| `move`キーワード | ✅ | 明示的所有権移転 |
| use-after-move検出 | ✅ | コンパイルエラー |
| 再代入復活 | ✅ | `x = 99`で復活 |
| const外し禁止 | ✅ | `const T* -> T*`禁止 |
| 借用中move禁止 | ✅ | `&x`後の`move x`禁止 |

---

## 未実装機能

### 1. フィールド借用追跡
```cm
struct Point { int x; int y; }
Point p = {1, 2};
int* px = &p.x;  // 現在: pへの借用として追跡されない
Point q = move p; // 危険だが現在許可
```

**改善案**: フィールドアクセスパスを追跡

### 2. 制御フロー分析
```cm
int x = 42;
if (cond) {
    int y = move x;
}
println("{x}");  // 条件次第でエラー
```

**改善案**: 分岐ごとの移動状態マージ

### 3. async対応準備
```cm
async fn process() {
    string data = "hello";
    let task = async { println("{data}"); };
    string other = move data;  // 危険
    await task;
}
```

**改善案**: キャプチャ変数のmove禁止

---

## 設計方針

### シンプルさ優先
- ライフタイム注釈なし
- 値セマンティクス重視
- Rustより軽量な静的チェック

### Goに近いアプローチ
- 暗黙のコピーなし（`move`必須）
- `const`で不変性保証
- 安全性はコンパイラが検証

---

## 実装計画

### Phase 1: フィールド借用
1. `Symbol.borrow_paths`追加
2. フィールドアクセス時にパス記録
3. 親オブジェクトmove時にエラー

### Phase 2: 制御フロー
1. 基本ブロック単位の状態追跡
2. マージポイントでの状態結合
3. 条件付きmoveの検出

### Phase 3: async準備
1. クロージャキャプチャ解析
2. キャプチャ変数のmove禁止フラグ

---

## 非対応（意図的）
- ライフタイム注釈
- 部分move（フィールド単位）
- 複数可変借用チェック
