====================================================================
Cmコンパイラ プラットフォーム別最適化 調査結果サマリー
====================================================================

【調査日】2025-12-31
【対象プロジェクト】Cm言語コンパイラ v0.10.0
【調査コンポーネント】
  - src/mir/optimizations/ (12個の最適化パス)
  - src/codegen/{llvm,js,interpreter}/ (4つのプラットフォーム)

====================================================================
1. 現在の実装状況
====================================================================

★ MIRレベル最適化（すべてのプラットフォーム共通）

実装済み最適化パス（完了度: 100% Phase 1-5）:

【Phase 1】基礎最適化
  ✓ SCCP (条件付き定数伝播)
  ✓ ConstantFolding (定数畳み込み・型変換対応)
    → 400行の大規模実装
    → 整数演算、比較演算、型変換に対応

【Phase 2】データフロー最適化
  ✓ GVN (Global Value Numbering)
  ✓ CopyPropagation (コピー伝播)

【Phase 3】冗長性排除
  ✓ DSE (Dead Store Elimination)
    → メモリアクセス副作用を考慮

【Phase 4】制御フロー最適化
  ✓ SimplifyControlFlow (CFG簡約化)
  ✓ FunctionInlining (関数インライン化)

【Phase 5】ループ最適化
  ✓ LICM (Loop Invariant Code Motion, 323行)
    → Dominator Tree & Loop Analysis依存
    → ループ外移動前のPre-header自動作成

★ プラットフォーム別コード生成

【1】インタプリタ (MIRレベル直接実行)
  - 実装: src/codegen/interpreter/
  - 最適化: 不要（直接実行）
  - 用途: デバッグ用

【2】JavaScript
  - 実装: src/codegen/js/codegen.hpp/cpp
  - LLVM IRを経由しない直接生成
  - 最適化: 8種類（変数インライン化、ローカル宣言最適化など）
  - 特徴: CSS構造体の特別化、ボクシング分析

【3】LLVM Native
  - 実装: src/codegen/llvm/native/
  - パイプライン: MIR → LLVM IR → PassBuilder → NativeCode
  - 最適化: LLVM PassBuilderの40+パス（O1-O3対応）
  - 対応: x86_64, ARM64, カスタムトリプル

【4】WASM
  - 実装: src/codegen/llvm/wasm/
  - パイプライン: MIR → LLVM IR (wasm32-unknown-emscripten) → WASM
  - 最適化: Oz (コードサイズ優先)
  - 効果: バイナリサイズ20-40%削減

【5】ベアメタル (no_std)
  - 実装: src/codegen/llvm/native/target.hpp
  - ターゲット: ARM Cortex-M (STM32等)
  - 特別処理: スタートアップコード自動生成、リンカスクリプト生成
  - 最適化: Os (コードサイズ優先)

====================================================================
2. プラットフォーム固有の最適化が必要な理由
====================================================================

【MIRでは対応不可】

┌─────────────────────────────────────────────────────────────┐
│ アーキテクチャ固有情報の不足                                │
│ ・レジスタ数・種類                                          │
│ ・キャッシュサイズ・ライン数                                │
│ ・命令遅延・スループット                                    │
│ → LLVM Codegenで処理: InstCombine, MemorySSA, など         │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ 動的型情報・実行時フィードバック（JavaScript）             │
│ ・ホットパス検出                                            │
│ ・JIT コンパイルの判断                                     │
│ → V8/SpiderMonkeyの実行時解析で処理                        │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ メモリページング・間接呼び出し（WASM）                      │
│ ・線形メモリ制約                                            │
│ ・テーブルインデックス最小化                                │
│ → LLVM WASM Backend で処理                                │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│ スタック使用量・リアルタイム性（ベアメタル）               │
│ ・実行時メモリ配置                                          │
│ ・割り込みハンドラ干渉                                      │
│ → リンカスクリプト + LICM で部分対応                       │
└─────────────────────────────────────────────────────────────┘

【セマンティック保持の困難性】

例: メモリアクセス順序の変更
  MIR: _0 = load ptr[0]; call_func(); _1 = load ptr[1];
  最適化したい: ロードを先に実行
  リスク:
    - JavaScript: call_func()が_0に依存する可能性
    - WASM: Workers共有メモリで競合条件
    - ベアメタル: 割り込みハンドラの介入

  → プラットフォーム別の安全解析が必須

====================================================================
3. no_stdサポートの必要性
====================================================================

【現在のサポート状況】

実装済み:
  ✓ LLVMバックエンドでベアメタルターゲット対応
  ✓ ARM Cortex-M ターゲット設定
  ✓ スタートアップコード自動生成（_start, MSP初期化）
  ✓ リンカスクリプト自動生成（Flash/RAM分離）
  ✓ メモリセクション初期化（memcpy, memset）

未実装:
  ✗ スタック使用量静的解析
  ✗ メモリセクション最適化（ROM化）
  ✗ 割り込みハンドラ統合
  ✗ リアルタイム保証検証

【ベアメタル環境での制約】

メモリ制約（STM32L476例）:
  Flash: 256KB
  RAM:   64KB
  EEPROM: 6KB
  → Cm生成コードは Os で最適化必須

スタック管理:
  典型的な64KB RAM:
    - スタック: 下向き成長
    - ヒープ: 上向き成長
    - グローバル変数: 下部固定
  → スタック溢れのリスク高い
  → LICM によるスタック圧力軽減が重要

リアルタイム要件:
  ・予測可能な実行時間（キャッシュなし）
  ・割り込みレイテンシ < 1μs
  ・動的メモリ禁止（フラグメンテーション防止）

====================================================================
4. 最適化の詳細比較
====================================================================

【LLVM Native】
実装層: LLVM PassBuilder
パス数: 40+
対象: 汎用CPU (x86_64, ARM64)
最適化アプローチ:
  - O1: 基本最適化のみ
  - O2: フルセット（デフォルト）
  - O3: キャッシュ局所性、ベクトル化
特徴:
  ・レジスタ割り当て自動
  ・命令スケジューリング自動
  ・ベクトル化自動（SLPVectorizer）

【JavaScript】
実装層: Cm ソースコード（直接JS生成）
パス数: 8種類
対象: Web ブラウザ
最適化アプローチ:
  1. 変数インライン化（小さい式）
  2. 変数使用回数追跡
  3. 静的フロー分析
  4. ローカル宣言最適化
  5. CSS構造体特別化
  6. ボクシング分析
  7. Runtime Helper最小化
  8. オブジェクトリテラル最適化
特徴:
  ・動的型情報はJS Engineが処理
  ・JIT最適化もJS Engineが処理
  ・Cmの役割: コード生成の効率化に限定

【WASM】
実装層: LLVM PassBuilder (Oz)
パス数: サイズ優先パス群
対象: Web Assembly
最適化アプローチ:
  ・コードサイズ優先 (Oz)
  ・バイナリダウンロード時間削減
  ・メモリページング最適化
特徴:
  ・テーブルサイズ最小化（LLVM処理）
  ・間接呼び出し最適化（LLVM処理）
  ・バルクメモリ操作（Reference Types）

【ベアメタル】
実装層: LLVM PassBuilder (Os) + Custom
パス数: サイズ優先パス群 + 手動設定
対象: ARM Cortex-M
最適化アプローチ:
  ・コードサイズ優先 (Os)
  ・スタック圧力軽減（LICM活用）
  ・選別的インライン化
特徴:
  ・スタートアップコード自動生成
  ・リンカスクリプト自動生成
  ・スタック使用量追跡不足（課題）

====================================================================
5. 推奨される改善順序
====================================================================

【短期（3-6ヶ月）】高優先度

1. ベアメタル スタック使用量解析
   - 全関数のスタック使用量計測
   - 自動警告システム
   - 再帰深度検証
   効果: スタック溢れ防止、信頼性向上

2. WASM バイナリサイズ最適化
   - データセグメント圧縮
   - テーブル要素インライニング
   効果: ダウンロード時間短縮

3. JavaScript 型推測強化
   - 静的型情報の蓄積
   - JS Engine の JIT 最適化を促進
   効果: 実行速度向上

【中期（6-12ヶ月）】中優先度

1. LTO (Link-Time Optimization) 統合
   効果: 全体的な実行速度向上

2. プロファイル駆動最適化 (PGO) 基盤
   効果: 分岐予測、ホットパス最適化

3. ポインタ解析の実装
   効果: CSE 機会拡大、メモリ最適化

【長期（12月以上）】低優先度

1. WCET (Worst Case Execution Time) 推定
   効果: リアルタイム保証検証

2. 並列化最適化
   効果: マルチコア活用

3. 機械学習駆動最適化
   効果: ヒューリスティック自動化

====================================================================
6. アーキテクチャ改善案
====================================================================

【現状】
  MIR → Platform-specific Codegen → Output

【提案: プロファイル駆動最適化フレームワーク】
  MIR 
   → Instrumentation Pass 
   → Platform-specific Codegen → Output (Instrumented)
       ↓ [Profile Run]
       ↓ [Profile Data]
   → PGO Pass (Branch/Loop Optimization)
   → Platform-specific Codegen → Output (Optimized)

【提案: マルチターゲット最適化キャッシュ】
  type OptimizationCache {
    target: BuildTarget,
    optimization_level: 0-3,
    computed_analyses: {
      dominators: DominatorTree,
      loops: LoopAnalysis,
    },
    platform_hints: {
      native: { cache_line: 64, registers: 16 },
      wasm: { memory_pages: 1024 },
      baremetal: { stack_limit: 65536 },
    }
  }

====================================================================
7. まとめ
====================================================================

【強み】
✓ MIR レベルの包括的最適化パス実装
✓ プラットフォーム別の適切な最適化戦略
✓ スケーラブルで保守性の高いアーキテクチャ

【弱み】
✗ ベアメタル環境での詳細な最適化不足
✗ プロファイル駆動最適化の欠如
✗ ポインタ解析の未実装
✗ スタック使用量静的解析の未実装

【結論】
Cm コンパイラは、MIR レベルで汎用的な最適化をしっかり実装し、
各プラットフォームの特性に応じた専門的な最適化を適切に配置している。
特に LLVM Native と WASM は十分に実装されている。

今後は、組み込み系（no_std/ベアメタル）の詳細な最適化を強化し、
プロファイル駆動最適化フレームワークを導入することで、
さらに高度な最適化機構の実現が可能になる。

====================================================================
【詳細ドキュメント】
docs/optimization/platform_specific_optimization_analysis.md
====================================================================
