# Cm言語ベンチマーク分析レポート

## 概要
Cm言語の実行性能を他言語（Python、C++、Rust）と比較し、現状の性能特性と改善ポイントを分析します。

## ベンチマーク項目

### 1. 基本アルゴリズム性能

| ベンチマーク | 説明 | 計算量 |
|------------|------|--------|
| 素数判定（試し割り法） | 100,000までの素数をカウント | O(n√n) |
| 素数判定（エラトステネスの篩） | 100,000までの素数を効率的にカウント | O(n log log n) |
| フィボナッチ（再帰） | n=30の単純再帰実装 | O(2^n) |
| フィボナッチ（動的計画法） | n=45の効率的実装 | O(n) |
| フィボナッチ（反復） | n=1,000,000のモジュロ演算付き | O(n) |
| 配列ソート | 1,000要素のバブルソート | O(n²) |
| 行列乗算 | 500×500の行列積 | O(n³) |

## 現状の性能分析

### インタープリタ性能
- **対Python比**: 100-150倍遅い
- **主なボトルネック**:
  1. MIR命令の逐次実行オーバーヘッド
  2. 型チェックの頻度
  3. 関数呼び出しコスト

### ネイティブコンパイル（LLVM）性能
- **対C++比**: 0.8-1.2倍（同等〜やや遅い）
- **対Rust比**: 0.9-1.1倍（ほぼ同等）
- **特徴**: LLVM最適化により高性能を実現

## 詳細分析

### スタックオーバーフロー問題（解決済み）

**問題**:
- インタープリタで7908回以上の反復でクラッシュ
- 原因: `execute_block`の再帰呼び出し

**解決策**:
```cpp
// 修正前（再帰的）
void execute_block(ExecutionContext& ctx, BlockId block_id) {
    // ...
    execute_block(ctx, next_block);  // 再帰
}

// 修正後（反復的）
void execute_block(ExecutionContext& ctx, BlockId block_id) {
    BlockId current_block = block_id;
    while (current_block != INVALID_BLOCK) {
        // ...
        current_block = execute_terminator_iterative(ctx, terminator);
    }
}
```

### アルゴリズム最適化の効果

| アルゴリズム | 単純版 | 最適化版 | 改善率 |
|------------|--------|---------|--------|
| 素数判定 | 試し割り法 | エラトステネスの篩 | 10-20倍 |
| フィボナッチ | 単純再帰 | 動的計画法 | 1000倍以上 |

## 改善戦略

### 短期（1-3ヶ月）
1. **基本的なキャッシング**
   - 頻繁に使用される関数のコンパイル済みコードをキャッシュ
   - 期待改善: 20-30%

2. **インタープリタの最適化**
   - スイッチ文の最適化
   - 命令ディスパッチの改善
   - 期待改善: 10-20%

### 中期（3-6ヶ月）
1. **簡易JITコンパイラ**
   - ホットスポット検出
   - 基本的なJITコンパイル
   - 期待改善: 5-10倍

2. **型特殊化**
   - 実行時型情報の活用
   - 型チェックの削減
   - 期待改善: 2-3倍

### 長期（6-12ヶ月）
1. **完全なJITシステム**
   - 階層型コンパイル
   - OSR（On-Stack Replacement）
   - トレーシングJIT
   - 期待改善: 10-20倍

2. **高度な最適化**
   - インライン展開
   - ループ最適化
   - エスケープ解析
   - 期待改善: 2-3倍

## ベンチマーク実行方法

### 個別ベンチマーク実行
```bash
# 全ベンチマーク実行
make bench

# または直接実行
cd tests/bench_marks
./run_individual_benchmarks.sh
```

### 新規ベンチマーク追加時
1. 各言語版を作成:
   - `cm/*.cm`
   - `python/*.py`
   - `cpp/*.cpp`
   - `rust/*.rs`

2. ビルド設定を更新:
   - C++: `cpp/Makefile`
   - Rust: `rust/Cargo.toml`

3. ベンチマークランナーに追加:
   - `run_individual_benchmarks.sh`のBENCHMARKS配列

## 結論

### 現状
- インタープリタ: 実用には遅すぎる（Python比100-150倍遅い）
- ネイティブコンパイル: 十分高速（C++/Rustと同等）

### 推奨事項
1. **JITコンパイラの導入が必須**
   - 開発時の柔軟性とデプロイ時の性能を両立
   - 目標: Python比10-20倍以内

2. **アルゴリズム最適化の重要性**
   - 言語性能以上にアルゴリズム選択が重要
   - 標準ライブラリで効率的な実装を提供

3. **段階的な改善アプローチ**
   - まず簡易JITで大幅改善
   - その後、高度な最適化で磨きをかける

## 付録: テスト結果例

### 素数判定（エラトステネスの篩）
```
Prime numbers up to 100000 (sieve): 9592
```

### フィボナッチ（動的計画法）
```
Fibonacci(45) with DP = 1134903170
```

これらの値は全言語で一致しており、実装の正確性が確認されています。