digraph CmGrammar {
    rankdir=LR;
    node [shape=box, style=rounded];

    "program" [style="rounded,bold", color=blue];

    "top_level_decl" -> "import_statement";
    "top_level_decl" -> "function_decl";
    "top_level_decl" -> "struct_decl";
    "top_level_decl" -> "trait_decl";
    "top_level_decl" -> "impl_decl";
    "top_level_decl" -> "typedef_decl";
    "top_level_decl" -> "macro_decl";
    "top_level_decl" -> "enum_decl";
    "top_level_decl" -> "operator_decl";
    "import_statement" -> "string_literal";
    "function_decl" -> "type";
    "function_decl" -> "identifier";
    "function_decl" -> "block";
    "function_decl" -> "type";
    "function_decl" -> "identifier";
    "struct_decl" -> "identifier";
    "struct_member" -> "type";
    "struct_member" -> "identifier";
    "struct_member" -> "function_decl";
    "trait_decl" -> "identifier";
    "trait_member" -> "type";
    "trait_member" -> "identifier";
    "trait_member" -> "type";
    "trait_member" -> "identifier";
    "trait_member" -> "block";
    "impl_decl" -> "trait_name";
    "impl_decl" -> "type";
    "impl_decl" -> "type";
    "impl_member" -> "function_decl";
    "impl_member" -> "identifier";
    "impl_member" -> "type";
    "typedef_decl" -> "identifier";
    "typedef_decl" -> "type";
    "macro_decl" -> "identifier";
    "macro_decl" -> "block";
    "enum_decl" -> "identifier";
    "enum_decl" -> "enum_variant";
    "enum_variant" -> "identifier";
    "enum_variant" -> "identifier";
    "enum_variant" -> "type_list";
    "enum_variant" -> "identifier";
    "operator_decl" -> "operator_symbol";
    "operator_decl" -> "param_list";
    "operator_decl" -> "type";
    "operator_decl" -> "block";
    "operator_decl" -> "operator_symbol";
    "operator_decl" -> "param_list";
    "operator_decl" -> "type";
    "generic_params" -> "generic_param_list";
    "generic_param_list" -> "generic_param";
    "generic_param" -> "type_param";
    "generic_param" -> "const_param";
    "type_param" -> "identifier";
    "const_param" -> "identifier";
    "const_param" -> "type";
    "type_constraint" -> "union_type";
    "type_constraint" -> "type_name";
    "where_clause" -> "where_bound";
    "where_bound" -> "identifier";
    "where_bound" -> "interface_bound";
    "interface_bound" -> "trait_name";
    "type" -> "primitive_type";
    "type" -> "type_name";
    "type" -> "type_name";
    "type" -> "type_list";
    "type" -> "type";
    "type" -> "const_expr";
    "type" -> "type";
    "type" -> "type";
    "type" -> "type_list";
    "type" -> "union_type";
    "type" -> "expression";
    "union_type" -> "type";
    "type_list" -> "type";
    "type_name" -> "identifier";
    "trait_name" -> "identifier";
    "statement" -> "declaration_statement";
    "statement" -> "expression_statement";
    "statement" -> "if_statement";
    "statement" -> "switch_statement";
    "statement" -> "while_statement";
    "statement" -> "for_statement";
    "statement" -> "return_statement";
    "statement" -> "break_statement";
    "statement" -> "continue_statement";
    "statement" -> "defer_statement";
    "statement" -> "block";
    "declaration_statement" -> "type";
    "declaration_statement" -> "identifier";
    "expression_statement" -> "expression";
    "if_statement" -> "expression";
    "if_statement" -> "statement";
    "switch_statement" -> "expression";
    "case_clause" -> "const_expr";
    "while_statement" -> "expression";
    "while_statement" -> "statement";
    "for_statement" -> "statement";
    "for_statement" -> "type";
    "for_statement" -> "identifier";
    "for_statement" -> "expression";
    "for_statement" -> "statement";
    "for_init" -> "declaration_statement";
    "for_init" -> "expression";
    "defer_statement" -> "statement";
    "expression" -> "assignment_expr";
    "assignment_expr" -> "conditional_expr";
    "assignment_expr" -> "unary_expr";
    "assignment_expr" -> "assign_op";
    "assignment_expr" -> "assignment_expr";
    "conditional_expr" -> "logical_or_expr";
    "conditional_expr" -> "logical_or_expr";
    "conditional_expr" -> "expression";
    "conditional_expr" -> "conditional_expr";
    "logical_or_expr" -> "logical_and_expr";
    "logical_or_expr" -> "logical_or_expr";
    "logical_or_expr" -> "logical_and_expr";
    "logical_and_expr" -> "inclusive_or_expr";
    "logical_and_expr" -> "logical_and_expr";
    "logical_and_expr" -> "inclusive_or_expr";
    "inclusive_or_expr" -> "exclusive_or_expr";
    "inclusive_or_expr" -> "inclusive_or_expr";
    "inclusive_or_expr" -> "exclusive_or_expr";
    "exclusive_or_expr" -> "and_expr";
    "exclusive_or_expr" -> "exclusive_or_expr";
    "exclusive_or_expr" -> "and_expr";
    "and_expr" -> "equality_expr";
    "and_expr" -> "and_expr";
    "and_expr" -> "equality_expr";
    "equality_expr" -> "relational_expr";
    "equality_expr" -> "equality_expr";
    "equality_expr" -> "relational_expr";
    "relational_expr" -> "shift_expr";
    "relational_expr" -> "relational_expr";
    "relational_expr" -> "shift_expr";
    "shift_expr" -> "additive_expr";
    "shift_expr" -> "shift_expr";
    "shift_expr" -> "additive_expr";
    "additive_expr" -> "multiplicative_expr";
    "additive_expr" -> "additive_expr";
    "additive_expr" -> "multiplicative_expr";
    "multiplicative_expr" -> "cast_expr";
    "multiplicative_expr" -> "multiplicative_expr";
    "multiplicative_expr" -> "cast_expr";
    "cast_expr" -> "unary_expr";
    "cast_expr" -> "type";
    "cast_expr" -> "cast_expr";
    "unary_expr" -> "postfix_expr";
    "unary_expr" -> "unary_expr";
    "unary_expr" -> "unary_expr";
    "unary_expr" -> "unary_operator";
    "unary_expr" -> "cast_expr";
    "unary_expr" -> "type";
    "unary_expr" -> "unary_expr";
    "unary_expr" -> "expression";
    "postfix_expr" -> "primary_expr";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "expression";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "identifier";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "identifier";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "postfix_expr";
    "postfix_expr" -> "type_list";
    "primary_expr" -> "identifier";
    "primary_expr" -> "literal";
    "primary_expr" -> "expression";
    "primary_expr" -> "lambda_expr";
    "primary_expr" -> "format_string";
    "lambda_expr" -> "block";
    "capture_list" -> "capture_item";
    "capture_item" -> "identifier";
    "format_string" -> "format_string_content";
    "format_expr" -> "expression";
    "format_expr" -> "expression";
    "param_list" -> "parameter";
    "parameter" -> "type";
    "parameter" -> "identifier";
    "parameter" -> "type";
    "parameter" -> "identifier";
    "argument_list" -> "expression";
    "const_expr" -> "conditional_expr";
    "literal" -> "integer_literal";
    "literal" -> "float_literal";
    "literal" -> "char_literal";
    "literal" -> "string_literal";
    "literal" -> "bool_literal";
    "literal" -> "null_literal";
    "integer_literal" -> "decimal_literal";
    "integer_literal" -> "hex_literal";
    "integer_literal" -> "binary_literal";
    "integer_literal" -> "octal_literal";
    "string_literal" -> "raw_string_literal";
    "preprocessor_directive" -> "string_literal";
    "preprocessor_directive" -> "identifier";
    "preprocessor_directive" -> "identifier";
    "preprocessor_directive" -> "identifier";
    "preprocessor_directive" -> "const_expr";
    "preprocessor_directive" -> "const_expr";
    "attribute" -> "attribute_list";
    "attribute_list" -> "attribute_spec";
    "attribute_spec" -> "identifier";
    "attribute_spec" -> "identifier";
    "attribute_spec" -> "argument_list";
}