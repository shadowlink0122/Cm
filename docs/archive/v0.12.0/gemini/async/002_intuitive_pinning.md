# 直感的なPinning: `pinned` 修飾子の導入

## 1. Rustの `Pin` の問題点
Rustでは、自己参照構造体を実現するために `Pin<P>` というラッパー型を使用します。
*   **複雑性**: `Pin<&mut T>` や `Unpin` トレイトの理解が必要。
*   **型システムへの侵入**: ユーザーコードの至る所に `Pin` が現れる。
*   **開発体験**: 「値が移動しないこと」を保証したいだけなのに、ポインタ型を操作させられる。

## 2. 提案: `pinned` 修飾子

Cm言語では、型ではなく**変数宣言時の属性**として「移動不可」を表現します。

### 2.1 構文

```cm
struct SelfRef {
    int value;
    int* ptr;
}

// pinned 変数宣言
pinned SelfRef x = SelfRef { value: 10, ptr: null };

// 初期化後は移動禁止
x.ptr = &x.value; // OK: xは移動しないため安全

// let y = x; // エラー: pinned変数は移動（Move）できない
// func(x);   // エラー: 値渡し（Move）禁止
func(&x);     // OK: 参照渡しは可能
```

### 2.2 コンパイラによる保証

`pinned` 属性が付いた変数は、以下の操作がコンパイルエラーになります。
1.  **Move**: 代入の右辺に置くこと、関数の引数として値渡しすること。
2.  **Copy**: `Copy` トレイトを持っていてもコピー禁止。
3.  **Swap**: `mem::swap` などのメモリ入れ替え操作。

### 2.3 `async` との連携

`async` ブロックや関数内で生成されるステートマシンは、コンパイラによって自動的に `pinned` 扱いとなります。

```cm
async void task() {
    int x = 10;
    int* p = &x; // 内部的に x は pinned 領域にあるため安全
    some_async_op().await;
    println("{}", *p);
}
```

### 2.4 構造体フィールドへの伝播

構造体自体を `pinned struct` として定義することも可能です。

```cm
pinned struct FutureState {
    int data;
    int* self_ref;
}
```

この構造体のインスタンスは、`pinned` 変数にしか代入できません。
`let x = FutureState(...);` と書くと、`x` は自動的に `pinned` 推論されます。

## 3. 実装詳細

### 3.1 MIR表現
MIRにおいて、ローカル変数（`LocalDecl`）に `is_pinned` フラグを持たせます。
`Move` オペコードの生成時や、`Call` 命令の引数処理時に、このフラグをチェックし、違反があればエラーを出力します。

### 3.2 ヒープ上のPin
`Box<T>` に入れた場合も、`pinned Box<T>` とすることで、中身の移動を禁止します。
（Cmの `Box` は所有権を持つポインタなので、`Box` 自体がムーブされなければ、中身のアドレスは変わりません。`pinned Box` は `Box` 自体のムーブを禁止します）

## 4. `Unpin` は不要か？
Rustの `Unpin` は「Pinされていても移動しても安全な型」を表します。
Cmの `pinned` は「この変数は移動させない」という**変数の性質**なので、型としての `Unpin` は不要です。
「移動しても安全な型」であっても、`pinned` 宣言されれば移動できません。これによりルールが単純化されます。

この設計により、ユーザーは「自己参照したいなら `pinned` をつける」という直感的なルールだけで安全なコードを書くことができます。
