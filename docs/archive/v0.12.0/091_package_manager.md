# Cm Package Manager (cpm) Design
**Date**: 2026-01-14
**Version**: v0.12.0

## 概要

`cpm`（Cm Package Manager）はCm言語の公式パッケージ管理ツールです。依存関係の解決、パッケージの公開、ビルド管理を統合的に提供します。

## 設計目標

1. **シンプルな依存管理**: 明確で理解しやすい依存関係
2. **高速な依存解決**: 並列ダウンロード、インクリメンタルビルド
3. **セキュアな配布**: 署名検証、脆弱性スキャン
4. **モノレポサポート**: ワークスペース機能
5. **プライベートレジストリ**: 企業向けの内部パッケージ管理

## アーキテクチャ

### システム構成

```
┌────────────────────────────────────────────┐
│                  cpm CLI                    │
├──────────┬──────────┬──────────┬──────────┤
│ Package  │  Build   │ Registry │  Workspace│
│ Manager  │  System  │  Client  │  Manager  │
├──────────┴──────────┴──────────┴──────────┤
│          Dependency Resolver               │
├────────────────────────────────────────────┤
│            Lock File Manager               │
├────────────────────────────────────────────┤
│          Cache & Download Manager          │
└────────────────────────────────────────────┘
```

### ディレクトリ構造

```
project/
├── Cm.toml                  # プロジェクト設定
├── Cm.lock                  # ロックファイル
├── src/
│   ├── lib.cm              # ライブラリエントリポイント
│   └── main.cm             # 実行可能ファイルエントリポイント
├── tests/                   # テストコード
├── benches/                 # ベンチマーク
├── examples/                # サンプルコード
└── target/                  # ビルド出力
    ├── debug/
    ├── release/
    └── deps/               # 依存パッケージ
```

## パッケージ仕様

### Cm.toml フォーマット

```toml
[package]
name = "my-package"
version = "0.1.0"
edition = "2025"
authors = ["Your Name <you@example.com>"]
description = "A brief description"
license = "MIT OR Apache-2.0"
repository = "https://github.com/user/repo"
keywords = ["web", "api", "async"]
categories = ["web-programming", "network-programming"]

[dependencies]
http_server = "1.2.3"
json = { version = "2.0", features = ["preserve_order"] }
regex = { version = "1.5", optional = true }

# プライベートGitリポジトリ
my_lib = { git = "https://github.com/user/private-repo", branch = "main" }

# ローカルパッケージ
local_lib = { path = "../local_lib" }

[dev-dependencies]
test_framework = "3.0"
mock = "1.0"

[build-dependencies]
code_gen = "0.5"

[features]
default = ["std"]
std = []
async = ["async_runtime", "http_server/async"]
full = ["async", "regex"]

[[bin]]
name = "my-app"
path = "src/bin/main.cm"

[lib]
name = "my_lib"
path = "src/lib.cm"
crate-type = ["lib", "staticlib", "cdylib"]

[profile.release]
opt-level = 3           # 0-3
debug = false
lto = true             # Link Time Optimization
strip = true           # Strip symbols

[profile.dev]
opt-level = 0
debug = true

[workspace]
members = [
    "core",
    "utils",
    "cli"
]

[patch.crates-io]
some_crate = { path = "../patched_crate" }
```

## 主要機能

### 1. パッケージ管理コマンド

```bash
# 新規プロジェクトの作成
cpm new my_project
cpm init  # 既存ディレクトリで初期化

# 依存関係の管理
cpm add http_server@1.2.3    # 依存関係を追加
cpm add --dev test_framework  # 開発依存を追加
cpm remove regex              # 依存関係を削除
cpm update                    # 全依存関係を更新
cpm update http_server        # 特定パッケージを更新

# ビルド・実行
cpm build                     # デバッグビルド
cpm build --release          # リリースビルド
cpm run                      # メインバイナリを実行
cpm run --bin another_bin    # 特定バイナリを実行
cpm test                     # テスト実行
cpm bench                    # ベンチマーク実行

# パッケージ公開
cpm publish                  # crates.ioに公開
cpm yank --vers 1.0.0       # バージョンを非推奨に
cpm owner --add username     # 所有者を追加

# 情報表示
cpm search http              # パッケージ検索
cpm info http_server         # パッケージ情報表示
cpm tree                     # 依存関係ツリー表示
cpm audit                    # セキュリティ監査
```

### 2. 依存関係解決アルゴリズム

```rust
// SATソルバーベースの依存解決
struct DependencyResolver {
    registry: Registry,
    cache: Cache,
}

impl DependencyResolver {
    fn resolve(&self, manifest: &Manifest) -> Result<ResolvedGraph> {
        let mut solver = SatSolver::new();

        // 1. 全バージョンの組み合わせを変数として追加
        for dep in manifest.dependencies() {
            let versions = self.registry.get_versions(dep.name)?;
            for version in versions {
                solver.add_variable(PackageVersion {
                    name: dep.name.clone(),
                    version,
                });
            }
        }

        // 2. 制約を追加
        self.add_version_constraints(&mut solver, manifest)?;
        self.add_conflict_constraints(&mut solver)?;
        self.add_feature_constraints(&mut solver)?;

        // 3. 解を求める
        let solution = solver.solve()?;

        // 4. 解決グラフを構築
        Ok(self.build_graph(solution))
    }
}
```

### 3. ロックファイル（Cm.lock）

```toml
# This file is automatically @generated by cpm.
# It is not intended for manual editing.
version = 3

[[package]]
name = "http_server"
version = "1.2.3"
source = "registry+https://crates.io"
checksum = "abc123..."
dependencies = [
    "async_runtime 2.0.1",
    "socket 3.1.0"
]

[[package]]
name = "my_project"
version = "0.1.0"
dependencies = [
    "http_server 1.2.3",
    "json 2.0.5"
]
```

### 4. ビルドシステム統合

```rust
// build.cm - カスタムビルドスクリプト
fn main() {
    // コード生成
    generate_bindings();

    // リンクライブラリの指定
    println("cargo:rustc-link-lib=native=foo");
    println("cargo:rustc-link-search=native=/usr/local/lib");

    // 環境変数の設定
    println("cargo:rustc-env=GENERATED_PATH={}", out_dir);
}
```

## レジストリシステム

### 1. 公式レジストリ（crates.io互換）

```
https://crates.io/
├── api/v1/
│   ├── crates              # パッケージ一覧
│   ├── crates/{name}       # パッケージ詳細
│   ├── crates/{name}/versions  # バージョン一覧
│   └── crates/{name}/{version}/download  # ダウンロード
├── index/                   # Gitベースのインデックス
└── storage/                 # パッケージストレージ
```

### 2. プライベートレジストリ

```toml
# .cpm/config.toml
[registries]
company = { index = "https://git.company.com/cpm-index" }

[source.crates-io]
replace-with = "company-mirror"

[source.company-mirror]
registry = "https://cpm.company.com"
```

### 3. パッケージ公開API

```rust
// パッケージのアップロード
struct PublishRequest {
    name: String,
    version: Version,
    dependencies: Vec<Dependency>,
    authors: Vec<String>,
    description: String,
    license: String,
    readme: Option<String>,
    repository: Option<String>,
    tarball: Vec<u8>,
}

impl Registry {
    async fn publish(&self, req: PublishRequest) -> Result<()> {
        // 1. 認証チェック
        self.authenticate()?;

        // 2. バージョン重複チェック
        if self.version_exists(&req.name, &req.version)? {
            return Err(Error::VersionAlreadyExists);
        }

        // 3. ライセンス検証
        self.validate_license(&req.license)?;

        // 4. tarballの検証とスキャン
        self.scan_malware(&req.tarball)?;

        // 5. メタデータとファイルの保存
        self.store_package(req).await?;

        Ok(())
    }
}
```

## セキュリティ機能

### 1. パッケージ署名

```rust
// Ed25519による署名
impl PackageSigner {
    fn sign_package(&self, package: &Package) -> Signature {
        let private_key = self.load_private_key()?;
        let message = package.to_bytes();
        ed25519::sign(&message, &private_key)
    }

    fn verify_signature(&self, package: &Package, sig: &Signature) -> bool {
        let public_key = self.get_publisher_key(&package.author)?;
        ed25519::verify(sig, &package.to_bytes(), &public_key)
    }
}
```

### 2. 脆弱性スキャン

```bash
# セキュリティ監査
cpm audit

# 出力例
Scanning Cm.lock...
Found 2 vulnerabilities:

CRITICAL: http_server v1.2.0 has known RCE vulnerability
  Upgrade to v1.2.4 or later
  CVE-2025-1234

MODERATE: json v1.9.0 has DoS vulnerability
  Upgrade to v2.0.0 or later
  CVE-2025-5678
```

### 3. 依存関係のサンドボックス化

```toml
# パッケージごとの権限設定
[package.permissions]
network = false         # ネットワークアクセス
filesystem = ["read"]   # ファイルシステムアクセス
env = ["HOME", "PATH"] # 環境変数アクセス
```

## キャッシュシステム

### 1. グローバルキャッシュ

```
~/.cpm/
├── registry/
│   ├── index/           # レジストリインデックス
│   ├── cache/           # パッケージtarball
│   └── src/             # 展開されたソース
├── git/
│   ├── db/              # Gitリポジトリ
│   └── checkouts/       # チェックアウト
└── target-cache/        # ビルド成果物キャッシュ
```

### 2. インクリメンタルコンパイル

```rust
// ビルドグラフの差分検出
impl BuildCache {
    fn needs_rebuild(&self, unit: &CompileUnit) -> bool {
        // 1. ソースファイルの変更チェック
        if self.source_modified(unit) {
            return true;
        }

        // 2. 依存関係の変更チェック
        if self.deps_modified(unit) {
            return true;
        }

        // 3. コンパイラフラグの変更チェック
        if self.flags_changed(unit) {
            return true;
        }

        false
    }
}
```

## ワークスペース機能

### 1. モノレポサポート

```toml
# ルートCm.toml
[workspace]
members = ["packages/*", "tools/*"]
default-members = ["packages/core"]
resolver = "2"  # 新しい依存解決アルゴリズム

[workspace.dependencies]
common_lib = { version = "1.0", path = "packages/common" }

[workspace.metadata]
ci = { test-threads = 4 }
```

### 2. 共有ビルドキャッシュ

```
workspace/
├── Cm.toml              # ワークスペースルート
├── Cm.lock              # 共有ロックファイル
├── target/              # 共有ビルド出力
├── packages/
│   ├── core/
│   │   └── Cm.toml
│   └── utils/
│       └── Cm.toml
└── tools/
    └── cli/
        └── Cm.toml
```

## パフォーマンス最適化

### 1. 並列ダウンロード

```rust
impl ParallelDownloader {
    async fn download_all(&self, packages: Vec<Package>) -> Result<()> {
        let semaphore = Arc::new(Semaphore::new(10)); // 最大10並列

        let futures = packages.into_iter().map(|pkg| {
            let sem = semaphore.clone();
            async move {
                let _permit = sem.acquire().await?;
                self.download_package(pkg).await
            }
        });

        futures::future::try_join_all(futures).await?;
        Ok(())
    }
}
```

### 2. 差分アップデート

```rust
// 最小限の再ビルド
impl IncrementalBuilder {
    fn compute_dirty_units(&self, changes: &[FileChange]) -> Vec<CompileUnit> {
        let mut dirty = HashSet::new();

        for change in changes {
            // 変更されたファイルに依存するユニットを追跡
            let affected = self.reverse_deps.get(&change.path);
            dirty.extend(affected);
        }

        dirty.into_iter().collect()
    }
}
```

## エラーメッセージ

```rust
// ユーザーフレンドリーなエラー
enum CpmError {
    VersionConflict {
        package: String,
        required: VersionReq,
        found: Version,
        required_by: Vec<String>,
    },
    CyclicDependency {
        cycle: Vec<String>,
    },
}

impl Display for CpmError {
    fn fmt(&self, f: &mut Formatter) -> Result {
        match self {
            Self::VersionConflict { package, required, found, required_by } => {
                write!(f, "
❌ Version conflict for package '{}'

Required: {}
Found: {}

Required by:
{}

Try running 'cpm update' or modify version requirements
                ", package, required, found,
                required_by.iter().map(|p| format!("  - {}", p)).collect::<Vec<_>>().join("\n"))
            }
            // ...
        }
    }
}
```

## 実装優先順位

1. **Phase 1** (v0.12.0): 基本的なパッケージ管理、依存解決
2. **Phase 2** (v0.13.0): レジストリ統合、セキュリティ機能
3. **Phase 3** (v0.14.0): ワークスペース、高度な最適化