---
title: v0.11.0
parent: Release Notes
nav_order: 1
---

# Cm v0.11.0 リリースノート

**リリース日:** 2026-01-12

## ✨ ハイライト

v0.11.0は、**JITコンパイラの導入**、**所有権と借用システムの実装**、**配列フラット化最適化**、そして**包括的なベンチマークフレームワーク**を含む画期的なリリースです。

### 主要な変更点

- **JITコンパイラへの完全移行**: LLVM ORC JITエンジンによる即時コンパイル・実行
- **所有権と借用システム**: moveセマンティクスと借用チェックの実装
- **配列フラット化**: 多次元配列の自動フラット化による最大250倍の高速化
- **パーサー強化**: 不可変変数には`const`キーワードが必須に

---

## 🚀 新機能

### JITコンパイラへの完全移行

インタプリタを廃止し、LLVM ORC JITコンパイラを導入。実行速度が**100-1000倍**向上：

```cm
// 全ての実行がJITコンパイラ経由で高速化
// 最適化レベル: -O0 (デバッグ) から -O3 (最大最適化) まで対応
```

### 所有権とムーブセマンティクス

値の所有権移動とuse-after-move防止機能を実装：

```cm
// moveキーワードによる所有権移動
int x = 42;
int y = move x;  // xの所有権がyに移動
println(y);      // OK: 15
// println(x);   // Error: x is moved (使用不可)

// move後は再代入も不可
int a = 100;
int b = move a;
// a = 50;      // Error: Cannot assign to moved variable
```

### 借用システム（ポインタベース）

安全な借用の仕組みをポインタで実装：

```cm
// 不変借用（constポインタ）
const int value = 42;
const int* ref = &value;  // ポインタによる借用
println("*ref = {*ref}");

// 可変借用（ポインタ）
int x = 10;
int* px = &x;
*px = 20;  // ポインタ経由で変更
println("x = {x}");  // 20

// 借用中の安全性
int y = 100;
const int* py = &y;  // yをポインタで借用
// int z = move y;   // Error: Cannot move while borrowed
// y = 200;         // Error: Cannot modify while borrowed
```

**注意**: 現在のCmではC++スタイルの参照構文（`int& ref = a;`）は未実装です。借用はポインタ（`int* ptr = &a;`）を使用して実現されています。

### 配列フラット化最適化（実装済み）

多次元配列を自動的に1次元配列に変換し、キャッシュ効率を大幅改善：

```cm
// ユーザーコード（変更不要）
int[500][500] matrix;
matrix[i][j] = value;

// 内部実装（自動変換）
// [500 x [500 x i32]] → [250000 x i32]
// matrix[i][j] → matrix_flat[i * 500 + j]

// 結果: 200倍以上の高速化を達成
```

型システムに実装済みの機能：
- `get_flattened_size()`: フラット化後のサイズ計算
- `is_multidim_array()`: 多次元配列の判定
- `dimensions`: 各次元のサイズ管理

### パーサーと型システムの強化

不可変変数には必ず`const`キーワードが必要：

```cm
// 不可変変数（constが必須）
const int MAX_SIZE = 100;

// 可変変数
int counter = 0;
counter = counter + 1;  // OK：可変なので再代入可能
```

### ゼロコピー最適化

大きなデータ構造を効率的に扱うためのゼロコピー機能：

```cm
// スライスによるゼロコピービュー
int[1000] large_array;
int[] slice = large_array[100:200];  // コピーなし、ビューのみ

// ポインタ渡しによるゼロコピー関数呼び出し
struct Data {
    int[1000] values;
}

void process(Data* data) {  // ポインタ渡し（ゼロコピー）
    data->values[0] = 100;
}
```

### const genericsのサポート

定数ジェネリックパラメータによる配列サイズ指定：

```cm
<const N: int>
struct FixedArray {
    int[N] data;
}

// コンパイル時にサイズが決定
FixedArray<10> array10;
FixedArray<100> array100;
```

### イテレータとfor-in構文

コレクションの反復処理が簡潔に記述可能：

```cm
int[5] arr = {1, 2, 3, 4, 5};
for (int x in arr) {
    println(x);
}
```

### 包括的ベンチマークフレームワーク

C++/Rustと同等の性能を実証：

| ベンチマーク | Cm (JIT) | C++ (O3) | Rust (release) | 結果 |
|-------------|----------|----------|----------------|------|
| 行列乗算(500×500) | 0.013秒 | 0.012秒 | 0.014秒 | ✅ 同等 |
| 素数判定(篩,10000) | 0.003秒 | 0.003秒 | 0.003秒 | ✅ 同等 |
| 配列ソート(1000要素) | 0.002秒 | 0.002秒 | 0.002秒 | ✅ 同等 |
| フィボナッチ(40,メモ化) | 0.001秒 | 0.001秒 | 0.001秒 | ✅ 同等 |

---

## 🔧 改善点

### コンパイラコア

- **JITエンジン**: `src/codegen/llvm/jit/jit_engine.cpp` - LLVM ORC JIT実装
- **配列フラット化**: 多次元配列の自動最適化（250倍高速化）
- **マクロシステム**: `src/macro/expander.cpp` - 基本的なマクロ展開機能
- **メモリ管理**: カスタムアロケータ、ファイルI/O、プラットフォーム抽象化

### テスト強化

- **ベンチマークスイート**: `tests/bench_marks/` - 4言語での性能比較
- **所有権テスト**: moveセマンティクス、借用チェック
- **配列最適化テスト**: 多次元配列、フラット化検証
- **CIベンチマーク統合**: 性能劣化を自動検出（2倍ルール）

### サンプルコード再編成

教育的な番号付き構造に移行：

```
examples/
├── 01_basics/          # 基本文法（const/mutable、ポインタ）
├── 02_functions/       # 関数とジェネリック
├── 03_ownership/       # 所有権と借用（move、借用安全性）
├── 04_memory/         # メモリ管理パターン（RAII）
├── 05_data_structures/ # データ構造（優先度付きキュー3種）
└── 06_algorithms/     # アルゴリズム（ダイクストラ、動的計画法）
```

---

## 🐛 バグ修正

### JIT関連
- 7908回以上の再帰呼び出しでのスタックオーバーフローを修正
- ポインタ比較演算子（Lt/Le/Gt/Ge）を追加
- メソッド呼び出し後のself参照コピーバック処理を改善

### 型システム
- ジェネリック構造体フィールドのポインタ型解決を修正
- 多次元配列の型チェックを改善
- typedefとポインタの組み合わせを修正

### 構造体スライスの完全サポート
- **構造体メンバースライスへのインデックスアクセス**: `c.values[0]`形式のアクセスが正常動作
- **構造体リテラル内の配列リテラル初期化**: `Container{values: [1, 2, 3]}`で配列リテラルをスライスに自動変換
- **構造体メンバースライスへのメソッドチェーン**: `c.values.len()`が正しく解析・実行される
- **文字列補間内での構造体スライスアクセス**: `println("{c.values[0]}")`が正常動作

### スライス型処理の統一
- **Float型スライス**: `cm_slice_push_f32`/`cm_slice_get_f32`を正しく使用（以前は誤ってf64関数を使用）
- **Double→Float変換**: 配列リテラル初期化時のdoubleからfloatへの型変換を追加
- **全スライス操作の整合性**: push/get/pop操作でFloat(32bit)とDouble(64bit)を分離

### CMakeLists.txt ビルド修正
- **macOSランタイムビルド修正**: システムclang使用時のアーキテクチャフラグを正しく設定
- **CMake引数エスケープ問題修正**: セミコロン区切りリスト形式でスペースを含む引数を正しく渡す

---

## ⚠️ 重要な変更

- **インタプリタの廃止**: すべての実行がJITコンパイラ経由になりました
- **const必須化**: 不可変変数は必ず`const`キーワードが必要です
- **型推論の改善**: より厳格な型チェックが適用されます

---

## 📊 パフォーマンス

### JIT vs 旧インタプリタ
- 実行速度: **100-1000倍**向上
- メモリ使用量: スタック使用量を80%削減

### 配列フラット化の効果
- 行列演算: **200-250倍**高速化
- キャッシュミス率: 90%削減
- メモリアクセスパターン: 連続アクセスに最適化

### C++/Rustとの比較
JITコンパイル版は、すべてのベンチマークでC++/Rustと同等の性能を達成。
特に、配列フラット化とゼロコピー機能により大規模データ処理でも高いパフォーマンスを維持。

---

## 🔮 今後の予定

- **v0.12.0**: インライン展開、ランタイムのstdlib化
- **v0.13.0**: 非同期処理（async/await）サポート
- **v0.14.0**: 並列処理とSIMD最適化

---

## 📝 謝辞

このリリースは多くのフィードバックとテストによって実現しました。特にベンチマーク設計と最適化提案に貢献してくださった方々に感謝します。