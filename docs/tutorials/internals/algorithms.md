---
layout: default
title: å†…éƒ¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
nav_order: 5
has_children: false
---

# ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©å†…éƒ¨ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

**å­¦ç¿’ç›®æ¨™:** Cmã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ä½¿ç”¨ã•ã‚Œã¦ã„ã‚‹ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ç†è§£ã—ã¾ã™ã€‚  
**æ‰€è¦æ™‚é–“:** 20åˆ†  
**é›£æ˜“åº¦:** ğŸ”´ ä¸Šç´š

---

## æ¦‚è¦

Cmã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–ã®æ¨™æº–çš„ãªã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

---

## ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æ

### Work-listã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

åæŸã™ã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—è§£æã‚’è¡Œã„ã¾ã™ã€‚

**ä½¿ç”¨ç®‡æ‰€:** SCCP, å®šæ•°ä¼æ’­, ç”Ÿå­˜å¤‰æ•°è§£æ

```
Input:  CFG (Control Flow Graph)
Output: å„ãƒã‚¤ãƒ³ãƒˆã§ã®ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼æƒ…å ±

worklist = å…¨åŸºæœ¬ãƒ–ãƒ­ãƒƒã‚¯
while worklist is not empty:
    block = worklist.pop()
    old = out[block]
    in[block] = âˆª out[predecessor]  // å‰æ–¹è§£æ
    out[block] = transfer(block, in[block])
    if out[block] â‰  old:
        add successors to worklist
```

---

## åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼è§£æ

### Tarjan's SCCï¼ˆå¼·é€£çµæˆåˆ†åˆ†è§£ï¼‰

å¾ªç’°ä¾å­˜ã‚’æ¤œå‡ºã—ã¾ã™ã€‚

**ä½¿ç”¨ç®‡æ‰€:** ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å¾ªç’°ä¾å­˜æ¤œå‡º

```
æ™‚é–“è¨ˆç®—é‡: O(V + E)
ç©ºé–“è¨ˆç®—é‡: O(V)
```

### æ”¯é…æœ¨ï¼ˆDominator Treeï¼‰

ã‚ã‚‹åœ°ç‚¹ã‚’å¿…ãšé€šéã™ã‚‹ã‹åˆ¤å®šã—ã¾ã™ã€‚

**ä½¿ç”¨ç®‡æ‰€:** LICMï¼ˆãƒ«ãƒ¼ãƒ—æ¤œå‡ºï¼‰ã€SSAæ§‹ç¯‰

```
æ™‚é–“è¨ˆç®—é‡: O(V Ã— Î±(V))  // Î±ã¯ã‚¢ãƒƒã‚«ãƒ¼ãƒãƒ³é–¢æ•°ã®é€†é–¢æ•°
```

---

## ä¸­é–“è¡¨ç¾

### SSAå½¢å¼ï¼ˆStatic Single Assignmentï¼‰

å„å¤‰æ•°ã¸ã®ä»£å…¥ã‚’1å›ã«é™å®šã—ãŸå½¢å¼ã€‚

**åˆ©ç‚¹:**
- Use-Defãƒã‚§ãƒ¼ãƒ³ã®åŠ¹ç‡åŒ–
- å®šæ•°ä¼æ’­ã®ç°¡æ˜“åŒ–
- ãƒ‡ãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰æ¤œå‡ºã®å®¹æ˜“åŒ–

```cm
// é€šå¸¸ã®ã‚³ãƒ¼ãƒ‰
x = 1;
x = 2;
y = x;

// SSAå½¢å¼
x_1 = 1;
x_2 = 2;
y = x_2;
```

### Ï†é–¢æ•°

è¤‡æ•°ã®çµŒè·¯ã‹ã‚‰ã®å€¤ã‚’çµ±åˆã—ã¾ã™ã€‚

```
if (cond) {
    x_1 = 10;
} else {
    x_2 = 20;
}
x_3 = Ï†(x_1, x_2);  // å®Ÿè¡ŒçµŒè·¯ã«å¿œã˜ãŸå€¤ã‚’é¸æŠ
```

---

## æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

### Value Numbering

å¼ã®ç­‰ä¾¡æ€§ã‚’ãƒãƒƒã‚·ãƒ¥ã§åˆ¤å®šã—ã¾ã™ã€‚

**ä½¿ç”¨ç®‡æ‰€:** GVNï¼ˆå…±é€šéƒ¨åˆ†å¼é™¤å»ï¼‰

```
hash(a + b) == hash(b + a)  // å¯æ›æ¼”ç®—ã®æ­£è¦åŒ–
```

### ãƒ«ãƒ¼ãƒ—è§£æ

ãƒ«ãƒ¼ãƒ—æ§‹é€ ã‚’ç‰¹å®šã—ã¦LICMã‚’é©ç”¨ã—ã¾ã™ã€‚

1. ãƒãƒƒã‚¯ã‚¨ãƒƒã‚¸æ¤œå‡ºï¼ˆå¾Œé€€è¾ºï¼‰
2. ãƒ«ãƒ¼ãƒ—ãƒ˜ãƒƒãƒ€ç‰¹å®š
3. ãƒ«ãƒ¼ãƒ—æœ¬ä½“ã®åé›†
4. ä¸å¤‰å¼ã®ç‰¹å®š

---

## å‹ã‚·ã‚¹ãƒ†ãƒ 

### å‹æ¨è«–è¨ˆç”»ï¼ˆå°†æ¥ï¼‰

Hindley-Milnerå‹æ¨è«–ã‚’å°å…¥äºˆå®šï¼š

1. **å‹å¤‰æ•°ç”Ÿæˆ** - ä¸æ˜ãªå‹ã«å¤‰æ•°ã‚’å‰²ã‚Šå½“ã¦
2. **åˆ¶ç´„åé›†** - å¼ã‹ã‚‰å‹ã®ç­‰å¼ã‚’åé›†
3. **å˜ä¸€åŒ–** - åˆ¶ç´„ã‚’è§£ã„ã¦å‹ã‚’æ±ºå®š

```
Given: f(1, "hello")
Constraint: T1 = int, T2 = string
Unify: T = (int, string) -> R
```

---

## Monomorphizationï¼ˆå˜ç›¸åŒ–ï¼‰

ã‚¸ã‚§ãƒãƒªãƒƒã‚¯é–¢æ•°ã‚’å…·è±¡å‹ã”ã¨ã«ç”Ÿæˆã—ã¾ã™ã€‚

```cm
// ã‚¸ã‚§ãƒãƒªãƒƒã‚¯å®šç¾©
func identity<T>(T x) -> T { return x; }

// ç”Ÿæˆã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ‰
func identity__int(int x) -> int { return x; }
func identity__string(string x) -> string { return x; }
```

---

## å‚è€ƒè³‡æ–™

- [æœ€é©åŒ–ãƒ‘ã‚¹](compiler/optimization.md) - å„ãƒ‘ã‚¹ã®è©³ç´°
- [Engineering a Compiler](https://www.elsevier.com/books/engineering-a-compiler/cooper/978-0-12-815412-0) - Cooper & Torczon
- [SSA-based Compiler Design](https://link.springer.com/book/10.1007/978-3-030-80515-9) - SSAã®è©³ç´°

