# コンパイル時静的解析の強化提案

**日付**: 2026年1月5日
**作成者**: Gemini Agent
**概要**: コンパイル時に検出可能な論理エラーやアンチパターンを警告・エラーとして報告し、コードの安全性と品質を向上させるためのチェックリストと実装方針。

## 1. 変数の状態と可変性に関するチェック

### 1.1 再代入のない可変変数の検出 (Unused Mutability)
**ユーザー提案**: `let mut` (あるいは `var`) で宣言された変数が、スコープ内で一度も再代入されていない場合。
- **目的**: 意図しない可変性を排除し、コードの予測可能性を高める。
- **挙動**: Warning ("Variable 'x' is declared mutable but never reassigned. Consider making it const.")
- **実装**: シンボルテーブルまたはMIRのデータフロー解析で、各変数の「代入回数」をカウントする。

### 1.2 初期化前の使用 (Use Before Initialization)
**必須**: 変数が初期化される前に参照されるパスが存在する場合。
- **目的**: 未定義動作やランダムな値の参照を防ぐ。
- **挙動**: Error
- **実装**: CFG (Control Flow Graph) 上でのDefinite Assignment Analysis（確定代入解析）。分岐の全てのパスで初期化されているかを検証する。

### 1.3 変数のシャドーイング (Variable Shadowing)
**推奨**: 内側のスコープで宣言された変数が、外側のスコープの変数と同名である場合。
- **目的**: 意図せずに外側の変数を隠蔽してしまい、バグの原因になるのを防ぐ。
- **挙動**: Warning
- **実装**: スコープスタックを確認し、上位スコープに同名シンボルが存在するかチェックする。

### 1.4 未使用の変数・関数 (Unused Variables/Functions)
**推奨**: 宣言されたが一度も参照されていない変数、関数、インポート。
- **目的**: デッドコードを削除し、可読性を維持する。
- **挙動**: Warning (変数の場合は `_` プレフィックスで抑制可能にするのが一般的)
- **実装**: シンボルごとに `reference_count` を持ち、解析終了時に0であれば報告する。

## 2. 制御フローに関するチェック

### 2.1 到達不能コード (Unreachable Code)
**推奨**: `return`, `break`, `continue`, `panic` の後に続くコード、または常に `false` となる条件分岐のブロック。
- **目的**: ロジックエラーの発見。
- **挙動**: Warning
- **実装**: MIR構築後のCFG解析で、エントリーブロックから到達不可能なブロックを特定する。

### 2.2 全パスでの戻り値 (Missing Return)
**必須**: 非void関数において、値を返さない実行パスが存在する場合。
- **目的**: 不定な戻り値を防ぐ。
- **挙動**: Error
- **実装**: CFGの終端ノード解析。

### 2.3 無限ループの可能性 (Infinite Loop)
**推奨**: 脱出条件のない `while` や再帰呼び出し。
- **目的**: 意図しないハングアップを防ぐ。
- **挙動**: Warning (意図的な `loop {}` は除く)

## 3. 型安全性と演算に関するチェック

### 3.1 パターンマッチの網羅性 (Exhaustiveness Check)
**必須**: `match` 式で、列挙型(Enum)やUnionの全てのケースがカバーされていない場合。
- **目的**: ハンドリング漏れによる実行時エラーを防ぐ。
- **挙動**: Error
- **実装**: Enumの定義とマッチアームを比較し、欠けているパターンを検出する。

### 3.2 ナローイング変換の警告 (Narrowing Conversion)
**推奨**: 情報落ちが発生する可能性のある暗黙の型変換（例: `int64` -> `int32`、`float` -> `int`）。
- **目的**: オーバーフローや精度低下を防ぐ。
- **挙動**: Warning (明示的なキャストを要求)

### 3.3 Result戻り値の無視 (Unused Result)
**推奨**: エラーを含む可能性のある `Result<T, E>` 型を返す関数を呼び出し、その戻り値を使っていない場合。
- **目的**: エラーハンドリングの強制。
- **挙動**: Warning
- **実装**: 関数の属性（例: `[[nodiscard]]` 相当）または型ベースでチェック。

## 4. 実装戦略

これらのチェックは、コンパイルパイプラインの異なるフェーズで実装するのが効率的です。

| チェック項目 | 推奨フェーズ | 理由 |
|---|---|---|
| シャドーイング | Parser / Name Resolution | スコープ解決時に自然に判明するため |
| 未使用変数 | Type Checking | 参照解決が終わった段階で判定可能 |
| 初期化前使用 | MIR Analysis | 制御フロー(CFG)が必要なため |
| 到達不能コード | MIR Analysis | 最適化前のCFGで解析するのが正確 |
| 再代入なし(const推奨) | MIR Analysis | SSA形式あるいは代入グラフで容易に判定可能 |
| 網羅性チェック | Type Checking | 型情報が揃った時点で判定すべき論理エラーのため |

## 5. 推奨される次のステップ

まず、**ユーザー提案の「再代入のない変数の検出」**と、**「初期化前使用の検出」**の実装を優先することを推奨します。これらはMIR（中間表現）のデータフロー解析フェーズに追加することで実現可能です。
