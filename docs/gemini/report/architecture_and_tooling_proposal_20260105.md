# アーキテクチャ見直しとツール拡張提案

**日付**: 2026年1月5日
**作成者**: Gemini Agent
**対象**: Cm プロジェクト全体

## 1. さらなるリファクタリング・最適化が必要な領域

既存のレポートに含まれていない、プロジェクト全体の隠れた課題と改善案を報告します。

### 1.1 文字列処理の非効率性とメモリリーク
- **現状**: `src/codegen/llvm/native/runtime_format.c` の `cm_string_concat` や `cm_format_string` は、呼び出されるたびに `cm_alloc` (malloc) を行い、新しいバッファを作成します。特に `cm_format_string` はループ内で `realloc` を繰り返しており、計算量が $O(N^2)$ になる非効率な実装です。
- **問題**: 大量の文字列結合を行うとパフォーマンスが激しく低下します。また、生成された文字列を解放する仕組み（GCやデストラクタ）がないため、**文字列操作をするたびにメモリリーク**します。
- **改善案**:
    - **StringBuilderの実装**: 内部バッファを持ち、アロケーション回数を減らす構造体を導入する。
    - **Small String Optimization (SSO)**: 短い文字列はヒープを使わずスタックに格納する。

### 1.2 MIR構造と最適化の難易度
- **現状**: MIR（中間表現）は `Assign` 文で `MirPlace`（変数）に値を代入する形式をとっており、**SSA (Single Static Assignment) 形式ではありません**。変数は再代入可能です。
- **問題**: SSA形式でないため、データフロー解析（変数の値がどこで定義され、どこで使われるか）が複雑になり、CSE（共通部分式削除）やLICM（ループ不変量移動）などの高度な最適化の実装が困難です。
- **改善案**:
    - **mem2regパスの導入**: スタック上の変数を仮想レジスタ（SSA）に昇格させるパスを実装する。
    - または、MIR生成直後にSSA形式へ変換するフェーズを追加する。

### 1.3 モジュール解決の循環依存リスク
- **現状**: `src/module/resolver.cpp` はパース後にモジュールをキャッシュしますが、パース中のインポート解決（再帰呼び出し）に対するガードが不十分に見えます。
- **問題**: 循環参照（A imports B, B imports A）が発生した場合、無限再帰によるスタックオーバーフローや、未定義状態のモジュール参照が発生するリスクがあります。
- **改善案**: モジュールの状態に「Loading（読み込み中）」を追加し、読み込み中のモジュールへの再アクセスを検知して適切に処理（エラー化または遅延解決）する仕組みを導入する。

---

## 2. 静的解析・Lint/Formatに向けた拡張提案

`cm lint` や `cm fmt` を実現するための具体的なアーキテクチャ拡張案を提案します。

### 2.1 現状の課題：情報の欠落
現在の `Token` 構造体 (`src/frontend/lexer/token.hpp`) や AST は、**「トリビア (Trivia)」** と呼ばれる情報（コメント、空白、改行）を保持していません。
- **結果**: 現在のASTを使って `cm fmt` を作ると、**全てのコメントと空行が消滅します**。これはフォーマッタとして許容されません。

### 2.2 フォーマッタ（`cm fmt`）のアプローチ

**提案：CST (Concrete Syntax Tree) または Trivia付きTokenへの移行**

最も現実的で拡張性の高いアプローチは **"Trivia付きToken"** 方式です。

1.  **Lexerの改修**:
    - `Token` 構造体に `std::vector<Trivia> leading_trivia` と `trailing_trivia` を追加。
    - `Trivia` 構造体は `enum Kind { Space, Newline, Comment }` とその内容を持つ。
    - Lexerはコメントや空白をスキップせず、直後のトークンの `leading_trivia` として保存する。

2.  **Parser/ASTの改修**:
    - ASTノードはトークン情報を保持しているため、ASTをトラバースしながらトークンとそのトリビアを出力し直すことで、元のソースコードを再現（ラウンドトリップ）可能にする。
    - フォーマッタは、ASTの構造に基づいて「あるべき空白」を計算し、トークン間のトリビアを調整して出力する。

### 2.3 リンター（`cm lint`）とエラー耐性

**提案：Error Tolerant Parsing (エラー許容パーサ)**

リンターは、書きかけのコードや文法エラーがあるコードに対しても診断を行う必要があります。現在の `Parser::has_errors()` で即停止する挙動は不向きです。

1.  **パニックモードリカバリの強化**:
    - エラー発生時、単にエラーを出力するだけでなく、**「Error Node」** をASTに挿入してパースを続行する。
    - 例: `let x = ;` (式がない) -> `LetStmt(x, ErrorExpr)` としてASTを構築。

2.  **TypeCheckerの「Unknown/Error型」伝播**:
    - `ErrorExpr` の型は `ErrorType` とし、これを含む計算の結果もすべて `ErrorType` とする（カスケードエラーの抑制）。
    - これにより、文法エラー箇所以外の正常なコードに対して静的解析（未使用変数の検出など）を続行可能にする。

---

## 3. 推奨実装ロードマップ（ツール拡張）

1.  **Phase 1: TokenへのTrivia追加**
    - `Token` 構造体の拡張とLexerの改修。これが全てのツールの基礎となります。
2.  **Phase 2: フォーマッタのプロトタイプ**
    - ASTからコードを再生成するプリンタを作成し、コメントが保持されることを確認。
3.  **Phase 3: パーサのエラーリカバリ強化**
    - エラーノードの導入と、パース続行ロジックの実装。
4.  **Phase 4: リンターの実装**
    - AST/MIRを巡回して推奨ルール（`static_analysis_proposal.md` 参照）をチェックするパスの実装。

このアプローチにより、Cm言語は現代的な開発者体験（DX）を提供できる言語へと進化します。
