# 非協調的マルチタスクとAsync/Await導入に向けたアルゴリズムと設計

## 概要
本レポートでは、Cm言語においてガベージコレクション（GC）を使用せず、RAII（Resource Acquisition Is Initialization）ベースのリソース管理を維持しながら、**将来的な `async/await`（Future型）のサポート** と **非協調的（プリエンプティブ）マルチタスク** の導入を実現するためのアーキテクチャとアルゴリズムを提案します。

## 1. 概念の整理とCmへの適用

### 1.1 "非協調的" と "Async/Await" の共存
通常、`async/await` は「協調的マルチタスク（Cooperative Multitasking）」とセットで語られます。タスクは `await` ポイントでのみ制御を放棄するからです。
「非協調的（プリエンプティブ）」な挙動を `async` タスクに導入する場合、以下の2つのアプローチが考えられます。

1.  **純粋なOSスレッド（1:1モデル）**:
    *   各タスクをOSスレッドにマッピングする。OSがプリエンプションを行う。
    *   **メリット**: 実装が容易。RAIIと完全に互換。C++の `std::thread` に近い。
    *   **デメリット**: スレッド生成コストが高く、数万単位のタスクは扱えない。`async/await` の軽量さという利点が消える。

2.  **ユーザースペース・スケジューラ（M:Nモデル） + 強制プリエンプション**:
    *   Go言語（Goroutine）や Erlang、RustのTokio（特定設定下）のアプローチ。
    *   多数のタスク（M）を少数のOSスレッド（N）上で実行する。
    *   **プリエンプションの実現**:
        *   コンパイラが関数のプロローグやループのバックエッジに「チェックポイント」を挿入し、実行時間が長引いている場合に強制的に `yield`（中断）させる。
    *   **Cmへの推奨**: `Future`型を目指すなら、ベースは **Stackless Coroutine（Rust型）** としつつ、スケジューラ側で **Work-Stealing** と **Time-Slicing** を組み合わせるのが現実的です。

## 2. 推奨アルゴリズムとデータ構造

### 2.1 スケジューリング: Work-Stealing Algorithm
M:Nモデルにおいて、CPUコア（OSスレッド）間の負荷分散を行う標準的なアルゴリズムです。

*   **構造**: 各OSスレッド（Worker）は、自身の「ローカル・デック（Deque）」を持つ。
*   **動作**:
    1.  Workerは自分のDequeの先頭（Top）からタスクを取り出して実行する（LIFO: キャッシュ局所性向上）。
    2.  自分のDequeが空の場合、他のWorkerのDequeの末尾（Bottom）からタスクを「盗む（Steal）」（FIFO）。
    3.  グローバルなRun Queueも用意し、定期的にそこからもタスクを取得する（飢餓防止）。

### 2.2 コンテキストスイッチとFuture
RAIIとGCレスでこれを実現するには、Rustのような **Polled Future** モデルが適しています。

*   **State Machine変換**:
    *   `async fn` はコンパイラによって「状態マシン（Enum）」に変換されます。
    *   スタックを丸ごと保存する（Stackful）のではなく、`await` 地点ごとのローカル変数を構造体のフィールドとして保持します。
    *   これにより、メモリ割り当てを最小限（ヒープまたはスタック）に抑え、RAIIによるデストラクタ呼び出しも状態マシンの破棄として静的に管理できます。

### 2.3 プリエンプションの実装（非協調的動作）
`async` タスクが無限ループなどでCPUを独占しないようにするための技術です。

*   **予算ベースの実行 (Budgeting)**:
    *   各タスク（Future）に「予算（Budget）」を割り当てる。
    *   `poll` 呼び出しや、コンパイラが挿入したチェックポイントごとに予算を減らす。
    *   予算が尽きたら、タスクは強制的に `Pending` を返し、Run Queueの末尾に回される。
*   **コンパイラによるYield挿入**:
    *   長いループや深い再帰の箇所に、自動的に `runtime::check_preemption()` のようなコードを挿入する。

## 3. RAIIとの統合と同期

GCがないため、非同期タスク間でデータを共有する場合のメモリ管理が重要です。

*   **所有権の移動**: タスク生成時（`spawn`）に、必要なデータの所有権をタスク内に移動（Move）させる。
*   **Arc (Atomic Reference Counting)**: 共有が必要なデータは、スレッドセーフな参照カウントポインタで管理する。RAIIにより、最後のタスクが終了した時点でリソースが解放される。
*   **Async Mutex / RwLock**:
    *   OSのブロッキングMutex（`pthread_mutex`など）を使うと、Workerスレッド全体が停止してしまう。
    *   **非同期Mutex**の実装が必要。ロックが取れない場合、タスクは `waiting` 状態となり、ロック解放時にスケジューラによって再び起こされる（Waker通知）。

## 4. ロードマップ案

1.  **Phase 1: Enum/Pattern Matchingの強化**（後述のレポート参照）
    *   `Optional`, `Result`, および `Future` の状態マシン表現に必須。
2.  **Phase 2: Future トレイトの定義**
    *   `poll(self: *Self, context: *Context) -> Poll<T>` のようなインターフェース。
3.  **Phase 3: ステートマシン変換の実装**
    *   コンパイラバックエンドでの `async/await` の書き換え。
4.  **Phase 4: シンプルなランタイムの実装**
    *   まずはシングルスレッドのExecutor。
    *   次にWork-Stealing Executorの実装。

このアーキテクチャにより、CmはC++/Rustのようなゼロオーバーヘッド抽象化を維持しつつ、Goのような並行処理性能を目指すことが可能になります。
