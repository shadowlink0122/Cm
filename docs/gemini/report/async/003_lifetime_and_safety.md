# 非同期処理におけるライフタイムと安全性

## 1. 課題: 非同期スタックフレームの寿命

通常、スタック上の変数の寿命はスコープの終わりまでですが、`async` 関数ではサスペンド（中断）により、スタックフレーム（ステートマシン）がヒープに移動したり、長時間生存したりします。

**リスク**:
1.  **Use-after-free**: `async` タスクがローカル変数の参照を外部に渡し、そのタスクが破棄された後に参照アクセスされる。
2.  **自己参照の無効化**: ステートマシンが移動（Move）することで、内部ポインタが無効になる（`pinned` で解決済み）。

## 2. 借用チェッカーの拡張

v0.11.0で導入された借用チェッカーを、`async/await` に対応させます。

### 2.1 `await` ポイントを跨ぐ借用

```cm
async void dangerous() {
    int x = 10;
    int* p = &x;
    
    other_task().await; // ここでサスペンド
    
    println("{}", *p);
}
```

このコードは安全でしょうか？
*   **Yes**: `p` と `x` は同じステートマシン内に保存されます。ステートマシン自体が `pinned` であれば、`x` のアドレスは変わりません。
*   **条件**: コンパイラは「`p` が `x` を借用している」ことを追跡し、`x` が `p` より先にドロップされないこと、そして `x` が移動しないことを保証する必要があります。

### 2.2 外部変数の借用

```cm
void main() {
    int x = 10;
    
    // asyncブロックが x を借用
    let future = async {
        println("{}", x);
    };
    
    // future は x のライフタイムに縛られる
    block_on(future);
}
```

`future` の型は `impl Future + 'a` となり、`'a` は `x` のライフタイムです。
`block_on` が終了するまで `x` が有効である必要があります。

**制約**: `spawn`（デタッチして実行）する場合、引数のFutureは `'static`（参照を含まない、または静的参照のみ）でなければなりません。
これはRustと同じ安全な制約ですが、Cmではエラーメッセージを分かりやすくします。
「`spawn` するタスクは、ローカル変数を参照できません。値をコピー（Move）してください」と提案します。

## 3. ダングリングポインタの防止

プリエンプティブな中断が入る場合、ロックの解除漏れなどが懸念されます。

### 3.1 RAIIガードの活用
非同期Mutexのロック取得は、`LockGuard` オブジェクトを返します。
タスクが強制中断（キャンセル/パニック）された場合でも、ステートマシンのデストラクタが走り、`LockGuard` のデストラクタでロックが解放されることを保証します。

```cm
{
    let guard = mutex.lock().await;
    // ... ここで強制終了しても guard.~LockGuard() が呼ばれる
}
```

### 3.2 構造化並行性 (Structured Concurrency)

可能な限り `spawn`（Fire-and-forget）ではなく、`scope` ベースの並行処理を推奨します。

```cm
async_scope {
    // このブロックを抜けるとき、全てのサブタスクの完了を待つ（またはキャンセルする）
    spawn(task1);
    spawn(task2);
}
```

これにより、親タスクのローカル変数を子タスクが安全に参照できる期間を明確にします。

## 4. 最適な非同期アルゴリズムの結論

1.  **実行モデル**:
    *   ベース: **Stackless Coroutine** (メモリ効率)
    *   スケジューリング: **Work-Stealing Executor** (CPU効率)
    *   プリエンプション: **Compiler-inserted Checkpoints** (ループ/関数境界での強制Yield)

2.  **メモリ管理**:
    *   **Pinned Attribute**: 言語レベルでの移動禁止。
    *   **No-GC / RAII**: デストラクタによる確実なリソース解放。

3.  **安全性**:
    *   **Borrow Checker**: `await` を跨ぐ借用と、タスク間の参照共有を静的に検証。
    *   **Structured Concurrency**: ライフタイムの管理を容易にする構文サポート。

この組み合わせにより、Cm言語は「安全かつ高速で、予測可能なリアルタイム性を持つ」独自の非同期ランタイムを提供できます。
