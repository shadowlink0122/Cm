[English](001_architecture_and_primitives.en.html)

# JSコンパイラ詳細設計: 001 アーキテクチャと基本型

## 1. コンパイルパイプライン

### 1.1 入力ソース
JSバックエンドは、**MIR (Mid-level Intermediate Representation)** を入力として受け取る設計とします。
*   **理由**: 型情報が解決済みであり、ジェネリクスが具体化（Monomorphization）された後の状態であるため、JSのクラス生成や関数生成が容易であるため。

### 1.2 処理フロー
1.  **MIR Analysis**: MIRグラフを走査し、依存関係（使用されている構造体、関数）を収集。
2.  **Code Generation**:
    *   **Prolog**: ランタイムヘルパー関数の出力（必要な場合）。
    *   **Type Defs**: 構造体・クラス定義の出力。
    *   **Functions**: 関数の出力。
    *   **Main**: エントリーポイントの呼び出し。
3.  **Output**: 単一の `.js` ファイル、またはモジュール単位の `.mjs` ファイルを出力。

## 2. データ型マッピング

Cmの型をJavaScriptのプリミティブおよびオブジェクトにどうマッピングするかを定義します。

### 2.1 プリミティブ型

| Cm Type | JS Type | 備考 |
| :--- | :--- | :--- |
| `bool` | `Boolean` | そのままマッピング |
| `char` | `String` | 長さ1の文字列 |
| `string` | `String` | JSの文字列（不変） |
| `i32`, `u32` | `Number` | JSのNumberはdoubleだが、ビット演算時は32bit整数として振る舞うため許容 |
| `i64`, `u64` | `BigInt` | 64bit精度を維持するために必須（`100n` 表記） |
| `f32`, `f64` | `Number` | そのままマッピング |
| `isize`, `usize` | `Number` | JS環境ではインデックスは `Number` で十分 |
| `void` | `undefined` | 戻り値がない場合など |

### 2.2 ポインタと参照
JSにはポインタがありませんが、Cmはポインタ操作を許可します。
*   **基本方針**: 参照渡し可能なオブジェクト（クラスインスタンス）はそのまま渡す。
*   **プリミティブのポインタ**: `Box<T>` のようなラッパーオブジェクトを一時的に生成する必要がありますが、パフォーマンスへの影響を考慮し、可能な限り値渡しとして扱います。
    *   *制限事項*: JSバックエンドでは、プリミティブ型（`int`など）へのポインタ経由の書き換えは、特定のラッパー（`Ref<T> { value: T }`）を通さない限りサポートしない方針とします。

## 3. ランタイムライブラリ (Shim)

コンパイル出力コードの先頭、または別モジュールとして以下の機能を提供します。

*   **`cm_panic(msg)`**: 例外 `throw new Error(msg)` を投げる。
*   **`cm_assert(cond)`**: 条件チェック。
*   **数値変換ヘルパー**: `BigInt` と `Number` の相互変換など。

## 4. プロジェクト構成案

`src/codegen/js/` ディレクトリを作成し、以下のモジュール構成を推奨します。

*   `js_backend.hpp/cpp`: エントリーポイント。
*   `js_ast.hpp`: JSのAST（出力用の中間データ構造）。文字列結合で直接出力するより、一度JS ASTを経由した方がソースマップ生成や最適化に有利。
*   `js_printer.cpp`: JS ASTをコード文字列に変換。