// std.macros - 標準マクロモジュール
module std.macros;

// ============================================================
// アサーションマクロ
// ============================================================

@[macro]
export fn assert!(condition: expr, message: string = "") {
    if (!$condition) {
        let msg = if ($message.is_empty()) {
            "Assertion failed: " + stringify!($condition)
        } else {
            "Assertion failed: " + $message
        };
        panic!(msg);
    }
}

@[macro]
export fn debug_assert!(condition: expr, message: string = "") {
    @[cfg(debug)]
    {
        assert!($condition, $message);
    }
}

// ============================================================
// パニックマクロ
// ============================================================

@[macro]
export fn panic!(message: string = "explicit panic") {
    import std.io.{eprintln};
    eprintln("PANIC: " + $message);

    // スタックトレースを出力
    @[cfg(debug)]
    {
        print_stacktrace!();
    }

    // プログラムを異常終了
    @[extern("cm_abort")]
    fn abort() -> !;
    abort();
}

@[macro]
export fn unreachable!(message: string = "entered unreachable code") {
    panic!("internal error: " + $message);
}

@[macro]
export fn unimplemented!(message: string = "not implemented") {
    panic!("not implemented: " + $message);
}

@[macro]
export fn todo!(message: string = "not yet implemented") {
    panic!("not yet implemented: " + $message);
}

// ============================================================
// デバッグマクロ
// ============================================================

@[macro]
export fn dbg!(expr: expr) -> typeof($expr) {
    @[cfg(debug)]
    {
        import std.io.{eprintln};
        let value = $expr;
        eprintln("[" + file!() + ":" + line!() + "] " + stringify!($expr) + " = " + debug_string!(value));
        value
    }
    @[cfg(not(debug))]
    {
        $expr
    }
}

@[macro]
export fn println!(args: expr...) {
    import std.io.{print, println};

    if ($args.len() == 0) {
        println("");
    } else if ($args.len() == 1) {
        println(to_string!($args[0]));
    } else {
        // フォーマット文字列として処理
        let formatted = format!($args[0], $args[1..]);
        println(formatted);
    }
}

@[macro]
export fn print!(args: expr...) {
    import std.io.{print};

    if ($args.len() == 1) {
        print(to_string!($args[0]));
    } else {
        // フォーマット文字列として処理
        let formatted = format!($args[0], $args[1..]);
        print(formatted);
    }
}

// ============================================================
// 文字列化マクロ
// ============================================================

@[macro]
export fn stringify!(expr: expr) -> string {
    // コンパイル時に式を文字列に変換
    return compiler_stringify($expr);
}

@[macro]
export fn to_string!(value: expr) -> string {
    // 値を文字列に変換（Display トレイトを使用）
    return $value.to_string();
}

@[macro]
export fn debug_string!(value: expr) -> string {
    // 値をデバッグ文字列に変換（Debug トレイトを使用）
    return format!("{:?}", $value);
}

// ============================================================
// コンパイル時情報マクロ
// ============================================================

@[macro]
export fn file!() -> string {
    return compiler_file();
}

@[macro]
export fn line!() -> uint {
    return compiler_line();
}

@[macro]
export fn column!() -> uint {
    return compiler_column();
}

@[macro]
export fn module_path!() -> string {
    return compiler_module_path();
}

@[macro]
export fn function_name!() -> string {
    return compiler_function_name();
}

// ============================================================
// 配列・ベクタ初期化マクロ
// ============================================================

@[macro]
export fn vec![elements: expr...] -> Vec<auto> {
    import std.collections.Vec;

    let mut v = Vec::new();
    for elem in $elements {
        v.push($elem);
    }
    return v;
}

@[macro]
export fn array![element: expr; count: expr] -> array<auto, $count> {
    let mut arr: array<typeof($element), $count>;
    for i in 0..$count {
        arr[i] = $element;
    }
    return arr;
}

// ============================================================
// 条件コンパイルマクロ
// ============================================================

@[macro]
export fn cfg!(condition: meta) -> bool {
    return compiler_cfg($condition);
}

@[macro]
export fn cfg_if! {
    {
        @[cfg($condition:meta)]
        $then_branch:block
    } $(else if {
        @[cfg($else_condition:meta)]
        $else_if_branch:block
    })* $(else {
        $else_branch:block
    })?
} {
    // 条件に応じてブランチを選択
    if (cfg!($condition)) {
        $then_branch
    } $(else if (cfg!($else_condition)) {
        $else_if_branch
    })* $(else {
        $else_branch
    })?
}

// ============================================================
// フォーマットマクロ
// ============================================================

@[macro]
export fn format!(fmt: string, args: expr...) -> string {
    // フォーマット文字列を解析して置換
    return compiler_format($fmt, $args);
}

// ============================================================
// マッチマクロ（パターンマッチングの拡張）
// ============================================================

@[macro]
export fn matches!(expr: expr, pattern: pat) -> bool {
    return match $expr {
        $pattern => true,
        _ => false,
    };
}