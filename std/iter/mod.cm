// std::iter - イテレータモジュール
module std.iter;

// ============================================================
// イテレータインターフェース
// ============================================================

/// 基本的なイテレータインターフェース（int型専用）
/// 注: ジェネリックインターフェースは現在未サポートのため型別に定義
export interface IntIterator {
    bool has_next();
    int next();
    int peek();
}

/// イテラブルインターフェース（int型専用）
export interface IntIterable {
    IntIterator iter();
}

// ============================================================
// 配列イテレータ
// ============================================================

/// ポインタベースの配列イテレータ（int型専用）
export struct IntArrayIterator {
    int* current;    // 現在の要素へのポインタ
    int* end;        // 終端へのポインタ（含まない）
}

impl IntArrayIterator {
    // コンストラクタ
    self(int* data, int size) {
        self.current = data;
        self.end = data + size;
    }
    
    // 次の要素があるか確認
    bool has_next() {
        return self.current < self.end;
    }
    
    // 次の要素を取得し、ポインタを進める
    int next() {
        int value = *self.current;
        self.current = self.current + 1;
        return value;
    }
    
    // 次の要素を取得（ポインタは進めない）
    int peek() {
        return *self.current;
    }
    
    // 残りの要素数を取得
    int remaining() {
        int count = 0;
        int* p = self.current;
        while (p < self.end) {
            count = count + 1;
            p = p + 1;
        }
        return count;
    }
}

// ============================================================
// Range構造体（範囲イテレータ）
// ============================================================

/// 整数範囲を表す構造体
export struct Range {
    int start;
    int end;
    int step;
}

/// 範囲を作成（step=1）
export Range range(int end) {
    Range r;
    r.start = 0;
    r.end = end;
    r.step = 1;
    return r;
}

/// 範囲を作成（start, end, step=1）
export Range range(int start, int end) {
    Range r;
    r.start = start;
    r.end = end;
    r.step = 1;
    return r;
}

/// 範囲を作成（start, end, step）
export Range range(int start, int end, int step) {
    Range r;
    r.start = start;
    r.end = end;
    r.step = step;
    return r;
}

/// 範囲の長さを取得
export int len(Range r) {
    if (r.step == 0) {
        return 0;
    }
    if (r.step > 0) {
        if (r.end <= r.start) {
            return 0;
        }
        return (r.end - r.start + r.step - 1) / r.step;
    } else {
        // step < 0: 降順
        if (r.start <= r.end) {
            return 0;
        }
        return (r.start - r.end - r.step - 1) / (-r.step);
    }
}

/// 範囲が空かどうか
export bool is_empty(Range r) {
    return len(r) == 0;
}

/// 範囲のn番目の要素を取得
export int at(Range r, int n) {
    return r.start + n * r.step;
}

// ============================================================
// RangeIterator（Range用イテレータ）
// ============================================================

/// Range用のイテレータ
export struct RangeIterator {
    int current;
    int end;
    int step;
}

impl RangeIterator {
    // Rangeからイテレータを作成
    self(Range r) {
        self.current = r.start;
        self.end = r.end;
        self.step = r.step;
    }
    
    // 次の要素があるか確認
    bool has_next() {
        if (self.step > 0) {
            return self.current < self.end;
        } else {
            return self.current > self.end;
        }
    }
    
    // 次の要素を取得
    int next() {
        int value = self.current;
        self.current = self.current + self.step;
        return value;
    }
    
    // 次の要素を確認（進めない）
    int peek() {
        return self.current;
    }
}

// ============================================================
// ユーティリティ関数
// ============================================================

/// 2つの値をスワップ
export <T> void swap(T* a, T* b) {
    T tmp = *a;
    *a = *b;
    *b = tmp;
}

