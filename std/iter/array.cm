// std::iter::array - 配列イテレータ
//
// 配列に対するポインタベースのイテレータ実装。
// 効率的なメモリアクセスでゼロコスト抽象化を実現します。

module std.iter.array;

// ============================================================
// IntArrayIterator - int配列用イテレータ
// ============================================================

/// ポインタベースの配列イテレータ（int型専用）
/// ポインタ演算による効率的なイテレーションを提供
export struct IntArrayIterator {
    int* current;  // 現在の要素へのポインタ
    int* end;      // 終端へのポインタ（含まない）
}

impl IntArrayIterator {
    /// コンストラクタ
    /// @param data 配列の先頭ポインタ
    /// @param size 配列のサイズ
    self(int* data, int size) {
        self.current = data;
        self.end = data + size;
    }

    /// 次の要素があるか確認
    bool has_next() {
        return self.current < self.end;
    }

    /// 次の要素を取得し、ポインタを進める
    int next() {
        int value = self.current;
        self.current = self.current + 1;
        return value;
    }

    /// 次の要素を取得（ポインタは進めない）
    int peek() {
        return self.current;
    }

    /// 残りの要素数を取得
    int remaining() {
        int count = 0;
        int* p = self.current;
        while (p < self.end) {
            count = count + 1;
            p = p + 1;
        }
        return count;
    }

    /// イテレータをリセット（先頭に戻る）
    // void reset(int* data, int size) {
    //     self.current = data;
    //     self.end = data + size;
    // }
}

// ============================================================
// 将来実装: ジェネリック配列イテレータ
// ============================================================

// TODO: ジェネリクス + impl内ポインタフィールド問題解決後
// export struct ArrayIterator<T> {
//     T* current;
//     T* end;
// }
//
// impl<T> ArrayIterator<T> for Iterator<T> {
//     bool has_next() { return self.current < self.end; }
//     T next() {
//         T value = self.current;
//         self.current = self.current + 1;
//         return value;
//     }
//     T peek() { return self.current; }
// }
