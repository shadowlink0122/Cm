// std::io::file::file - ファイルI/O
// v0.13.0: Reader, Writer, Seek interface実装
module std.io.file.file;

import std.io.error::{IoResult, IoError, IoErrorKind};

// ============================================================
// libc syscall
// ============================================================

use libc {
    long read(int fd, void* buf, long count);
    long write(int fd, void* buf, long count);
    int open(string path, int flags, int mode);
    int close(int fd);
    long lseek(int fd, long offset, int whence);
    int fsync(int fd);
    void* malloc(long size);
    void free(void* ptr);
}

// ============================================================
// Open フラグ定数 (POSIX)
// ============================================================

// macOS/Linux共通フラグ
const int O_RDONLY   = 0;        // 読み取り専用
const int O_WRONLY   = 1;        // 書き込み専用
const int O_RDWR     = 2;        // 読み書き
const int O_CREAT    = 0x0200;   // ファイル作成 (macOS: 0x200, Linux: 0x40)
const int O_TRUNC    = 0x0400;   // 切り詰め (macOS: 0x400, Linux: 0x200)
const int O_APPEND   = 0x0008;   // 追記 (macOS: 0x8, Linux: 0x400)

// Seekフラグ
const int SEEK_SET = 0;  // ファイル先頭から
const int SEEK_CUR = 1;  // 現在位置から
const int SEEK_END = 2;  // ファイル末尾から

// デフォルトパーミッション
const int DEFAULT_MODE = 0644;  // rw-r--r--

// ============================================================
// File構造体
// ============================================================

/// ファイルハンドル
export struct File {
    int _fd;
    bool _is_open;
}

impl File {
    // ========================================
    // 静的メソッド - ファイルオープン
    // ========================================

    /// 読み取り専用で開く
    IoResult<File> open(string path) {
        int fd = open(path, O_RDONLY, 0);
        if (fd < 0) {
            return IoResult.Err(IoError.not_found(path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    /// 書き込み用に作成（既存は上書き）
    IoResult<File> create(string path) {
        int flags = O_WRONLY | O_CREAT | O_TRUNC;
        int fd = open(path, flags, DEFAULT_MODE);
        if (fd < 0) {
            return IoResult.Err(IoError.other("failed to create file: " + path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    /// 追記用に開く
    IoResult<File> open_append(string path) {
        int flags = O_WRONLY | O_CREAT | O_APPEND;
        int fd = open(path, flags, DEFAULT_MODE);
        if (fd < 0) {
            return IoResult.Err(IoError.other("failed to open for append: " + path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    // ========================================
    // Reader実装
    // ========================================

    /// バッファにデータを読み込む
    IoResult<int> read(utiny[] buf) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        if (buf.len() == 0) {
            return IoResult.Ok(0);
        }

        long n = read(this._fd, &buf[0] as void*, buf.len() as long);
        if (n < 0) {
            return IoResult.Err(IoError.other("read error"));
        }
        return IoResult.Ok(n as int);
    }

    // ========================================
    // Writer実装
    // ========================================

    /// バッファからデータを書き込む
    IoResult<int> write(utiny[] buf) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        if (buf.len() == 0) {
            return IoResult.Ok(0);
        }

        long n = write(this._fd, &buf[0] as void*, buf.len() as long);
        if (n < 0) {
            return IoResult.Err(IoError.other("write error"));
        }
        return IoResult.Ok(n as int);
    }

    /// 文字列を書き込む
    IoResult<int> write_str(string s) {
        // 簡易実装：文字列長を取得して書き込み
        // 将来的にはstring.as_bytes()を使用
        utiny* ptr = s as utiny*;
        long len = s.len() as long;
        long n = write(this._fd, ptr as void*, len);
        if (n < 0) {
            return IoResult.Err(IoError.other("write error"));
        }
        return IoResult.Ok(n as int);
    }

    /// フラッシュ
    IoResult<int> flush() {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        int ret = fsync(this._fd);
        if (ret < 0) {
            return IoResult.Err(IoError.other("fsync error"));
        }
        return IoResult.Ok(0);
    }

    // ========================================
    // Seek実装
    // ========================================

    /// ファイル先頭にシーク
    IoResult<long> seek_start(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_SET);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// 現在位置からシーク
    IoResult<long> seek_current(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_CUR);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// ファイル末尾からシーク
    IoResult<long> seek_end(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_END);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// 現在位置を取得
    IoResult<long> position() {
        return this.seek_current(0);
    }

    // ========================================
    // クローズ
    // ========================================

    /// ファイルを閉じる
    IoResult<int> close() {
        if (!this._is_open) {
            return IoResult.Ok(0);  // 既に閉じている
        }

        int ret = close(this._fd);
        this._is_open = false;
        this._fd = -1;

        if (ret < 0) {
            return IoResult.Err(IoError.other("close error"));
        }
        return IoResult.Ok(0);
    }

    /// ファイルが開いているか
    bool is_open() {
        return this._is_open;
    }
}

// ============================================================
// 便利関数
// ============================================================

/// ファイル全体を文字列として読み込み
export IoResult<string> read_to_string(string path) {
    // ファイルを開く
    int fd = open(path, O_RDONLY, 0);
    if (fd < 0) {
        return IoResult.Err(IoError.not_found(path));
    }
    
    // ファイルサイズを取得
    long size = lseek(fd, 0, SEEK_END);
    if (size < 0) {
        close(fd);
        return IoResult.Err(IoError.other("failed to get file size"));
    }
    lseek(fd, 0, SEEK_SET);
    
    // バッファを確保
    void* buf = malloc(size + 1);
    if (buf == 0 as void*) {
        close(fd);
        return IoResult.Err(IoError.other("out of memory"));
    }
    
    // ファイルを読み込み
    long bytes_read = read(fd, buf, size);
    close(fd);
    
    if (bytes_read < 0) {
        free(buf);
        return IoResult.Err(IoError.other("read error"));
    }
    
    // null終端
    char* str = buf as char*;
    str[bytes_read as int] = 0 as char;
    
    return IoResult.Ok(str as string);
}

/// 文字列をファイルに書き込み
export IoResult<int> write_string(string path, string content) {
    // ファイルを作成
    int flags = O_WRONLY | O_CREAT | O_TRUNC;
    int fd = open(path, flags, DEFAULT_MODE);
    if (fd < 0) {
        return IoResult.Err(IoError.other("failed to create file: " + path));
    }
    
    // 書き込み
    long len = content.len() as long;
    long bytes_written = write(fd, content as void*, len);
    close(fd);
    
    if (bytes_written < 0) {
        return IoResult.Err(IoError.other("write error"));
    }
    
    return IoResult.Ok(bytes_written as int);
}

