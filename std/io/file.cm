// std::io::file - ファイルI/O
// v0.13.0: Reader, Writer, Seek interface実装
module std.io.file;

import std.io.error::{IoResult, IoError, IoErrorKind};

// ============================================================
// libc関数宣言（LLVM経由で直接呼び出し）
// ============================================================

extern "C" long read(int fd, utiny* buf, long count);
extern "C" long write(int fd, utiny* buf, long count);
extern "C" int open(string path, int flags, int mode);
extern "C" int close(int fd);
extern "C" long lseek(int fd, long offset, int whence);
extern "C" int fsync(int fd);

// ============================================================
// Open フラグ定数 (POSIX)
// ============================================================

// macOS/Linux共通フラグ
const int O_RDONLY   = 0;        // 読み取り専用
const int O_WRONLY   = 1;        // 書き込み専用
const int O_RDWR     = 2;        // 読み書き
const int O_CREAT    = 0x0200;   // ファイル作成 (macOS: 0x200, Linux: 0x40)
const int O_TRUNC    = 0x0400;   // 切り詰め (macOS: 0x400, Linux: 0x200)
const int O_APPEND   = 0x0008;   // 追記 (macOS: 0x8, Linux: 0x400)

// Seekフラグ
const int SEEK_SET = 0;  // ファイル先頭から
const int SEEK_CUR = 1;  // 現在位置から
const int SEEK_END = 2;  // ファイル末尾から

// デフォルトパーミッション
const int DEFAULT_MODE = 0644;  // rw-r--r--

// ============================================================
// File構造体
// ============================================================

/// ファイルハンドル
export struct File {
    int _fd;
    bool _is_open;
}

impl File {
    // ========================================
    // 静的メソッド - ファイルオープン
    // ========================================

    /// 読み取り専用で開く
    IoResult<File> open(string path) {
        int fd = open(path, O_RDONLY, 0);
        if (fd < 0) {
            return IoResult.Err(IoError.not_found(path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    /// 書き込み用に作成（既存は上書き）
    IoResult<File> create(string path) {
        int flags = O_WRONLY | O_CREAT | O_TRUNC;
        int fd = open(path, flags, DEFAULT_MODE);
        if (fd < 0) {
            return IoResult.Err(IoError.other("failed to create file: " + path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    /// 追記用に開く
    IoResult<File> open_append(string path) {
        int flags = O_WRONLY | O_CREAT | O_APPEND;
        int fd = open(path, flags, DEFAULT_MODE);
        if (fd < 0) {
            return IoResult.Err(IoError.other("failed to open for append: " + path));
        }

        File f;
        f._fd = fd;
        f._is_open = true;
        return IoResult.Ok(f);
    }

    // ========================================
    // Reader実装
    // ========================================

    /// バッファにデータを読み込む
    IoResult<int> read(utiny[] buf) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        if (buf.len() == 0) {
            return IoResult.Ok(0);
        }

        long n = read(this._fd, buf.ptr(), buf.len() as long);
        if (n < 0) {
            return IoResult.Err(IoError.other("read error"));
        }
        return IoResult.Ok(n as int);
    }

    // ========================================
    // Writer実装
    // ========================================

    /// バッファからデータを書き込む
    IoResult<int> write(utiny[] buf) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        if (buf.len() == 0) {
            return IoResult.Ok(0);
        }

        long n = write(this._fd, buf.ptr(), buf.len() as long);
        if (n < 0) {
            return IoResult.Err(IoError.other("write error"));
        }
        return IoResult.Ok(n as int);
    }

    /// 文字列を書き込む
    IoResult<int> write_str(string s) {
        // 簡易実装：文字列長を取得して書き込み
        // 将来的にはstring.as_bytes()を使用
        utiny* ptr = s as utiny*;
        long len = s.len() as long;
        long n = write(this._fd, ptr, len);
        if (n < 0) {
            return IoResult.Err(IoError.other("write error"));
        }
        return IoResult.Ok(n as int);
    }

    /// フラッシュ
    IoResult<int> flush() {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        int ret = fsync(this._fd);
        if (ret < 0) {
            return IoResult.Err(IoError.other("fsync error"));
        }
        return IoResult.Ok(0);
    }

    // ========================================
    // Seek実装
    // ========================================

    /// ファイル先頭にシーク
    IoResult<long> seek_start(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_SET);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// 現在位置からシーク
    IoResult<long> seek_current(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_CUR);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// ファイル末尾からシーク
    IoResult<long> seek_end(long offset) {
        if (!this._is_open) {
            return IoResult.Err(IoError.other("file not open"));
        }
        long pos = lseek(this._fd, offset, SEEK_END);
        if (pos < 0) {
            return IoResult.Err(IoError.other("seek error"));
        }
        return IoResult.Ok(pos);
    }

    /// 現在位置を取得
    IoResult<long> position() {
        return this.seek_current(0);
    }

    // ========================================
    // クローズ
    // ========================================

    /// ファイルを閉じる
    IoResult<int> close() {
        if (!this._is_open) {
            return IoResult.Ok(0);  // 既に閉じている
        }

        int ret = close(this._fd);
        this._is_open = false;
        this._fd = -1;

        if (ret < 0) {
            return IoResult.Err(IoError.other("close error"));
        }
        return IoResult.Ok(0);
    }

    /// ファイルが開いているか
    bool is_open() {
        return this._is_open;
    }
}

// ============================================================
// 便利関数
// ============================================================

/// ファイル全体を文字列として読み込み
export IoResult<string> read_to_string(string path) {
    // 既存のランタイム関数を使用
    string content = cm_file_read_all(path);
    if (content.len() == 0) {
        // 空かエラーか判定できない（簡易実装）
    }
    return IoResult.Ok(content);
}

/// 文字列をファイルに書き込み
export IoResult<int> write_string(string path, string content) {
    bool ok = cm_file_write_all(path, content);
    if (!ok) {
        return IoResult.Err(IoError.other("write failed: " + path));
    }
    return IoResult.Ok(content.len() as int);
}

// 既存のランタイム関数
extern "C" string cm_file_read_all(string path);
extern "C" bool cm_file_write_all(string path, string content);
