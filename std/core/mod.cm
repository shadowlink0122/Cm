// std.core - コア機能モジュール（OS非依存）
module std.core;

// ============================================================
// 基本的な型エイリアス
// ============================================================

export type i8 = tiny;
export type i16 = short;
export type i32 = int;
export type i64 = long;

export type u8 = utiny;
export type u16 = ushort;
export type u32 = uint;
export type u64 = ulong;

export type f32 = float;
export type f64 = double;

export type usize = uint;  // プラットフォーム依存（32/64bit）
export type isize = int;   // プラットフォーム依存（32/64bit）

// ============================================================
// Option型（Nullable）
// ============================================================

export enum class Option<T> {
    Some(T),
    None
};

export template<typename T>
bool is_some(const Option<T>& opt) {
    return opt == Option<T>::Some;
}

export template<typename T>
bool is_none(const Option<T>& opt) {
    return opt == Option<T>::None;
}

export template<typename T>
T unwrap(Option<T> opt) {
    if (opt == Option<T>::None) {
        panic("Called unwrap on None value");
    }
    return opt.value;
}

export template<typename T>
T unwrap_or(Option<T> opt, T default_value) {
    if (opt == Option<T>::None) {
        return default_value;
    }
    return opt.value;
}

// ============================================================
// Result型（エラーハンドリング）
// ============================================================

export enum class Result<T, E> {
    Ok(T),
    Err(E)
};

export template<typename T, typename E>
bool is_ok(const Result<T, E>& res) {
    return res == Result<T, E>::Ok;
}

export template<typename T, typename E>
bool is_err(const Result<T, E>& res) {
    return res == Result<T, E>::Err;
}

export template<typename T, typename E>
T unwrap_result(Result<T, E> res) {
    if (res == Result<T, E>::Err) {
        panic("Called unwrap on Err value");
    }
    return res.value;
}

export template<typename T, typename E>
E unwrap_err(Result<T, E> res) {
    if (res == Result<T, E>::Ok) {
        panic("Called unwrap_err on Ok value");
    }
    return res.error;
}

// ============================================================
// 基本的なインターフェース
// ============================================================

export interface Clone {
    virtual Clone* clone() const = 0;
};

export interface Copy {
    // マーカーインターフェース（メソッドなし）
};

export interface Default {
    static Default* default_value();
};

export interface Debug {
    virtual string debug_str() const = 0;
};

export interface Display {
    virtual string to_string() const = 0;
};

export interface PartialEq {
    virtual bool eq(const PartialEq& other) const = 0;
    virtual bool ne(const PartialEq& other) const {
        return !eq(other);
    }
};

export interface Eq : PartialEq {
    // 反射律、対称律、推移律を満たす
};

// ============================================================
// 順序付け
// ============================================================

export enum class Ordering {
    Less,
    Equal,
    Greater
};

export interface PartialOrd : PartialEq {
    virtual Option<Ordering> partial_cmp(const PartialOrd& other) const = 0;

    virtual bool lt(const PartialOrd& other) const {
        Option<Ordering> result = partial_cmp(other);
        return is_some(result) && unwrap(result) == Ordering::Less;
    }

    virtual bool le(const PartialOrd& other) const {
        Option<Ordering> result = partial_cmp(other);
        return is_some(result) && unwrap(result) != Ordering::Greater;
    }

    virtual bool gt(const PartialOrd& other) const {
        Option<Ordering> result = partial_cmp(other);
        return is_some(result) && unwrap(result) == Ordering::Greater;
    }

    virtual bool ge(const PartialOrd& other) const {
        Option<Ordering> result = partial_cmp(other);
        return is_some(result) && unwrap(result) != Ordering::Less;
    }
};

export interface Ord : Eq, PartialOrd {
    virtual Ordering cmp(const Ord& other) const = 0;
};

// ============================================================
// 基本的な関数
// ============================================================

// 値の交換
export template<typename T>
void swap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}

// 最小値
export template<typename T>
T min(T a, T b) {
    if (a < b) {
        return a;
    } else {
        return b;
    }
}

// 最大値
export template<typename T>
T max(T a, T b) {
    if (a > b) {
        return a;
    } else {
        return b;
    }
}

// クランプ
export template<typename T>
T clamp(T value, T min_val, T max_val) {
    if (value < min_val) {
        return min_val;
    } else if (value > max_val) {
        return max_val;
    } else {
        return value;
    }
}

// パニック関数（外部定義）
extern "C" void cm_panic(const char* message);

export void panic(string message) {
    cm_panic(message.c_str());
}