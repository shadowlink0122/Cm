// std::collections::vector - ジェネリック動的配列
// Vector<T> - 任意の型Tを格納できる動的配列
module std.collections.vector;

use libc {
    void* malloc(long size);
    void free(void* ptr);
    void* memcpy(void* dest, void* src, long n);
}

// =============================================================
// Vector<T> - ジェネリック動的配列
// =============================================================

export struct Vector<T> {
    T* data;
    int size;
    int cap;
}

export impl Vector<T> {
    // 初期化
    void init() {
        void* null_ptr = 0 as void*;
        this.data = null_ptr as T*;
        this.size = 0;
        this.cap = 0;
    }

    // 末尾に追加
    void push(T value) {
        if (this.size >= this.cap) {
            int new_cap = this.cap == 0 ? 4 : this.cap * 2;
            // __sizeof__(T)で型サイズを動的取得
            long elem_size = __sizeof__(T) as long;
            long alloc_size = (new_cap as long) * elem_size;
            void* raw_ptr = malloc(alloc_size);
            T* new_data = raw_ptr as T*;
            // 既存データをコピー（memcpyで高速コピー）
            if (this.size > 0) {
                void* src = this.data as void*;
                void* dst = new_data as void*;
                long copy_size = (this.size as long) * elem_size;
                memcpy(dst, src, copy_size);
            }
            void* old_ptr = this.data as void*;
            void* null_ptr = 0 as void*;
            if (old_ptr != null_ptr) {
                free(old_ptr);
            }
            this.data = new_data;
            this.cap = new_cap;
        }
        this.data[this.size] = value;
        this.size = this.size + 1;
    }

    // 取得
    T get(int index) {
        return this.data[index];
    }

    // 設定
    void set(int index, T value) {
        if (index >= 0 && index < this.size) {
            this.data[index] = value;
        }
    }

    // 長さ
    int len() {
        return this.size;
    }

    // 容量
    int capacity() {
        return this.cap;
    }

    // 末尾削除
    T pop() {
        this.size = this.size - 1;
        return this.data[this.size];
    }

    // 空チェック
    bool is_empty() {
        return this.size == 0;
    }

    // クリア（データは保持、サイズのみリセット）
    void clear() {
        this.size = 0;
    }

    // メモリ解放（完全リリース）
    void release() {
        void* ptr = this.data as void*;
        void* null_ptr = 0 as void*;
        if (ptr != null_ptr) {
            free(ptr);
        }
        this.data = null_ptr as T*;
        this.size = 0;
        this.cap = 0;
    }
}
