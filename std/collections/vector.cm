// std::collections::vector - ジェネリック動的配列
// Vector<T> - 任意の型Tを格納できる動的配列
module std.collections.vector;

use libc {
    void* malloc(long size);
    void* realloc(void* ptr, long size);
    void free(void* ptr);
}

// =============================================================
// Vector<T> - ジェネリック動的配列
// =============================================================

export struct Vector<T> {
    T* data;
    int size;
    int cap;
}

export impl Vector<T> {
    // コンストラクタ（静的メソッド風）
    static Vector<T> new() {
        Vector<T> v;
        v.data = 0 as T*;
        v.size = 0;
        v.cap = 0;
        return v;
    }

    // 末尾に追加
    void push(T value) {
        if (this.size >= this.cap) {
            int new_cap = this.cap == 0 ? 4 : this.cap * 2;
            // __sizeof__(T)で型サイズ取得
            long elem_size = __sizeof__(T) as long;
            T* new_data = malloc(new_cap as long * elem_size) as T*;
            // 既存データをコピー
            for (int i = 0; i < this.size; i++) {
                new_data[i] = this.data[i];
            }
            if (this.data != 0 as T*) {
                free(this.data as void*);
            }
            this.data = new_data;
            this.cap = new_cap;
        }
        this.data[this.size] = value;
        this.size = this.size + 1;
    }

    // 取得
    T get(int index) {
        return this.data[index];
    }

    // 設定
    void set(int index, T value) {
        if (index >= 0 && index < this.size) {
            this.data[index] = value;
        }
    }

    // 長さ
    int len() {
        return this.size;
    }

    // 容量
    int capacity() {
        return this.cap;
    }

    // 末尾削除
    T pop() {
        this.size = this.size - 1;
        return this.data[this.size];
    }

    // 空チェック
    bool is_empty() {
        return this.size == 0;
    }

    // クリア（データは保持、サイズのみリセット）
    void clear() {
        this.size = 0;
    }

    // メモリ解放（完全リリース）
    void free() {
        if (this.data != 0 as T*) {
            free(this.data as void*);
        }
        this.data = 0 as T*;
        this.size = 0;
        this.cap = 0;
    }
}
