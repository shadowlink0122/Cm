// std::collections::hashmap - ジェネリック連想配列
// HashMap<V> - キーはint固定、値はジェネリックV
// 注: HashMap<K, V>の2型パラメータはLLVMバックエンドのバグで動作しないため
//     キーはint固定の1型パラメータ版として実装
module std.collections.hashmap;

use libc {
    void* malloc(long size);
    void free(void* ptr);
}

// =============================================================
// HashMap<V> - ジェネリック連想配列（線形探索）
// キー: int固定, 値: ジェネリックV
// 注意: フィールド順序はアライメントを考慮（大きい型を先に）
// =============================================================

export struct Entry<V> {
    V value;       // ジェネリック値を先に
    int key;
    bool occupied;
}

export struct HashMap<V> {
    Entry<V>* entries;
    int cap;
    int size;
}

export impl HashMap<V> {
    // コンストラクタ
    void HashMap(int capacity) {
        // Entryサイズは32バイト固定（十分なサイズ確保）
        long entry_size = 32;
        long alloc_size = (capacity as long) * entry_size;
        void* raw_ptr = malloc(alloc_size);
        this.entries = raw_ptr as Entry<V>*;
        this.cap = capacity;
        this.size = 0;
        for (int i = 0; i < capacity; i++) {
            this.entries[i].occupied = false;
        }
    }

    // 挿入
    void insert(int key, V value) {
        int h = key;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (!this.entries[pos].occupied || this.entries[pos].key == key) {
                if (!this.entries[pos].occupied) {
                    this.size = this.size + 1;
                }
                this.entries[pos].key = key;
                this.entries[pos].value = value;
                this.entries[pos].occupied = true;
                return;
            }
        }
    }

    // 取得
    V get(int key) {
        int h = key;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return this.entries[pos].value;
            }
            if (!this.entries[pos].occupied) {
                break;
            }
        }
        // デフォルト値（型に依存）
        V default_val;
        return default_val;
    }

    // 存在確認
    bool contains(int key) {
        int h = key;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return true;
            }
            if (!this.entries[pos].occupied) {
                return false;
            }
        }
        return false;
    }

    // 削除
    void remove(int key) {
        int h = key;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                this.entries[pos].occupied = false;
                this.size = this.size - 1;
                return;
            }
            if (!this.entries[pos].occupied) {
                return;
            }
        }
    }

    // サイズ
    int len() {
        return this.size;
    }

    // クリア
    void clear() {
        for (int i = 0; i < this.cap; i++) {
            this.entries[i].occupied = false;
        }
        this.size = 0;
    }

    // 解放
    void release() {
        void* ptr = this.entries as void*;
        void* null_ptr = 0 as void*;
        if (ptr != null_ptr) {
            free(ptr);
        }
        this.entries = null_ptr as Entry<V>*;
        this.size = 0;
        this.cap = 0;
    }
}
