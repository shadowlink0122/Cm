// std::collections::hashmap - ジェネリック連想配列
// HashMap<K, V> - キーと値の両方がジェネリック
module std.collections.hashmap;

use libc {
    void* malloc(long size);
    void free(void* ptr);
}

// =============================================================
// HashMap<K, V> - ジェネリック連想配列（線形探索）
// キー: ジェネリックK, 値: ジェネリックV
// 注意: フィールド順序はアライメントを考慮（大きい型を先に）
// =============================================================

export struct Entry<K, V> {
    V value;  // ジェネリック値
    K key;    // ジェネリックキー
    bool occupied;
}

export struct HashMap<K, V> {
    Entry<K, V>* entries;
    int cap;
    int size;
}

export impl<K, V> HashMap<K, V> {
    // コンストラクタ（デフォルト容量16）
    self() {
        int capacity = 16;
        // Entryサイズは64バイト固定（十分なサイズ確保）
        long entry_size = 64;
        long alloc_size = (capacity as long) * entry_size;
        void* raw_ptr = malloc(alloc_size);
        self.entries = raw_ptr as Entry<K, V>*;
        self.cap = capacity;
        self.size = 0;
        for (int i = 0; i < capacity; i++) {
            self.entries[i].occupied = false;
        }
    }

    // 挿入（intキー専用ハッシュ）
    void insert(K key, V value) {
        // 簡易ハッシュ（intとして扱う）
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;

        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (!this.entries[pos].occupied || this.entries[pos].key == key) {
                if (!this.entries[pos].occupied) {
                    this.size = this.size + 1;
                }
                this.entries[pos].key = key;
                this.entries[pos].value = value;
                this.entries[pos].occupied = true;
                return;
            }
        }
    }

    // 取得
    V get(K key) {
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;

        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return this.entries[pos].value;
            }
            if (!this.entries[pos].occupied) {
                break;
            }
        }
        // デフォルト値（型に依存）
        V default_val;
        return default_val;
    }

    // 存在確認
    bool contains(K key) {
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;

        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return true;
            }
            if (!this.entries[pos].occupied) {
                return false;
            }
        }
        return false;
    }

    // 削除
    void remove(K key) {
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;

        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                this.entries[pos].occupied = false;
                this.size = this.size - 1;
                return;
            }
            if (!this.entries[pos].occupied) {
                return;
            }
        }
    }

    // サイズ
    int len() {
        return this.size;
    }

    // クリア
    void clear() {
        for (int i = 0; i < this.cap; i++) {
            this.entries[i].occupied = false;
        }
        this.size = 0;
    }

    // デストラクタ
    ~self() {
        void* ptr = self.entries as void*;
        void* null_ptr = 0 as void*;
        if (ptr != null_ptr) {
            free(ptr);
        }
        self.entries = null_ptr as Entry<K, V>*;
        self.size = 0;
        self.cap = 0;
    }
}
