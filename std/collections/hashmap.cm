// std::collections::hashmap - ジェネリック連想配列
// HashMap<K, V> - キーK、値Vの連想配列
module std.collections.hashmap;

use libc {
    void* malloc(long size);
    void free(void* ptr);
}

// =============================================================
// HashMap<K, V> - ジェネリック連想配列（線形探索）
// =============================================================

export struct Entry<K, V> {
    K key;
    V value;
    bool occupied;
}

export struct HashMap<K, V> {
    Entry<K, V>* entries;
    int cap;
    int size;
}

export impl HashMap<K, V> {
    // 挿入
    void insert(K key, V value) {
        // 単純なハッシュ: キーをintにキャストしてmod
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (!this.entries[pos].occupied || this.entries[pos].key == key) {
                if (!this.entries[pos].occupied) {
                    this.size = this.size + 1;
                }
                this.entries[pos].key = key;
                this.entries[pos].value = value;
                this.entries[pos].occupied = true;
                return;
            }
        }
    }

    // 取得
    V get(K key) {
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return this.entries[pos].value;
            }
            if (!this.entries[pos].occupied) {
                break;
            }
        }
        // デフォルト値（型に依存）
        V default_val;
        return default_val;
    }

    // 存在確認
    bool contains(K key) {
        int h = key as int;
        if (h < 0) { h = 0 - h; }
        int idx = h % this.cap;
        
        for (int i = 0; i < this.cap; i++) {
            int pos = (idx + i) % this.cap;
            if (this.entries[pos].occupied && this.entries[pos].key == key) {
                return true;
            }
            if (!this.entries[pos].occupied) {
                return false;
            }
        }
        return false;
    }

    // サイズ
    int len() {
        return this.size;
    }

    // 解放
    void release() {
        if (this.entries != 0 as Entry<K, V>*) {
            free(this.entries as void*);
        }
        this.entries = 0 as Entry<K, V>*;
        this.size = 0;
        this.cap = 0;
    }
}

// ファクトリ関数
export <K, V> HashMap<K, V> hashmap_new(int capacity) {
    HashMap<K, V> m;
    m.entries = malloc((capacity * 32) as long) as Entry<K, V>*;
    m.cap = capacity;
    m.size = 0;
    for (int i = 0; i < capacity; i++) {
        m.entries[i].occupied = false;
    }
    return m;
}
