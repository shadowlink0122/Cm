// std/thread/mod.cm - スレッドモジュール
// C++ backing (thread_runtime.cpp) を使用
module std.thread;

// ============================================================
// C++ backing extern宣言
// ============================================================

extern "C" ulong cm_thread_create(void* fn, void* arg);
extern "C" int cm_thread_join(ulong thread_id, void** retval);
extern "C" void cm_thread_detach(ulong thread_id);
extern "C" ulong cm_thread_self();
extern "C" void cm_thread_sleep_us(ulong microseconds);
extern "C" void cm_thread_join_all(ulong* handles, int count);
extern "C" ulong cm_thread_spawn_with_arg(void* fn, void* arg);

// ============================================================
// Thread API
// ============================================================

// 新しいスレッドを生成（引数なし）
export ulong spawn(void* fn) {
    return cm_thread_create(fn, 0 as void*);
}

// 新しいスレッドを生成（引数あり）
export ulong spawn_with_arg(void* fn, void* arg) {
    return cm_thread_spawn_with_arg(fn, arg);
}

// スレッドの終了を待機し、結果を取得
export int join(ulong handle) {
    void* result = 0 as void*;
    cm_thread_join(handle, &result);
    return result as int;
}

// 複数スレッドを一括待機
// handles: スレッドハンドルの配列
// count: 配列の要素数
export void join_all(ulong* handles, int count) {
    cm_thread_join_all(handles, count);
}

// スレッドをデタッチ（バックグラウンド実行）
export void detach(ulong handle) {
    cm_thread_detach(handle);
}

// 現在のスレッドIDを取得
export ulong current_id() {
    return cm_thread_self();
}

// ============================================================
// スリープ関数
// ============================================================

// 現在のスレッドをスリープ（ミリ秒）
export void sleep_ms(int ms) {
    cm_thread_sleep_us((ms * 1000) as ulong);
}

// 現在のスレッドをスリープ（秒）
export void sleep(int seconds) {
    cm_thread_sleep_us((seconds * 1000000) as ulong);
}

