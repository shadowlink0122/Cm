#pragma once

#include "../mir_cpp/mir_cpp_nodes.hpp"
#include "../common/debug.hpp"
#include <sstream>
#include <iomanip>

namespace cm::codegen {

class CppCodeGeneratorV2 {
private:
    std::ostringstream output;
    int indent_level = 0;

    void emit_line(const std::string& line) {
        for (int i = 0; i < indent_level; ++i) {
            output << "    ";
        }
        output << line << "\n";
    }

    void emit(const std::string& text) {
        output << text;
    }

    void emit_indent() {
        for (int i = 0; i < indent_level; ++i) {
            output << "    ";
        }
    }

public:
    std::string generate(const mir_cpp::Program& program) {
        // ヘッダーコメント
        emit_line("// Generated by Cm Compiler (MIR-C++ Backend v2)");
        emit_line("");

        // インクルード
        for (const auto& import : program.imports) {
            emit_line("#include " + import);
        }
        emit_line("");

        // 標準ライブラリ関数（println用）
        generate_stdlib();

        // 各関数を生成
        for (const auto& func : program.functions) {
            generate_function(func);
            emit_line("");
        }

        // main関数のエントリーポイント
        generate_main_entry();

        return output.str();
    }

private:
    void generate_stdlib() {
        // println実装（シンプル版）
        emit_line("template<typename... Args>");
        emit_line("void println(Args... args) {");
        indent_level++;
        emit_line("((std::cout << args), ...);");
        emit_line("std::cout << std::endl;");
        indent_level--;
        emit_line("}");
        emit_line("");

        // print実装
        emit_line("template<typename... Args>");
        emit_line("void print(Args... args) {");
        indent_level++;
        emit_line("((std::cout << args), ...);");
        indent_level--;
        emit_line("}");
        emit_line("");
    }

    void generate_function(const mir_cpp::Function& func) {
        // 関数シグネチャ
        std::string return_type = type_to_cpp(func.return_type);

        // main関数はcm_mainとして生成
        std::string func_name = func.is_main ? "cm_main" : func.name;

        emit_indent();
        emit(return_type + " " + func_name + "(");

        // パラメータ
        bool first = true;
        for (const auto& [name, type] : func.params) {
            if (!first) emit(", ");
            emit(type_to_cpp(type) + " " + name);
            first = false;
        }

        emit(") {\n");
        indent_level++;

        // 関数本体
        generate_block(func.body);

        indent_level--;
        emit_line("}");
    }

    void generate_block(mir_cpp::BlockPtr block) {
        for (const auto& stmt : block->statements) {
            generate_statement(stmt);
        }
    }

    void generate_statement(mir_cpp::StmtPtr stmt) {
        switch (stmt->kind) {
            case mir_cpp::StmtKind::VarDecl: {
                auto& decl = std::get<mir_cpp::VarDecl>(stmt->data);
                emit_indent();

                if (decl.is_const) {
                    emit("const ");
                }

                emit(type_to_cpp(decl.type) + " " + decl.name);

                if (decl.init) {
                    emit(" = ");
                    generate_expression(decl.init);
                } else {
                    // デフォルト初期化
                    if (decl.type->kind == hir::TypeKind::String) {
                        emit("");  // std::stringはデフォルトコンストラクタで初期化される
                    } else if (decl.type->kind == hir::TypeKind::Bool) {
                        emit(" = false");
                    } else if (decl.type->kind == hir::TypeKind::Int ||
                              decl.type->kind == hir::TypeKind::Double) {
                        emit(" = 0");
                    }
                }

                emit(";\n");
                break;
            }

            case mir_cpp::StmtKind::Assignment: {
                auto& assign = std::get<mir_cpp::Assignment>(stmt->data);
                emit_indent();
                emit(assign.target + " = ");
                generate_expression(assign.value);
                emit(";\n");
                break;
            }

            case mir_cpp::StmtKind::Expression: {
                auto& expr = std::get<mir_cpp::ExprPtr>(stmt->data);
                emit_indent();
                generate_expression(expr);
                emit(";\n");
                break;
            }

            case mir_cpp::StmtKind::If: {
                auto& if_stmt = std::get<mir_cpp::IfStmt>(stmt->data);
                emit_indent();
                emit("if (");
                generate_expression(if_stmt.condition);
                emit(") {\n");

                indent_level++;
                generate_block(if_stmt.then_block);
                indent_level--;

                if (if_stmt.else_block) {
                    emit_line("} else {");
                    indent_level++;
                    generate_block(if_stmt.else_block);
                    indent_level--;
                }

                emit_line("}");
                break;
            }

            case mir_cpp::StmtKind::While: {
                auto& while_stmt = std::get<mir_cpp::WhileStmt>(stmt->data);
                emit_indent();
                emit("while (");
                generate_expression(while_stmt.condition);
                emit(") {\n");

                indent_level++;
                generate_block(while_stmt.body);
                indent_level--;

                emit_line("}");
                break;
            }

            case mir_cpp::StmtKind::For: {
                auto& for_stmt = std::get<mir_cpp::ForStmt>(stmt->data);
                emit_indent();
                emit("for (");

                // 初期化
                if (for_stmt.init) {
                    // インライン生成（セミコロンなし）
                    // TODO: 適切な処理
                }
                emit("; ");

                // 条件
                if (for_stmt.condition) {
                    generate_expression(for_stmt.condition);
                }
                emit("; ");

                // 更新
                if (for_stmt.update) {
                    // インライン生成
                }

                emit(") {\n");

                indent_level++;
                generate_block(for_stmt.body);
                indent_level--;

                emit_line("}");
                break;
            }

            case mir_cpp::StmtKind::Return: {
                auto& ret = std::get<mir_cpp::ReturnStmt>(stmt->data);
                emit_indent();
                emit("return");

                if (ret.value) {
                    emit(" ");
                    generate_expression(ret.value);
                }

                emit(";\n");
                break;
            }

            case mir_cpp::StmtKind::Break: {
                emit_line("break;");
                break;
            }

            case mir_cpp::StmtKind::Continue: {
                emit_line("continue;");
                break;
            }

            case mir_cpp::StmtKind::Block: {
                auto& block = std::get<mir_cpp::BlockPtr>(stmt->data);
                emit_line("{");
                indent_level++;
                generate_block(block);
                indent_level--;
                emit_line("}");
                break;
            }
        }
    }

    void generate_expression(mir_cpp::ExprPtr expr) {
        switch (expr->kind) {
            case mir_cpp::ExprKind::Literal: {
                auto& lit = std::get<mir_cpp::Literal>(expr->data);
                generate_literal(lit);
                break;
            }

            case mir_cpp::ExprKind::Variable: {
                auto& var = std::get<mir_cpp::Variable>(expr->data);
                emit(var.name);
                break;
            }

            case mir_cpp::ExprKind::Binary: {
                auto& bin = std::get<mir_cpp::BinaryOp>(expr->data);
                emit("(");
                generate_expression(bin.left);
                emit(" " + binary_op_to_cpp(bin.op) + " ");
                generate_expression(bin.right);
                emit(")");
                break;
            }

            case mir_cpp::ExprKind::Unary: {
                auto& un = std::get<mir_cpp::UnaryOp>(expr->data);
                emit(unary_op_to_cpp(un.op));
                emit("(");
                generate_expression(un.operand);
                emit(")");
                break;
            }

            case mir_cpp::ExprKind::Call: {
                auto& call = std::get<mir_cpp::CallExpr>(expr->data);

                // println/printの特別処理（文字列補間をサポート）
                if (call.func_name == "println" && !call.args.empty()) {
                    // 第一引数が文字列補間の場合、特別に処理
                    if (call.args[0]->kind == mir_cpp::ExprKind::StringInterpolation) {
                        generate_println_with_interpolation(call);
                        break;
                    }
                }

                // 通常の関数呼び出し
                emit(call.func_name + "(");
                bool first = true;
                for (const auto& arg : call.args) {
                    if (!first) emit(", ");
                    generate_expression(arg);
                    first = false;
                }
                emit(")");
                break;
            }

            case mir_cpp::ExprKind::Cast: {
                auto& cast = std::get<mir_cpp::CastExpr>(expr->data);
                emit("static_cast<" + type_to_cpp(cast.target_type) + ">(");
                generate_expression(cast.expr);
                emit(")");
                break;
            }

            case mir_cpp::ExprKind::StringInterpolation: {
                // 文字列補間を直接文字列として生成
                auto& interp = std::get<mir_cpp::StringInterpolation>(expr->data);
                generate_string_interpolation(interp);
                break;
            }
        }
    }

    void generate_println_with_interpolation(const mir_cpp::CallExpr& call) {
        auto& interp = std::get<mir_cpp::StringInterpolation>(call.args[0]->data);

        emit("std::cout");

        // 補間された文字列を出力
        for (const auto& part : interp.parts) {
            if (!part.text.empty()) {
                emit(" << \"" + escape_string(part.text) + "\"");
            }

            if (part.expr) {
                // フォーマット指定子を処理
                if (!part.format_spec.empty()) {
                    emit(" << ");
                    generate_formatted_output(part.expr, part.format_spec);
                } else {
                    emit(" << ");
                    generate_expression(part.expr);
                }
            }
        }

        // 残りの引数があれば出力
        for (size_t i = 1; i < call.args.size(); ++i) {
            emit(" << ");
            generate_expression(call.args[i]);
        }

        emit(" << std::endl");
    }

    void generate_formatted_output(mir_cpp::ExprPtr expr, const std::string& spec) {
        // フォーマット指定子に基づいた出力
        if (spec == "x") {
            emit("std::hex << ");
            generate_expression(expr);
            emit(" << std::dec");
        } else if (spec == "X") {
            emit("std::hex << std::uppercase << ");
            generate_expression(expr);
            emit(" << std::nouppercase << std::dec");
        } else if (spec == "b") {
            emit("std::bitset<32>(");
            generate_expression(expr);
            emit(")");
        } else if (spec == "o") {
            emit("std::oct << ");
            generate_expression(expr);
            emit(" << std::dec");
        } else if (spec.size() > 1 && spec[0] == '.') {
            // 小数点精度
            int precision = std::stoi(spec.substr(1));
            emit("std::fixed << std::setprecision(" + std::to_string(precision) + ") << ");
            generate_expression(expr);
        } else if (spec == "e") {
            emit("std::scientific << ");
            generate_expression(expr);
        } else if (spec == "E") {
            emit("std::scientific << std::uppercase << ");
            generate_expression(expr);
            emit(" << std::nouppercase");
        } else if (spec[0] == '<' && spec.size() > 1) {
            int width = std::stoi(spec.substr(1));
            emit("std::left << std::setw(" + std::to_string(width) + ") << ");
            generate_expression(expr);
        } else if (spec[0] == '>' && spec.size() > 1) {
            int width = std::stoi(spec.substr(1));
            emit("std::right << std::setw(" + std::to_string(width) + ") << ");
            generate_expression(expr);
        } else if (spec[0] == '^' && spec.size() > 1) {
            // 中央揃え（簡易実装）
            int width = std::stoi(spec.substr(1));
            emit("std::setw(" + std::to_string(width) + ") << ");
            generate_expression(expr);
        } else if (spec.size() > 2 && spec.substr(0, 2) == "0>") {
            int width = std::stoi(spec.substr(2));
            emit("std::setfill('0') << std::setw(" + std::to_string(width) + ") << ");
            generate_expression(expr);
            emit(" << std::setfill(' ')");
        } else {
            // デフォルト
            generate_expression(expr);
        }
    }

    void generate_string_interpolation(const mir_cpp::StringInterpolation& interp) {
        emit("(std::ostringstream{} << ");

        bool first = true;
        for (const auto& part : interp.parts) {
            if (!first) emit(" << ");

            if (!part.text.empty()) {
                emit("\"" + escape_string(part.text) + "\"");
                if (part.expr) emit(" << ");
            }

            if (part.expr) {
                if (!part.format_spec.empty()) {
                    generate_formatted_output(part.expr, part.format_spec);
                } else {
                    generate_expression(part.expr);
                }
            }

            first = false;
        }

        emit(").str()");
    }

    void generate_literal(const mir_cpp::Literal& lit) {
        if (auto* i = std::get_if<int64_t>(&lit.value)) {
            emit(std::to_string(*i));
        } else if (auto* d = std::get_if<double>(&lit.value)) {
            std::ostringstream oss;
            oss << std::fixed << std::setprecision(6) << *d;
            std::string str = oss.str();
            // 末尾の0を削除
            size_t dot_pos = str.find('.');
            if (dot_pos != std::string::npos) {
                size_t end = str.find_last_not_of('0');
                if (end != std::string::npos && end > dot_pos) {
                    str = str.substr(0, end + 1);
                    if (str.back() == '.') {
                        str += '0';
                    }
                }
            }
            emit(str);
        } else if (auto* b = std::get_if<bool>(&lit.value)) {
            emit(*b ? "true" : "false");
        } else if (auto* c = std::get_if<char>(&lit.value)) {
            emit("'" + std::string(1, *c) + "'");
        } else if (auto* s = std::get_if<std::string>(&lit.value)) {
            emit("\"" + escape_string(*s) + "\"");
        }
    }

    void generate_main_entry() {
        emit_line("// Entry point");
        emit_line("int main(int argc, char* argv[]) {");
        indent_level++;
        emit_line("return cm_main();");
        indent_level--;
        emit_line("}");
    }

    std::string type_to_cpp(hir::TypePtr type) {
        if (!type) return "void";

        switch (type->kind) {
            case hir::TypeKind::Void: return "void";
            case hir::TypeKind::Bool: return "bool";
            case hir::TypeKind::Char: return "char";
            case hir::TypeKind::Int: return "int";
            case hir::TypeKind::Long: return "long";
            case hir::TypeKind::Double: return "double";
            case hir::TypeKind::String: return "std::string";
            default: return "auto";
        }
    }

    std::string binary_op_to_cpp(mir_cpp::BinaryOp::Op op) {
        switch (op) {
            case mir_cpp::BinaryOp::Add: return "+";
            case mir_cpp::BinaryOp::Sub: return "-";
            case mir_cpp::BinaryOp::Mul: return "*";
            case mir_cpp::BinaryOp::Div: return "/";
            case mir_cpp::BinaryOp::Mod: return "%";
            case mir_cpp::BinaryOp::Eq: return "==";
            case mir_cpp::BinaryOp::Ne: return "!=";
            case mir_cpp::BinaryOp::Lt: return "<";
            case mir_cpp::BinaryOp::Le: return "<=";
            case mir_cpp::BinaryOp::Gt: return ">";
            case mir_cpp::BinaryOp::Ge: return ">=";
            case mir_cpp::BinaryOp::And: return "&&";
            case mir_cpp::BinaryOp::Or: return "||";
            case mir_cpp::BinaryOp::BitAnd: return "&";
            case mir_cpp::BinaryOp::BitOr: return "|";
            case mir_cpp::BinaryOp::BitXor: return "^";
            case mir_cpp::BinaryOp::Shl: return "<<";
            case mir_cpp::BinaryOp::Shr: return ">>";
            default: return "+";
        }
    }

    std::string unary_op_to_cpp(mir_cpp::UnaryOp::Op op) {
        switch (op) {
            case mir_cpp::UnaryOp::Neg: return "-";
            case mir_cpp::UnaryOp::Not: return "!";
            case mir_cpp::UnaryOp::BitNot: return "~";
            default: return "";
        }
    }

    std::string escape_string(const std::string& str) {
        std::string result;
        for (char c : str) {
            switch (c) {
                case '\n': result += "\\n"; break;
                case '\r': result += "\\r"; break;
                case '\t': result += "\\t"; break;
                case '\\': result += "\\\\"; break;
                case '"': result += "\\\""; break;
                default: result += c; break;
            }
        }
        return result;
    }
};

}  // namespace cm::codegen