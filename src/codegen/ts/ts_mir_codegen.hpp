#pragma once

#include "ts_mir.hpp"

#include <filesystem>
#include <fstream>
#include <sstream>

namespace cm {
namespace ts_mir {

// ============================================================
// TS-MIR → TypeScriptコード 生成器
// ============================================================
class TsMirCodegen {
   public:
    struct Options {
        std::string output_dir = ".tmp/ts_output";
        bool generate_package_json = true;  // テストランナーのために常にtrue
        bool use_strict = true;
    };

    TsMirCodegen() = default;
    TsMirCodegen(const Options& opts) : options(opts) {}

    void generate(const Program& program, const std::string& output_path = "") {
        if (!output_path.empty()) {
            options.output_dir = output_path;
        }

        std::filesystem::create_directories(options.output_dir);

        // main.ts を生成
        std::ofstream out(options.output_dir + "/main.ts");
        out << generateCode(program);
        out.close();

        // package.json と tsconfig.json を生成
        generatePackageJson();
        generateTsConfig();
    }

    std::string generateCode(const Program& program) {
        std::ostringstream out;

        // ヘッダコメント
        out << "// Generated by Cm compiler\n";
        out << "// Do not edit manually\n\n";

        // 関数を生成
        for (const auto& func : program.functions) {
            out << generateFunction(func);
            out << "\n";
        }

        // mainの呼び出し（main関数がある場合）
        for (const auto& func : program.functions) {
            if (func.is_main) {
                out << "// Entry point\n";
                if (func.return_type == Type::NUMBER) {
                    // main関数の戻り値を終了コードとして使用
                    out << "const __exitCode = main();\n";
                    out << "if (__exitCode !== 0) process.exit(__exitCode);\n";
                } else {
                    out << "main();\n";
                }
                break;
            }
        }

        return out.str();
    }

   private:
    Options options;
    int indent_level = 0;

    std::string generateFunction(const Function& func) {
        std::ostringstream out;

        // 関数シグネチャ
        out << "function " << func.name << "(";

        // パラメータ
        for (size_t i = 0; i < func.parameters.size(); ++i) {
            if (i > 0)
                out << ", ";
            out << func.parameters[i].second << ": " << typeToString(func.parameters[i].first);
        }

        out << ")";

        // 戻り値型
        if (func.return_type != Type::VOID) {
            out << ": " << typeToString(func.return_type);
        }

        out << " {\n";

        indent_level++;

        // 本体
        for (const auto& stmt : func.body) {
            out << generateStatement(stmt);
        }

        indent_level--;
        out << "}\n";

        return out.str();
    }

    std::string generateStatement(const Statement& stmt) {
        std::ostringstream out;
        std::string indent(indent_level * 4, ' ');

        switch (stmt.kind) {
            case StatementKind::CONST:
            case StatementKind::LET: {
                out << indent;
                if (stmt.var_data.is_const) {
                    out << "const ";
                } else {
                    out << "let ";
                }
                out << stmt.var_data.name;

                // 型アノテーション
                out << ": " << typeToString(stmt.var_data.type);

                if (stmt.var_data.init) {
                    out << " = " << exprToString(stmt.var_data.init.value());
                }
                out << ";\n";
                break;
            }

            case StatementKind::ASSIGNMENT: {
                out << indent << stmt.assign_data.target << " = "
                    << exprToString(stmt.assign_data.value) << ";\n";
                break;
            }

            case StatementKind::CONSOLE_LOG: {
                out << indent << "console.log(";
                for (size_t i = 0; i < stmt.console_data.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(stmt.console_data.args[i]);
                }
                out << ");\n";
                break;
            }

            case StatementKind::EXPRESSION: {
                out << indent << exprToString(stmt.expr_data) << ";\n";
                break;
            }

            case StatementKind::IF_ELSE: {
                out << indent << "if (" << exprToString(stmt.if_data->condition) << ") {\n";
                indent_level++;
                for (const auto& inner : stmt.if_data->then_body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                if (!stmt.if_data->else_body.empty()) {
                    out << indent << "} else {\n";
                    indent_level++;
                    for (const auto& inner : stmt.if_data->else_body) {
                        out << generateStatement(*inner);
                    }
                    indent_level--;
                }
                out << indent << "}\n";
                break;
            }

            case StatementKind::WHILE: {
                out << indent << "while (" << exprToString(stmt.while_data->condition) << ") {\n";
                indent_level++;
                for (const auto& inner : stmt.while_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::FOR: {
                out << indent << "for (";

                // 初期化
                if (stmt.for_data->init) {
                    out << generateForInit(*stmt.for_data->init);
                }
                out << "; ";

                // 条件
                if (stmt.for_data->condition) {
                    out << exprToString(stmt.for_data->condition.value());
                }
                out << "; ";

                // 更新
                if (stmt.for_data->update) {
                    out << generateForUpdate(*stmt.for_data->update);
                }
                out << ") {\n";

                indent_level++;
                for (const auto& inner : stmt.for_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::FOR_OF: {
                out << indent << "for (const " << stmt.for_of_data->var_name << " of "
                    << exprToString(stmt.for_of_data->iterable) << ") {\n";
                indent_level++;
                for (const auto& inner : stmt.for_of_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::RETURN: {
                out << indent;
                if (stmt.return_data.value) {
                    out << "return " << exprToString(stmt.return_data.value.value());
                } else {
                    out << "return";
                }
                out << ";\n";
                break;
            }

            case StatementKind::BREAK: {
                out << indent << "break;\n";
                break;
            }

            case StatementKind::CONTINUE: {
                out << indent << "continue;\n";
                break;
            }
        }

        return out.str();
    }

    std::string generateForInit(const Statement& stmt) {
        if (stmt.kind == StatementKind::CONST || stmt.kind == StatementKind::LET) {
            std::ostringstream out;
            if (stmt.var_data.is_const) {
                out << "const ";
            } else {
                out << "let ";
            }
            out << stmt.var_data.name << ": " << typeToString(stmt.var_data.type);
            if (stmt.var_data.init) {
                out << " = " << exprToString(stmt.var_data.init.value());
            }
            return out.str();
        }
        return "";
    }

    std::string generateForUpdate(const Statement& stmt) {
        if (stmt.kind == StatementKind::EXPRESSION) {
            return exprToString(stmt.expr_data);
        } else if (stmt.kind == StatementKind::ASSIGNMENT) {
            return stmt.assign_data.target + " = " + exprToString(stmt.assign_data.value);
        }
        return "";
    }

    std::string exprToString(const Expression& expr) {
        switch (expr.kind) {
            case Expression::LITERAL:
                // 文字列リテラルの場合はエスケープ処理を行う
                if (expr.type == Type::STRING) {
                    return escapeStringLiteral(expr.value);
                }
                return expr.value;
            case Expression::VARIABLE:
            case Expression::BINARY_OP:
            case Expression::UNARY_OP:
            case Expression::TEMPLATE_LIT:
            case Expression::TERNARY:
                return expr.value;

            case Expression::CALL: {
                std::ostringstream out;
                out << expr.func_name << "(";
                for (size_t i = 0; i < expr.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(expr.args[i]);
                }
                out << ")";
                return out.str();
            }

            case Expression::METHOD_CALL: {
                std::ostringstream out;
                if (expr.receiver) {
                    out << exprToString(*expr.receiver) << ".";
                }
                out << expr.method_name << "(";
                for (size_t i = 0; i < expr.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(expr.args[i]);
                }
                out << ")";
                return out.str();
            }

            default:
                return expr.value;
        }
    }

    // 文字列リテラルをTypeScript用にエスケープ
    std::string escapeStringLiteral(const std::string& value) {
        // 引用符で囲まれているか確認
        if (value.length() < 2 || value[0] != '"' || value.back() != '"') {
            return value;
        }

        std::string content = value.substr(1, value.length() - 2);
        std::string result = "\"";

        size_t i = 0;
        while (i < content.length()) {
            // Cm言語の {{ → { と }} → } のエスケープを処理
            if (content[i] == '{' && i + 1 < content.length() && content[i + 1] == '{') {
                result += '{';
                i += 2;
                continue;
            }
            if (content[i] == '}' && i + 1 < content.length() && content[i + 1] == '}') {
                result += '}';
                i += 2;
                continue;
            }

            switch (content[i]) {
                case '\\':
                    result += "\\\\";
                    break;
                case '"':
                    result += "\\\"";
                    break;
                case '\n':
                    result += "\\n";
                    break;
                case '\r':
                    result += "\\r";
                    break;
                case '\t':
                    result += "\\t";
                    break;
                default:
                    result += content[i];
                    break;
            }
            i++;
        }

        result += "\"";
        return result;
    }

    std::string typeToString(Type type) {
        switch (type) {
            case Type::VOID:
                return "void";
            case Type::BOOLEAN:
                return "boolean";
            case Type::NUMBER:
                return "number";
            case Type::STRING:
                return "string";
            case Type::ANY:
                return "any";
            case Type::UNKNOWN:
                return "unknown";
            default:
                return "any";
        }
    }

    void generatePackageJson() {
        std::ofstream out(options.output_dir + "/package.json");
        out << "{\n";
        out << "  \"name\": \"cm-output\",\n";
        out << "  \"version\": \"1.0.0\",\n";
        out << "  \"main\": \"main.js\",\n";
        out << "  \"scripts\": {\n";
        out << "    \"build\": \"tsc\",\n";
        out << "    \"start\": \"node main.js\"\n";
        out << "  },\n";
        out << "  \"devDependencies\": {\n";
        out << "    \"typescript\": \"^5.0.0\",\n";
        out << "    \"@types/node\": \"^20.0.0\"\n";
        out << "  }\n";
        out << "}\n";
    }

    void generateTsConfig() {
        std::ofstream out(options.output_dir + "/tsconfig.json");
        out << "{\n";
        out << "  \"compilerOptions\": {\n";
        out << "    \"target\": \"ES2020\",\n";
        out << "    \"module\": \"commonjs\",\n";
        out << "    \"strict\": false,\n";
        out << "    \"esModuleInterop\": true,\n";
        out << "    \"skipLibCheck\": true,\n";
        out << "    \"forceConsistentCasingInFileNames\": true\n";
        out << "  },\n";
        out << "  \"files\": [\"main.ts\"]\n";
        out << "}\n";
    }
};

}  // namespace ts_mir
}  // namespace cm
