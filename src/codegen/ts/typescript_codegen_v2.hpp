#pragma once

#include "../../mir/mir_nodes.hpp"

#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

namespace cm::codegen {

class TypeScriptCodeGeneratorV2 {
   private:
    std::stringstream output;
    int indent_level = 0;

    void emit(const std::string& code) { output << std::string(indent_level * 2, ' ') << code; }

    void emit_line(const std::string& code = "") {
        if (!code.empty()) {
            emit(code);
        }
        output << "\n";
    }

   public:
    std::string generate(const mir::MirProgram& mir_program) {
        // ヘッダー
        emit_line("// Generated by Cm compiler V2");
        emit_line("// State machine based code generation");
        emit_line();

        // 各関数を生成
        for (const auto& func : mir_program.functions) {
            if (func) {
                generate_function(*func);
            }
        }

        return output.str();
    }

   private:
    void generate_function(const mir::MirFunction& func) {
        // 関数シグネチャ
        if (func.name == "main") {
            emit_line("function main(): void {");
        } else {
            emit("function " + func.name + "(");
            for (size_t i = 0; i < func.arg_locals.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("_" + std::to_string(func.arg_locals[i]) + ": " +
                     type_to_ts(*func.locals[func.arg_locals[i]].type));
            }
            emit("): " + type_to_ts(*func.locals[func.return_local].type));
            emit_line(" {");
        }
        indent_level++;

        // ローカル変数の宣言
        for (size_t i = 0; i < func.locals.size(); i++) {
            // anyとして宣言（TypeScriptは動的型付けに対応）
            emit_line("let _" + std::to_string(i) + ": any;");
        }
        emit_line();

        // ステートマシンによる基本ブロックの実行
        emit_line("let _current_bb: number = 0;");
        emit_line("while (true) {");
        indent_level++;
        emit_line("switch (_current_bb) {");
        indent_level++;

        // 各基本ブロックをcaseとして生成
        for (const auto& block : func.basic_blocks) {
            if (!block)
                continue;

            emit_line("case " + std::to_string(block->id) + ":");
            indent_level++;

            // ブロック内の文を生成
            for (const auto& stmt : block->statements) {
                if (stmt) {
                    generate_statement(*stmt, func);
                }
            }

            // ターミネータを生成（次のブロックを決定）
            if (block->terminator) {
                generate_terminator_v2(*block->terminator, func);
            }

            emit_line("break;");
            indent_level--;
        }

        // デフォルトケース
        emit_line("default:");
        indent_level++;
        emit_line("throw new Error(`Invalid basic block: ${_current_bb}`);");
        indent_level--;

        indent_level--;
        emit_line("}");
        indent_level--;
        emit_line("}");

        indent_level--;
        emit_line("}");
        emit_line();

        // main関数の呼び出し
        if (func.name == "main") {
            emit_line("// Execute main");
            emit_line("main();");
            emit_line();
        }
    }

    void generate_terminator_v2(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                if (func.name == "main") {
                    if (func.return_local < func.locals.size() &&
                        func.locals[func.return_local].type &&
                        func.locals[func.return_local].type->name != "void") {
                        emit_line("process.exit(_" + std::to_string(func.return_local) + ");");
                    } else {
                        emit_line("return;");
                    }
                } else {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                }
                break;

            case mir::MirTerminator::Goto:
                emit_line("_current_bb = " +
                          std::to_string(std::get<mir::MirTerminator::GotoData>(term.data).target) +
                          ";");
                break;

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("switch (" + operand_to_ts(*data.discriminant) + ") {");
                indent_level++;

                // 各ケース
                for (const auto& [value, target] : data.targets) {
                    emit_line("case " + std::to_string(value) + ":");
                    indent_level++;
                    emit_line("_current_bb = " + std::to_string(target) + ";");
                    emit_line("break;");
                    indent_level--;
                }

                // デフォルトケース
                emit_line("default:");
                indent_level++;
                emit_line("_current_bb = " + std::to_string(data.otherwise) + ";");
                emit_line("break;");
                indent_level--;

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);

                // 関数名を取得（定数の場合は文字列を抽出）
                std::string func_name;
                if (data.func->kind == mir::MirOperand::Constant) {
                    auto& constant = std::get<mir::MirConstant>(data.func->data);
                    if (std::holds_alternative<std::string>(constant.value)) {
                        func_name = std::get<std::string>(constant.value);
                    } else {
                        func_name = operand_to_ts(*data.func);
                    }
                } else {
                    func_name = operand_to_ts(*data.func);
                }

                // std::io::println を console.log にマップ
                // 注意: printlnはbuiltinではなく、必ずstd::ioからインポートする必要があります
                if (func_name == "std::io::println") {
                    if (data.args.size() == 1) {
                        emit_line("console.log(" + operand_to_ts(*data.args[0]) + ");");
                    } else {
                        emit_line("console.log();");
                    }
                } else if (func_name == "std::io::print") {
                    if (data.args.size() == 1) {
                        emit_line("process.stdout.write(" + operand_to_ts(*data.args[0]) + ");");
                    } else {
                        emit_line("process.stdout.write(\"\");");
                    }
                } else {
                    // 通常の関数呼び出し
                    if (data.destination) {
                        emit("_" + std::to_string(data.destination->local) + " = ");
                    }
                    emit(func_name + "(");
                    for (size_t i = 0; i < data.args.size(); i++) {
                        if (i > 0)
                            emit(", ");
                        emit(operand_to_ts(*data.args[i]));
                    }
                    emit_line(");");
                }

                // 次のブロックへ
                emit_line("_current_bb = " + std::to_string(data.success) + ";");
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("throw new Error('Unreachable code');");
                break;
        }
    }

    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                emit(place_to_ts(data.place) + " = ");
                if (data.rvalue) {
                    generate_rvalue(*data.rvalue);
                }
                emit_line(";");
                break;
            }

            case mir::MirStatement::StorageLive:
            case mir::MirStatement::StorageDead:
            case mir::MirStatement::Nop:
                // TypeScriptでは特に処理不要
                break;
        }
    }

    void generate_rvalue(const mir::MirRvalue& rvalue) {
        switch (rvalue.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rvalue.data);
                if (data.operand) {
                    emit(operand_to_ts(*data.operand));
                }
                break;
            }

            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rvalue.data);
                emit("(");
                if (data.lhs)
                    emit(operand_to_ts(*data.lhs));
                emit(" " + binary_op_to_ts(data.op) + " ");
                if (data.rhs)
                    emit(operand_to_ts(*data.rhs));
                emit(")");
                break;
            }

            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rvalue.data);
                emit(unary_op_to_ts(data.op));
                if (data.operand) {
                    emit(operand_to_ts(*data.operand));
                }
                break;
            }

            case mir::MirRvalue::Ref: {
                // TypeScriptには参照がないため、値をそのまま使用
                auto& data = std::get<mir::MirRvalue::RefData>(rvalue.data);
                emit(place_to_ts(data.place));
                break;
            }

            case mir::MirRvalue::Aggregate: {
                auto& data = std::get<mir::MirRvalue::AggregateData>(rvalue.data);
                emit("[");
                for (size_t i = 0; i < data.operands.size(); i++) {
                    if (i > 0)
                        emit(", ");
                    if (data.operands[i]) {
                        emit(operand_to_ts(*data.operands[i]));
                    }
                }
                emit("]");
                break;
            }

            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rvalue.data);
                // TypeScriptではキャスト記法が異なる
                if (data.operand) {
                    emit(operand_to_ts(*data.operand));
                }
                if (data.target_type) {
                    emit(" as ");
                    emit(type_to_ts(*data.target_type));
                }
                break;
            }
        }
    }

    std::string place_to_ts(const mir::MirPlace& place) {
        return "_" + std::to_string(place.local);
    }

    std::string operand_to_ts(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Copy:
            case mir::MirOperand::Move:
                return place_to_ts(std::get<mir::MirPlace>(op.data));
            case mir::MirOperand::Constant:
                return constant_to_ts(std::get<mir::MirConstant>(op.data));
            case mir::MirOperand::FunctionRef:
                // 関数参照の場合は関数名を返す
                if (std::holds_alternative<std::string>(op.data)) {
                    return std::get<std::string>(op.data);
                }
                return "???";
        }
        return "???";
    }

    std::string constant_to_ts(const mir::MirConstant& constant) {
        return std::visit(
            [](const auto& val) -> std::string {
                using T = std::decay_t<decltype(val)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    return "undefined";
                } else if constexpr (std::is_same_v<T, bool>) {
                    return val ? "true" : "false";
                } else if constexpr (std::is_same_v<T, int64_t>) {
                    return std::to_string(val);
                } else if constexpr (std::is_same_v<T, double>) {
                    return std::to_string(val);
                } else if constexpr (std::is_same_v<T, char>) {
                    return "'" + std::string(1, val) + "'";
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return "\"" + val + "\"";
                }
                return "???";
            },
            constant.value);
    }

    std::string binary_op_to_ts(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add:
                return "+";
            case mir::MirBinaryOp::Sub:
                return "-";
            case mir::MirBinaryOp::Mul:
                return "*";
            case mir::MirBinaryOp::Div:
                return "/";
            case mir::MirBinaryOp::Mod:
                return "%";
            case mir::MirBinaryOp::BitAnd:
                return "&";
            case mir::MirBinaryOp::BitOr:
                return "|";
            case mir::MirBinaryOp::BitXor:
                return "^";
            case mir::MirBinaryOp::Shl:
                return "<<";
            case mir::MirBinaryOp::Shr:
                return ">>";
            case mir::MirBinaryOp::Eq:
                return "===";
            case mir::MirBinaryOp::Ne:
                return "!==";
            case mir::MirBinaryOp::Lt:
                return "<";
            case mir::MirBinaryOp::Le:
                return "<=";
            case mir::MirBinaryOp::Gt:
                return ">";
            case mir::MirBinaryOp::Ge:
                return ">=";
            case mir::MirBinaryOp::And:
                return "&&";
            case mir::MirBinaryOp::Or:
                return "||";
        }
        return "???";
    }

    std::string unary_op_to_ts(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg:
                return "-";
            case mir::MirUnaryOp::Not:
                return "!";
            case mir::MirUnaryOp::BitNot:
                return "~";
        }
        return "???";
    }

    std::string type_to_ts(const hir::Type& type) {
        if (type.name == "int")
            return "number";
        if (type.name == "bool")
            return "boolean";
        if (type.name == "char")
            return "string";
        if (type.name == "float")
            return "number";
        if (type.name == "string")
            return "string";
        if (type.name == "void")
            return "void";
        if (type.name.empty())
            return "void";  // 空の型名もvoidとして扱う
        return "any";
    }
};

}  // namespace cm::codegen