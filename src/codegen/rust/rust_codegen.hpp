#pragma once

#include "../../common/debug.hpp"
#include "../../common/debug_messages.hpp"
#include "../../frontend/ast/module.hpp"
#include "../../mir/mir_nodes.hpp"

#include <cmath>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <sstream>
#include <unordered_map>

namespace cm::codegen {

// ============================================================
// Rustコード生成器（FFI対応）
// ============================================================
class RustCodegen {
   private:
    struct Options {
        bool use_ffi = true;         // FFIを使用
        bool generate_cargo = true;  // Cargo.tomlを生成
        bool split_modules = true;   // モジュール分割
        std::string output_dir = ".tmp/rust_build";
        std::string crate_name = "cm_app";
    };

    Options opts;
    std::ostringstream current_output;
    std::unordered_map<std::string, std::string> module_outputs;
    std::vector<std::string> external_crates;
    std::vector<std::string> ffi_functions;
    int indent_level = 0;
    std::map<size_t, std::string> inferred_types;  // 型推論結果を保持
    std::map<size_t, std::string> const_strings;   // 定数文字列の値を保持

   public:
    RustCodegen() = default;
    RustCodegen(const Options& options) : opts(options) {}

    // MIRプログラムをRustコードに変換
    void generate(const mir::MirProgram& program, const std::string& output_path = "") {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Info,
                       debug::msg(new const char* [] {
                           "Starting Rust code generation", "Rustコード生成を開始"
                       }));
        }

        // output_pathが指定されていればそれを使用
        if (!output_path.empty()) {
            opts.output_dir = output_path;
        }

        std::filesystem::create_directories(opts.output_dir);

        if (opts.split_modules) {
            generate_split_modules(program);
        } else {
            generate_single_file(program);
        }

        if (opts.generate_cargo) {
            generate_cargo_toml();
        }

        if (opts.use_ffi) {
            generate_ffi_bindings();
        }

        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Info,
                       "Generated Rust code at: " + opts.output_dir);
        }
    }

   private:
    // 単一ファイル生成
    void generate_single_file(const mir::MirProgram& program) {
        emit_header();
        emit_imports();
        emit_float_format_helper();

        for (const auto& func : program.functions) {
            generate_function(*func);
        }

        std::ofstream out(opts.output_dir + "/main.rs");
        out << current_output.str();
    }

    // モジュール分割生成
    void generate_split_modules(const mir::MirProgram& program) {
        // メインモジュール
        current_output.str("");
        emit_header();
        emit_module_imports();
        emit_float_format_helper();

        // main関数を探す
        for (const auto& func : program.functions) {
            if (func->name == "main") {
                generate_function(*func);
                break;
            }
        }

        std::ofstream main_out(opts.output_dir + "/main.rs");
        main_out << current_output.str();

        // その他の関数をlibに
        current_output.str("");
        emit_header();
        for (const auto& func : program.functions) {
            if (func->name != "main") {
                generate_function_as_pub(*func);
            }
        }

        std::ofstream lib_out(opts.output_dir + "/lib.rs");
        lib_out << current_output.str();
    }

    // ヘッダーコメント
    void emit_header() {
        emit_line("// Generated by Cm compiler");
        emit_line("// WARNING: Do not edit manually");
        emit_line("");
        emit_line("#![allow(dead_code)]");
        emit_line("#![allow(unused_variables)]");
        emit_line("#![allow(non_snake_case)]");
        emit_line("");
    }

    // 浮動小数点フォーマットヘルパー関数を出力
    void emit_float_format_helper() {
        emit_line("// Helper function to format floats like C's %g (6 significant digits)");
        emit_line("fn _fmt_float(f: f64) -> String {");
        indent_level++;
        emit_line("if f == 0.0 { return \"0\".to_string(); }");
        emit_line("let abs_f = f.abs();");
        emit_line("// Use scientific notation for very large or very small numbers");
        emit_line("if abs_f >= 1e6 || (abs_f < 1e-4 && abs_f > 0.0) {");
        indent_level++;
        emit_line("return _fmt_sci(f);");
        indent_level--;
        emit_line("}");
        emit_line("// Calculate precision based on significant digits (like %g with 6 sig figs)");
        emit_line("let log10 = abs_f.log10().floor() as i32;");
        emit_line(
            "let precision = if log10 >= 0 { (5 - log10).max(0) as usize } else { 5 + (-log10) as "
            "usize };");
        emit_line("let s = format!(\"{:.prec$}\", f, prec = precision.min(15));");
        emit_line("let s = s.trim_end_matches('0');");
        emit_line("let s = s.trim_end_matches('.');");
        emit_line("s.to_string()");
        indent_level--;
        emit_line("}");
        emit_line("");
        emit_line("fn _fmt_sci(f: f64) -> String {");
        indent_level++;
        emit_line("let s = format!(\"{:e}\", f);");
        emit_line("// Convert e0 to e+00 format");
        emit_line("if let Some(pos) = s.find('e') {");
        indent_level++;
        emit_line("let (mantissa, exp) = s.split_at(pos);");
        emit_line("let exp_num: i32 = exp[1..].parse().unwrap_or(0);");
        emit_line("format!(\"{}e{:+03}\", mantissa, exp_num)");
        indent_level--;
        emit_line("} else {");
        indent_level++;
        emit_line("s");
        indent_level--;
        emit_line("}");
        indent_level--;
        emit_line("}");
        emit_line("");
        emit_line("fn _fmt_sci_upper(f: f64) -> String {");
        indent_level++;
        emit_line("_fmt_sci(f).replace(\"e\", \"E\")");
        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // インポート
    void emit_imports() {
        emit_line("use std::ffi::{CStr, CString};");
        emit_line("use std::os::raw::c_char;");
        emit_line("");

        if (opts.use_ffi) {
            emit_ffi_imports();
        }
    }

    // モジュールインポート
    void emit_module_imports() {
        for (const auto& module : module_outputs) {
            emit_line("mod " + module.first + ";");
        }
        emit_line("");
    }

    // FFIインポート
    void emit_ffi_imports() {
        emit_line("// FFI imports");
        emit_line("extern \"C\" {");
        indent_level++;

        // 標準ライブラリFFI
        emit_line("fn cm_print_string(s: *const c_char);");
        emit_line("fn cm_print_int(n: i64);");
        emit_line("fn cm_print_float(f: f64);");
        emit_line("fn cm_print_bool(b: bool);");

        // カスタムFFI関数
        for (const auto& ffi : ffi_functions) {
            emit_line(ffi);
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数生成
    void generate_function(const mir::MirFunction& func) {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug,
                       "Generating function: " + func.name);
        }

        std::string signature = build_function_signature(func, false);
        emit_line(signature + " {");
        indent_level++;

        // ローカル変数宣言
        generate_locals(func);

        // ステートマシンで基本ブロック処理
        emit_line("let mut __bb = 0usize;");
        emit_line("loop {");
        indent_level++;
        emit_line("match __bb {");
        indent_level++;

        for (const auto& block : func.basic_blocks) {
            if (block) {
                emit_line(std::to_string(block->id) + " => {");
                indent_level++;
                generate_basic_block(*block, func);
                indent_level--;
                emit_line("}");
            }
        }

        emit_line("_ => panic!(\"Invalid basic block\"),");

        indent_level--;
        emit_line("}");
        indent_level--;
        emit_line("}");

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // パブリック関数生成（FFI用）
    void generate_function_as_pub(const mir::MirFunction& func) {
        // FFIエクスポート用
        if (opts.use_ffi) {
            emit_line("#[no_mangle]");
            emit_line("pub extern \"C\" " + build_ffi_signature(func) + " {");
        } else {
            emit_line("pub " + build_function_signature(func, true) + " {");
        }

        indent_level++;
        generate_locals(func);

        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数シグネチャ構築
    std::string build_function_signature(const mir::MirFunction& func, bool is_pub) {
        std::ostringstream sig;

        if (is_pub)
            sig << "pub ";
        sig << "fn " << mangle_name(func.name) << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first)
                sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_rust(local.type);
        }

        // main関数の特別処理 - Rustのmainは常に()を返す
        if (func.name == "main") {
            sig << ")";  // Rustのmainは()を返す
        } else {
            sig << ") -> " << type_to_rust(func.locals[func.return_local].type);
        }
        return sig.str();
    }

    // FFIシグネチャ構築
    std::string build_ffi_signature(const mir::MirFunction& func) {
        std::ostringstream sig;
        sig << "fn cm_" << func.name << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first)
                sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_ffi(local.type);
        }

        sig << ") -> " << type_to_ffi(func.locals[func.return_local].type);
        return sig.str();
    }

    // ローカル変数生成（型推論機能付き）
    void generate_locals(const mir::MirFunction& func) {
        // 型推論のために文を先読みして定数の型を推定
        // inferred_types はクラスメンバとして保持
        inferred_types.clear();  // 関数ごとにクリア
        const_strings.clear();   // 関数ごとにクリア

        // 複数パス: 定数から直接型を推論、その後伝播
        for (int pass = 0; pass < 3; pass++) {
            for (const auto& block : func.basic_blocks) {
                if (!block)
                    continue;
                for (const auto& stmt : block->statements) {
                    if (!stmt)
                        continue;
                    if (stmt->kind == mir::MirStatement::Assign) {
                        auto& data = std::get<mir::MirStatement::AssignData>(stmt->data);
                        size_t dest_local = data.place.local;

                        // RValueがUseの場合
                        if (data.rvalue && data.rvalue->kind == mir::MirRvalue::Use) {
                            auto& use_data = std::get<mir::MirRvalue::UseData>(data.rvalue->data);
                            if (use_data.operand) {
                                // 定数から型を推論
                                if (use_data.operand->kind == mir::MirOperand::Constant) {
                                    auto& constant =
                                        std::get<mir::MirConstant>(use_data.operand->data);

                                    if (std::holds_alternative<bool>(constant.value)) {
                                        inferred_types[dest_local] = "bool";
                                    } else if (std::holds_alternative<double>(constant.value)) {
                                        double val = std::get<double>(constant.value);
                                        // 浮動小数点リテラルの判定
                                        if (constant.type && constant.type->name == "double") {
                                            inferred_types[dest_local] = "f64";
                                        } else if (constant.type &&
                                                   constant.type->name == "float") {
                                            inferred_types[dest_local] = "f32";
                                        } else if (val != std::floor(val)) {
                                            // 小数点を含む値はデフォルトでf64
                                            inferred_types[dest_local] = "f64";
                                        } else {
                                            // 整数値でも明示的にdouble型の場合はf64
                                            inferred_types[dest_local] = "f64";
                                        }
                                    } else if (std::holds_alternative<char>(constant.value)) {
                                        inferred_types[dest_local] = "char";
                                    } else if (std::holds_alternative<std::string>(
                                                   constant.value)) {
                                        inferred_types[dest_local] = "String";
                                        // 定数文字列の値も保存
                                        const_strings[dest_local] =
                                            std::get<std::string>(constant.value);
                                    }
                                }
                                // 変数から変数への代入で型を伝播
                                else if (use_data.operand->kind == mir::MirOperand::Copy ||
                                         use_data.operand->kind == mir::MirOperand::Move) {
                                    if (auto* place =
                                            std::get_if<mir::MirPlace>(&use_data.operand->data)) {
                                        size_t src_local = place->local;
                                        if (inferred_types.count(src_local)) {
                                            inferred_types[dest_local] = inferred_types[src_local];
                                        }
                                        // 定数文字列の値も伝播
                                        if (const_strings.count(src_local)) {
                                            const_strings[dest_local] = const_strings[src_local];
                                        }
                                    }
                                }
                            }
                        }
                        // 比較演算の結果はbool
                        else if (data.rvalue && data.rvalue->kind == mir::MirRvalue::BinaryOp) {
                            auto& binop_data =
                                std::get<mir::MirRvalue::BinaryOpData>(data.rvalue->data);
                            if (binop_data.op >= mir::MirBinaryOp::Eq &&
                                binop_data.op <= mir::MirBinaryOp::Ge) {
                                inferred_types[dest_local] = "bool";
                            }
                            // 論理演算の結果もbool
                            else if (binop_data.op == mir::MirBinaryOp::And ||
                                     binop_data.op == mir::MirBinaryOp::Or) {
                                inferred_types[dest_local] = "bool";
                            }
                            // 文字列連結の場合、結果はString
                            else if (binop_data.op == mir::MirBinaryOp::Add) {
                                // いずれかのオペランドが文字列型かチェック
                                bool is_string_concat = false;

                                // 左辺のチェック
                                if (binop_data.lhs) {
                                    if (binop_data.lhs->kind == mir::MirOperand::Constant) {
                                        auto& constant =
                                            std::get<mir::MirConstant>(binop_data.lhs->data);
                                        if (std::holds_alternative<std::string>(constant.value)) {
                                            is_string_concat = true;
                                        }
                                    } else if (binop_data.lhs->kind == mir::MirOperand::Copy ||
                                               binop_data.lhs->kind == mir::MirOperand::Move) {
                                        if (auto* place =
                                                std::get_if<mir::MirPlace>(&binop_data.lhs->data)) {
                                            if (inferred_types.count(place->local) &&
                                                inferred_types[place->local] == "String") {
                                                is_string_concat = true;
                                            }
                                        }
                                    }
                                }

                                // 右辺のチェック
                                if (!is_string_concat && binop_data.rhs) {
                                    if (binop_data.rhs->kind == mir::MirOperand::Constant) {
                                        auto& constant =
                                            std::get<mir::MirConstant>(binop_data.rhs->data);
                                        if (std::holds_alternative<std::string>(constant.value)) {
                                            is_string_concat = true;
                                        }
                                    } else if (binop_data.rhs->kind == mir::MirOperand::Copy ||
                                               binop_data.rhs->kind == mir::MirOperand::Move) {
                                        if (auto* place =
                                                std::get_if<mir::MirPlace>(&binop_data.rhs->data)) {
                                            if (inferred_types.count(place->local) &&
                                                inferred_types[place->local] == "String") {
                                                is_string_concat = true;
                                            }
                                        }
                                    }
                                }

                                if (is_string_concat) {
                                    inferred_types[dest_local] = "String";
                                } else {
                                    // 通常の算術演算の型推論
                                    std::string op_type;
                                    if (binop_data.lhs) {
                                        if (binop_data.lhs->kind == mir::MirOperand::Copy ||
                                            binop_data.lhs->kind == mir::MirOperand::Move) {
                                            if (auto* place = std::get_if<mir::MirPlace>(
                                                    &binop_data.lhs->data)) {
                                                if (inferred_types.count(place->local)) {
                                                    op_type = inferred_types[place->local];
                                                }
                                            }
                                        } else if (binop_data.lhs->kind ==
                                                   mir::MirOperand::Constant) {
                                            auto& constant =
                                                std::get<mir::MirConstant>(binop_data.lhs->data);
                                            if (std::holds_alternative<double>(constant.value)) {
                                                op_type = "f64";
                                            } else if (std::holds_alternative<int64_t>(
                                                           constant.value)) {
                                                op_type = "i32";
                                            }
                                        }
                                    }

                                    // 右オペランドの型もチェック（浮動小数点が優先）
                                    if (binop_data.rhs && op_type != "f64") {
                                        if (binop_data.rhs->kind == mir::MirOperand::Copy ||
                                            binop_data.rhs->kind == mir::MirOperand::Move) {
                                            if (auto* place = std::get_if<mir::MirPlace>(
                                                    &binop_data.rhs->data)) {
                                                if (inferred_types.count(place->local)) {
                                                    std::string rhs_type =
                                                        inferred_types[place->local];
                                                    if (rhs_type == "f64" || rhs_type == "f32") {
                                                        op_type = rhs_type;
                                                    }
                                                }
                                            }
                                        } else if (binop_data.rhs->kind ==
                                                   mir::MirOperand::Constant) {
                                            auto& constant =
                                                std::get<mir::MirConstant>(binop_data.rhs->data);
                                            if (std::holds_alternative<double>(constant.value)) {
                                                op_type = "f64";
                                            }
                                        }
                                    }

                                    if (!op_type.empty()) {
                                        inferred_types[dest_local] = op_type;
                                    }
                                }
                            }
                            // 算術演算の場合、オペランドの型を伝播
                            else {
                                // 左オペランドの型を取得
                                std::string op_type;
                                if (binop_data.lhs) {
                                    if (binop_data.lhs->kind == mir::MirOperand::Copy ||
                                        binop_data.lhs->kind == mir::MirOperand::Move) {
                                        if (auto* place =
                                                std::get_if<mir::MirPlace>(&binop_data.lhs->data)) {
                                            if (inferred_types.count(place->local)) {
                                                op_type = inferred_types[place->local];
                                            }
                                        }
                                    } else if (binop_data.lhs->kind == mir::MirOperand::Constant) {
                                        auto& constant =
                                            std::get<mir::MirConstant>(binop_data.lhs->data);
                                        if (std::holds_alternative<double>(constant.value)) {
                                            op_type = "f64";
                                        } else if (std::holds_alternative<int64_t>(
                                                       constant.value)) {
                                            op_type = "i32";
                                        }
                                    }
                                }

                                // 右オペランドの型もチェック（浮動小数点が優先）
                                if (binop_data.rhs && op_type != "f64") {
                                    if (binop_data.rhs->kind == mir::MirOperand::Copy ||
                                        binop_data.rhs->kind == mir::MirOperand::Move) {
                                        if (auto* place =
                                                std::get_if<mir::MirPlace>(&binop_data.rhs->data)) {
                                            if (inferred_types.count(place->local)) {
                                                std::string rhs_type = inferred_types[place->local];
                                                if (rhs_type == "f64" || rhs_type == "f32") {
                                                    op_type = rhs_type;
                                                }
                                            }
                                        }
                                    } else if (binop_data.rhs->kind == mir::MirOperand::Constant) {
                                        auto& constant =
                                            std::get<mir::MirConstant>(binop_data.rhs->data);
                                        if (std::holds_alternative<double>(constant.value)) {
                                            op_type = "f64";
                                        }
                                    }
                                }

                                if (!op_type.empty()) {
                                    inferred_types[dest_local] = op_type;
                                }
                            }
                        }
                        // 単項演算の結果の型を推論
                        else if (data.rvalue && data.rvalue->kind == mir::MirRvalue::UnaryOp) {
                            auto& unop_data =
                                std::get<mir::MirRvalue::UnaryOpData>(data.rvalue->data);
                            // 論理否定の結果はbool
                            if (unop_data.op == mir::MirUnaryOp::Not) {
                                // オペランドの型をチェック
                                if (unop_data.operand) {
                                    if (unop_data.operand->kind == mir::MirOperand::Copy ||
                                        unop_data.operand->kind == mir::MirOperand::Move) {
                                        if (auto* place = std::get_if<mir::MirPlace>(
                                                &unop_data.operand->data)) {
                                            if (inferred_types.count(place->local)) {
                                                std::string src_type = inferred_types[place->local];
                                                // boolの否定はbool
                                                if (src_type == "bool") {
                                                    inferred_types[dest_local] = "bool";
                                                }
                                                // 整数の否定（ビット反転）は同じ型
                                                else if (src_type == "i32" || src_type == "i64") {
                                                    inferred_types[dest_local] = src_type;
                                                }
                                            }
                                        }
                                    } else if (unop_data.operand->kind ==
                                               mir::MirOperand::Constant) {
                                        auto& constant =
                                            std::get<mir::MirConstant>(unop_data.operand->data);
                                        if (std::holds_alternative<bool>(constant.value)) {
                                            inferred_types[dest_local] = "bool";
                                        }
                                    }
                                }
                            }
                            // 負の符号の場合、元の型を保持
                            else if (unop_data.op == mir::MirUnaryOp::Neg) {
                                if (unop_data.operand) {
                                    if (unop_data.operand->kind == mir::MirOperand::Copy ||
                                        unop_data.operand->kind == mir::MirOperand::Move) {
                                        if (auto* place = std::get_if<mir::MirPlace>(
                                                &unop_data.operand->data)) {
                                            if (inferred_types.count(place->local)) {
                                                inferred_types[dest_local] =
                                                    inferred_types[place->local];
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // フォーマット変換の結果は常にString
                        else if (data.rvalue &&
                                 data.rvalue->kind == mir::MirRvalue::FormatConvert) {
                            inferred_types[dest_local] = "String";
                        }
                    }
                }
            }
        }

        // mainの戻り値変数を明示的に宣言（main関数の特別処理）
        if (func.name == "main") {
            // _0は常にi32型として宣言（exit code用）
            // void mainの場合は0で初期化
            bool is_void = true;
            if (func.return_local < func.locals.size()) {
                auto return_type = func.locals[func.return_local].type;
                if (return_type && return_type->name != "void" &&
                    return_type->kind != hir::TypeKind::Void) {
                    is_void = false;
                }
            }

            if (is_void) {
                emit_line("let mut _0: i32 = 0;");
            } else {
                emit_line("let mut _0: i32;");
            }
        }

        for (const auto& local : func.locals) {
            // 引数とreturn値以外を宣言
            bool is_arg = false;
            for (auto arg_id : func.arg_locals) {
                if (arg_id == local.id) {
                    is_arg = true;
                    break;
                }
            }

            if (!is_arg && local.id != func.return_local) {
                std::string mut_str = local.is_mutable ? "mut " : "";
                std::string type_str;

                // 型情報がある場合はそれを使用
                if (local.type) {
                    type_str = type_to_rust(local.type);
                    // "()"が返ってきた場合は型情報なし
                    if (type_str == "()") {
                        type_str.clear();
                    }
                }

                // 型推論の結果がある場合はそれを使用
                if (type_str.empty() && inferred_types.count(local.id)) {
                    type_str = inferred_types[local.id];
                }

                // どちらもない場合はデフォルトでi32
                if (type_str.empty()) {
                    type_str = "i32";
                }

                // デフォルト値で初期化（Rustのborrow checkerを満たすため）
                std::string default_val;
                if (type_str == "bool") {
                    default_val = " = false";
                } else if (type_str == "i32" || type_str == "i64" || type_str == "u32" ||
                           type_str == "u64") {
                    default_val = " = 0";
                } else if (type_str == "f32" || type_str == "f64") {
                    default_val = " = 0.0";
                } else if (type_str == "String") {
                    default_val = " = String::new()";
                } else if (type_str == "char") {
                    default_val = " = '\\0'";
                } else {
                    default_val = "";  // その他の型はデフォルト値なし
                }

                emit_line("let " + mut_str + "_" + std::to_string(local.id) + ": " + type_str +
                          default_val + ";");
            }
        }

        if (!func.locals.empty()) {
            emit_line("");
        }
    }

    // 基本ブロック生成
    void generate_basic_block(const mir::BasicBlock& block, const mir::MirFunction& func) {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Trace,
                       "Generating basic block: bb" + std::to_string(block.id));
        }

        // ブロックラベル（将来のgoto用）
        emit_line("// bb" + std::to_string(block.id) + ":");

        // 文を生成
        for (const auto& stmt : block.statements) {
            generate_statement(*stmt, func);
        }

        // 終端命令を生成
        if (block.terminator) {
            generate_terminator(*block.terminator, func);
        }
    }

    // 文の生成
    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                std::string lhs = place_to_rust(data.place);
                std::string rhs = rvalue_to_rust(*data.rvalue);

                // 文字列リテラルをString型に代入する場合の特別処理
                if (data.rvalue && data.rvalue->kind == mir::MirRvalue::Use) {
                    auto& use_data = std::get<mir::MirRvalue::UseData>(data.rvalue->data);
                    if (use_data.operand && use_data.operand->kind == mir::MirOperand::Constant) {
                        auto& constant = std::get<mir::MirConstant>(use_data.operand->data);
                        if (std::holds_alternative<std::string>(constant.value)) {
                            // 対象変数の型を確認
                            mir::LocalId dest_local = data.place.local;
                            if (inferred_types.count(dest_local) &&
                                inferred_types[dest_local] == "String") {
                                rhs += ".to_string()";
                            }
                        }
                    }
                }

                emit_line(lhs + " = " + rhs + ";");
                break;
            }
            case mir::MirStatement::StorageLive: {
                // Rustでは明示的なStorageLiveは不要
                break;
            }
            case mir::MirStatement::StorageDead: {
                // Rustでは明示的なStorageDeadは不要
                break;
            }
            case mir::MirStatement::Nop: {
                emit_line("// nop");
                break;
            }
        }
    }

    // 終端命令の生成
    void generate_terminator(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                // main関数の特別処理 - 戻り値をexit codeとして使用
                if (func.name == "main" && func.return_local < func.locals.size()) {
                    auto return_type = func.locals[func.return_local].type;
                    if (return_type && return_type->name != "void") {
                        emit_line("std::process::exit(_" + std::to_string(func.return_local) +
                                  ");");
                    } else {
                        emit_line("return;");
                    }
                } else if (func.return_local != 0) {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                } else {
                    emit_line("return;");
                }
                break;

            case mir::MirTerminator::Goto: {
                auto target = std::get<mir::MirTerminator::GotoData>(term.data).target;
                emit_line("__bb = " + std::to_string(target) + ";");
                emit_line("continue;");
                break;
            }

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("match " + operand_to_rust(*data.discriminant) + " {");
                indent_level++;

                // 判別対象の型を確認
                bool is_bool = false;
                if (data.discriminant) {
                    if (data.discriminant->kind == mir::MirOperand::Copy ||
                        data.discriminant->kind == mir::MirOperand::Move) {
                        if (auto* place = std::get_if<mir::MirPlace>(&data.discriminant->data)) {
                            if (inferred_types.count(place->local)) {
                                is_bool = (inferred_types[place->local] == "bool");
                            }
                        }
                    } else if (data.discriminant->kind == mir::MirOperand::Constant) {
                        auto& constant = std::get<mir::MirConstant>(data.discriminant->data);
                        is_bool = std::holds_alternative<bool>(constant.value);
                    }
                }

                for (const auto& [value, target] : data.targets) {
                    // bool型の場合はtrue/falseを使用
                    std::string match_pattern;
                    if (is_bool) {
                        match_pattern = (value == 1) ? "true" : "false";
                    } else {
                        match_pattern = std::to_string(value);
                    }

                    emit_line(match_pattern + " => {");
                    indent_level++;
                    emit_line("__bb = " + std::to_string(target) + ";");
                    emit_line("continue;");
                    indent_level--;
                    emit_line("},");
                }

                emit_line("_ => {");
                indent_level++;
                emit_line("__bb = " + std::to_string(data.otherwise) + ";");
                emit_line("continue;");
                indent_level--;
                emit_line("}");

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);

                // 関数名を取得（組み込み関数の特別処理）
                std::string func_name;

                // FunctionRefの場合の処理
                if (data.func && data.func->kind == mir::MirOperand::FunctionRef) {
                    if (auto* fn_name = std::get_if<std::string>(&data.func->data)) {
                        // std::io::println/print を Rustのマクロにマップ
                        if (*fn_name == "std::io::println" || *fn_name == "println") {
                            func_name = "println!";
                        } else if (*fn_name == "std::io::print" || *fn_name == "print") {
                            func_name = "print!";
                        } else {
                            func_name = *fn_name;
                        }
                    }
                }
                // Constantの場合の処理（後方互換性）
                else if (data.func && data.func->kind == mir::MirOperand::Constant) {
                    if (auto* constant = std::get_if<mir::MirConstant>(&data.func->data)) {
                        if (auto* s = std::get_if<std::string>(&constant->value)) {
                            // 組み込み関数の特別処理
                            if (*s == "println") {
                                func_name = "println!";  // Rustのマクロに変換
                            } else if (*s == "print") {
                                func_name = "print!";  // Rustのマクロに変換
                            } else {
                                func_name = *s;  // 通常の関数名
                            }
                        }
                    }
                }

                // 関数名が取得できなかった場合はデフォルト処理
                if (func_name.empty()) {
                    func_name = operand_to_rust(*data.func);
                }

                // 引数リストを構築
                std::string call;

                // println!/print!の特別処理
                if (func_name == "println!" || func_name == "print!") {
                    if (!data.args.empty()) {
                        // 複数引数の場合（文字列補間を使用している場合）
                        if (data.args.size() > 1) {
                            // 第1引数の文字列から{変数名}を{}に置換したフォーマット文字列を作成
                            // 第1引数の元の値を取得して処理（変数の場合は型推論結果から復元）
                            std::string format_str = "";
                            bool has_format_str = false;

                            // 第1引数が定数文字列の場合
                            if (data.args[0]->kind == mir::MirOperand::Constant) {
                                if (auto* constant =
                                        std::get_if<mir::MirConstant>(&data.args[0]->data)) {
                                    if (auto* str_val =
                                            std::get_if<std::string>(&constant->value)) {
                                        format_str = *str_val;
                                        has_format_str = true;
                                    }
                                }
                            }
                            // 第1引数が変数の場合、保存された定数文字列を確認
                            else if (data.args[0]->kind == mir::MirOperand::Copy ||
                                     data.args[0]->kind == mir::MirOperand::Move) {
                                if (auto* place = std::get_if<mir::MirPlace>(&data.args[0]->data)) {
                                    // 定数文字列が保存されているか確認
                                    if (const_strings.count(place->local)) {
                                        format_str = const_strings[place->local];
                                        has_format_str = true;
                                    }
                                }
                            }

                            // フォーマット文字列が取得できた場合、{変数名}を{}に置換
                            if (has_format_str) {
                                size_t pos = 0;
                                while ((pos = format_str.find('{', pos)) != std::string::npos) {
                                    // {{の場合はスキップ
                                    if (pos + 1 < format_str.size() && format_str[pos + 1] == '{') {
                                        pos += 2;
                                        continue;
                                    }

                                    size_t end = format_str.find('}', pos);
                                    if (end != std::string::npos) {
                                        std::string placeholder =
                                            format_str.substr(pos + 1, end - pos - 1);
                                        // フォーマット指定子が含まれている場合はそのまま保持
                                        // 変数名のみの場合は{}に置換
                                        if (!placeholder.empty()) {
                                            // :で始まる場合はフォーマット指定子なのでそのまま保持
                                            if (placeholder[0] == ':' ||
                                                std::isdigit(placeholder[0])) {
                                                // フォーマット指定子はそのまま
                                                pos = end + 1;
                                            } else if (placeholder.find(':') != std::string::npos) {
                                                // 変数名:フォーマット の形式は、変数名部分を削除
                                                size_t colon_pos = placeholder.find(':');
                                                std::string format_spec =
                                                    placeholder.substr(colon_pos);
                                                format_str.replace(pos, end - pos + 1,
                                                                   "{" + format_spec + "}");
                                                pos += format_spec.length() + 2;
                                            } else {
                                                // 単純な変数名は{}に置換
                                                format_str.replace(pos, end - pos + 1, "{}");
                                                pos += 2;  // {}の長さ
                                            }
                                        } else {
                                            // 空の{}はそのまま
                                            pos = end + 1;
                                        }
                                    } else {
                                        break;
                                    }
                                }
                            } else {
                                // フォーマット文字列が取得できない場合、すべての引数の数だけ{}を作成（スペースなし）
                                for (size_t i = 0; i < data.args.size(); ++i) {
                                    format_str += "{}";
                                }
                            }

                            // println!マクロの呼び出しを生成
                            // has_format_strがtrueの場合は第1引数がフォーマット文字列
                            // {}または{:で始まるフォーマット指定子を含む場合はフォーマット文字列
                            bool is_format_string =
                                has_format_str && (format_str.find("{}") != std::string::npos ||
                                                   format_str.find("{:") != std::string::npos);

                            if (is_format_string) {
                                // 科学表記と浮動小数点のカスタム処理
                                // {:e}を{}に置き換え、対応する引数を_fmt_sciでラップ
                                // {:E}を{}に置き換え、対応する引数を_fmt_sci_upperでラップ

                                // フォーマット指定子を解析してインデックスを特定
                                std::vector<std::pair<std::string, size_t>>
                                    format_specs;  // (spec, arg_index)
                                size_t arg_idx = 1;  // 引数は1から始まる（0はフォーマット文字列）
                                std::string modified_format = "";
                                size_t pos = 0;
                                while (pos < format_str.length()) {
                                    if (format_str[pos] == '{') {
                                        if (pos + 1 < format_str.length() &&
                                            format_str[pos + 1] == '{') {
                                            modified_format += "{{";
                                            pos += 2;
                                            continue;
                                        }
                                        size_t end = format_str.find('}', pos);
                                        if (end != std::string::npos) {
                                            std::string placeholder =
                                                format_str.substr(pos, end - pos + 1);
                                            std::string spec =
                                                format_str.substr(pos + 1, end - pos - 1);

                                            if (spec == ":e" || spec == ":E") {
                                                format_specs.push_back({spec, arg_idx});
                                                modified_format += "{}";
                                            } else if (spec.empty() || spec[0] != ':') {
                                                // デフォルト浮動小数点
                                                if (arg_idx < data.args.size()) {
                                                    // 浮動小数点チェック
                                                    bool is_float = false;
                                                    if (data.args[arg_idx]->kind ==
                                                            mir::MirOperand::Copy ||
                                                        data.args[arg_idx]->kind ==
                                                            mir::MirOperand::Move) {
                                                        if (auto* place =
                                                                std::get_if<mir::MirPlace>(
                                                                    &data.args[arg_idx]->data)) {
                                                            if (inferred_types.count(
                                                                    place->local)) {
                                                                std::string t =
                                                                    inferred_types[place->local];
                                                                is_float =
                                                                    (t == "f64" || t == "f32");
                                                            }
                                                        }
                                                    }
                                                    if (is_float) {
                                                        format_specs.push_back({"float", arg_idx});
                                                    }
                                                }
                                                modified_format += placeholder;
                                            } else {
                                                modified_format += placeholder;
                                            }
                                            arg_idx++;
                                            pos = end + 1;
                                            continue;
                                        }
                                    }
                                    if (format_str[pos] == '}' && pos + 1 < format_str.length() &&
                                        format_str[pos + 1] == '}') {
                                        modified_format += "}}";
                                        pos += 2;
                                        continue;
                                    }
                                    modified_format += format_str[pos];
                                    pos++;
                                }

                                // フォーマット文字列として使用し、残りの引数をパラメータとして追加
                                call = func_name + "(\"" + modified_format + "\"";
                                // 第1引数はすでにフォーマット文字列として使用したので、第2引数から追加
                                for (size_t i = 1; i < data.args.size(); ++i) {
                                    std::string arg_str = operand_to_rust(*data.args[i]);
                                    // 科学表記または浮動小数点の変換が必要かチェック
                                    for (const auto& [spec, idx] : format_specs) {
                                        if (idx == i) {
                                            if (spec == ":e") {
                                                arg_str = "_fmt_sci(" + arg_str + ")";
                                            } else if (spec == ":E") {
                                                arg_str = "_fmt_sci_upper(" + arg_str + ")";
                                            } else if (spec == "float") {
                                                arg_str = "_fmt_float(" + arg_str + ")";
                                            }
                                            break;
                                        }
                                    }
                                    call += ", " + arg_str;
                                }
                                call += ")";
                            } else {
                                // フォーマット文字列でない場合は、すべての引数の数だけ{}を作成
                                std::string all_format_str = "";
                                for (size_t i = 0; i < data.args.size(); ++i) {
                                    all_format_str += "{}";
                                }
                                call = func_name + "(\"" + all_format_str + "\"";
                                // すべての引数を追加
                                for (size_t i = 0; i < data.args.size(); ++i) {
                                    call += ", " + operand_to_rust(*data.args[i]);
                                }
                                call += ")";
                            }
                        } else {
                            // 単一引数の場合
                            if (data.args[0]->kind == mir::MirOperand::Constant) {
                                if (auto* constant =
                                        std::get_if<mir::MirConstant>(&data.args[0]->data)) {
                                    if (std::holds_alternative<std::string>(constant->value)) {
                                        // 文字列リテラルはそのまま
                                        call = func_name + "(" + constant_to_rust(*constant) + ")";
                                    } else if (std::holds_alternative<double>(constant->value)) {
                                        // 浮動小数点はカスタムフォーマット（末尾ゼロを除去）
                                        call = func_name + "(\"{}\", " +
                                               operand_to_rust(*data.args[0]) + ")";
                                    } else {
                                        // その他の定数は"{}"フォーマットで
                                        call = func_name + "(\"{}\", " +
                                               operand_to_rust(*data.args[0]) + ")";
                                    }
                                }
                            } else {
                                // 変数の場合
                                // 型情報を使ってフォーマットを決定
                                if (data.args[0]->kind == mir::MirOperand::Copy ||
                                    data.args[0]->kind == mir::MirOperand::Move) {
                                    if (auto* place =
                                            std::get_if<mir::MirPlace>(&data.args[0]->data)) {
                                        if (inferred_types.count(place->local)) {
                                            std::string var_type = inferred_types[place->local];
                                            if (var_type == "f64" || var_type == "f32") {
                                                // 浮動小数点はカスタムフォーマット（末尾ゼロを除去）
                                                call = func_name + "(\"{}\", _fmt_float(" +
                                                       operand_to_rust(*data.args[0]) + "))";
                                            } else {
                                                call = func_name + "(\"{}\", " +
                                                       operand_to_rust(*data.args[0]) + ")";
                                            }
                                        } else {
                                            call = func_name + "(\"{}\", " +
                                                   operand_to_rust(*data.args[0]) + ")";
                                        }
                                    } else {
                                        call = func_name + "(\"{}\", " +
                                               operand_to_rust(*data.args[0]) + ")";
                                    }
                                } else {
                                    call = func_name + "(\"{}\", " +
                                           operand_to_rust(*data.args[0]) + ")";
                                }
                            }
                        }
                    } else {
                        // 引数なし
                        call = func_name + "()";
                    }
                } else {
                    // 通常の関数呼び出し
                    call = func_name + "(";
                    bool first = true;
                    for (const auto& arg : data.args) {
                        if (!first)
                            call += ", ";
                        first = false;
                        call += operand_to_rust(*arg);
                    }
                    call += ")";
                }

                // println!/print!は値を返さないので、代入はスキップ
                if (data.destination && func_name != "println!" && func_name != "print!") {
                    emit_line(place_to_rust(*data.destination) + " = " + call + ";");
                } else {
                    emit_line(call + ";");
                }

                // 次のブロックへ遷移
                emit_line("__bb = " + std::to_string(data.success) + ";");
                emit_line("continue;");
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("unreachable!();");
                break;
        }
    }

    // Place → Rust
    std::string place_to_rust(const mir::MirPlace& place) {
        std::string result = "_" + std::to_string(place.local);

        for (const auto& proj : place.projections) {
            switch (proj.kind) {
                case mir::ProjectionKind::Field:
                    result += "." + std::to_string(proj.field_id);
                    break;
                case mir::ProjectionKind::Index:
                    result += "[_" + std::to_string(proj.index_local) + "]";
                    break;
                case mir::ProjectionKind::Deref:
                    result = "(*" + result + ")";
                    break;
            }
        }

        return result;
    }

    // Operand → Rust
    std::string operand_to_rust(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Move:
            case mir::MirOperand::Copy:
                if (auto* place = std::get_if<mir::MirPlace>(&op.data)) {
                    return place_to_rust(*place);
                }
                break;
            case mir::MirOperand::Constant:
                if (auto* constant = std::get_if<mir::MirConstant>(&op.data)) {
                    return constant_to_rust(*constant);
                }
                break;
            case mir::MirOperand::FunctionRef:
                if (auto* func_name = std::get_if<std::string>(&op.data)) {
                    // std::io::println/print を Rustのマクロにマップ
                    // 注意: printlnはbuiltinではなく、必ずstd::ioからインポートする必要があります
                    if (*func_name == "std::io::println" || *func_name == "println") {
                        return "println!";
                    } else if (*func_name == "std::io::print" || *func_name == "print") {
                        return "print!";
                    }
                    // 通常の関数名
                    return *func_name;
                }
                break;
        }
        return "()";
    }

    // Rvalue → Rust
    std::string rvalue_to_rust(const mir::MirRvalue& rv) {
        switch (rv.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rv.data);
                return operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rv.data);

                // 文字列連結の特別処理
                if (data.op == mir::MirBinaryOp::Add) {
                    // 左側が文字列型かチェック
                    bool lhs_is_string = false;
                    bool rhs_is_string = false;

                    // オペランドから型を推論
                    if (data.lhs->kind == mir::MirOperand::Copy ||
                        data.lhs->kind == mir::MirOperand::Move) {
                        if (auto* place = std::get_if<mir::MirPlace>(&data.lhs->data)) {
                            if (inferred_types.count(place->local)) {
                                auto& type = inferred_types[place->local];
                                lhs_is_string = (type == "String" || type == "&str");
                            }
                        }
                    }

                    if (data.rhs->kind == mir::MirOperand::Copy ||
                        data.rhs->kind == mir::MirOperand::Move) {
                        if (auto* place = std::get_if<mir::MirPlace>(&data.rhs->data)) {
                            if (inferred_types.count(place->local)) {
                                auto& type = inferred_types[place->local];
                                rhs_is_string = (type == "String" || type == "&str");
                            }
                        }
                    }

                    // 文字列連結の場合はformat!マクロを使用
                    if (lhs_is_string || rhs_is_string) {
                        return "format!(\"{}{}\", " + operand_to_rust(*data.lhs) + ", " +
                               operand_to_rust(*data.rhs) + ")";
                    }
                }

                // 通常の二項演算
                return "(" + operand_to_rust(*data.lhs) + " " + binary_op_to_rust(data.op) + " " +
                       operand_to_rust(*data.rhs) + ")";
            }
            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rv.data);
                return unary_op_to_rust(data.op) + operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::Ref: {
                auto& data = std::get<mir::MirRvalue::RefData>(rv.data);
                std::string prefix = data.borrow == mir::BorrowKind::Shared ? "&" : "&mut ";
                return prefix + place_to_rust(data.place);
            }
            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rv.data);
                return operand_to_rust(*data.operand) + " as " + type_to_rust(data.target_type);
            }
            case mir::MirRvalue::FormatConvert: {
                auto& data = std::get<mir::MirRvalue::FormatConvertData>(rv.data);
                std::string operand = operand_to_rust(*data.operand);

                // フォーマット指定子に応じて変換
                if (data.format_spec == "x") {
                    return "format!(\"{:x}\", " + operand + ")";
                } else if (data.format_spec == "X") {
                    return "format!(\"{:X}\", " + operand + ")";
                } else if (data.format_spec == "b") {
                    return "format!(\"{:b}\", " + operand + ")";
                } else if (data.format_spec == "o") {
                    return "format!(\"{:o}\", " + operand + ")";
                } else if (data.format_spec.size() > 1 && data.format_spec[0] == '.') {
                    // 浮動小数点精度
                    std::string precision = data.format_spec.substr(1);
                    return "format!(\"{:." + precision + "}\", " + operand + ")";
                } else {
                    // デフォルト：文字列変換
                    return "format!(\"{}\", " + operand + ")";
                }
            }
            default:
                return "()";
        }
    }

    // 定数 → Rust
    std::string constant_to_rust(const mir::MirConstant& constant) {
        if (std::holds_alternative<std::monostate>(constant.value)) {
            return "()";
        } else if (auto* b = std::get_if<bool>(&constant.value)) {
            return *b ? "true" : "false";
        } else if (auto* i = std::get_if<int64_t>(&constant.value)) {
            return std::to_string(*i);
        } else if (auto* d = std::get_if<double>(&constant.value)) {
            return std::to_string(*d);
        } else if (auto* c = std::get_if<char>(&constant.value)) {
            return "'" + std::string(1, *c) + "'";
        } else if (auto* s = std::get_if<std::string>(&constant.value)) {
            return "\"" + escape_string(*s) + "\"";
        }
        return "()";
    }

    // 型 → Rust
    std::string type_to_rust(hir::TypePtr type) {
        if (!type) {
            // 型情報がない場合はエラー
            if (debug::g_debug_mode) {
                debug::log(debug::Stage::CodegenRust, debug::Level::Error,
                           "Missing type information - this is a compiler bug!");
            }
            return "()";  // Unit型を返す（本来はエラーとすべき）
        }

        if (type->name == "int")
            return "i32";
        if (type->name == "uint")
            return "u32";
        if (type->name == "long")
            return "i64";
        if (type->name == "ulong")
            return "u64";
        if (type->name == "float")
            return "f32";
        if (type->name == "double")
            return "f64";
        if (type->name == "bool")
            return "bool";
        if (type->name == "char")
            return "char";
        if (type->name == "void")
            return "()";
        if (type->name == "string")
            return "String";

        return type->name;
    }

    // 型 → FFI
    std::string type_to_ffi(hir::TypePtr type) {
        if (!type)
            return "()";

        if (type->name == "string")
            return "*const c_char";
        // その他は通常のRust型と同じ
        return type_to_rust(type);
    }

    // 二項演算子 → Rust
    std::string binary_op_to_rust(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add:
                return "+";
            case mir::MirBinaryOp::Sub:
                return "-";
            case mir::MirBinaryOp::Mul:
                return "*";
            case mir::MirBinaryOp::Div:
                return "/";
            case mir::MirBinaryOp::Mod:
                return "%";
            case mir::MirBinaryOp::BitAnd:
                return "&";
            case mir::MirBinaryOp::BitOr:
                return "|";
            case mir::MirBinaryOp::BitXor:
                return "^";
            case mir::MirBinaryOp::Shl:
                return "<<";
            case mir::MirBinaryOp::Shr:
                return ">>";
            case mir::MirBinaryOp::Eq:
                return "==";
            case mir::MirBinaryOp::Ne:
                return "!=";
            case mir::MirBinaryOp::Lt:
                return "<";
            case mir::MirBinaryOp::Le:
                return "<=";
            case mir::MirBinaryOp::Gt:
                return ">";
            case mir::MirBinaryOp::Ge:
                return ">=";
            case mir::MirBinaryOp::And:
                return "&&";
            case mir::MirBinaryOp::Or:
                return "||";
            default:
                return "?";
        }
    }

    // 単項演算子 → Rust
    std::string unary_op_to_rust(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg:
                return "-";
            case mir::MirUnaryOp::Not:
                return "!";
            case mir::MirUnaryOp::BitNot:
                return "!";  // Rustでは!がビット反転
            default:
                return "?";
        }
    }

    // 名前マングリング
    std::string mangle_name(const std::string& name) {
        // main関数は特別扱い
        if (name == "main")
            return "main";

        // Cm_ プレフィックスを付ける
        return "cm_" + name;
    }

    // 文字列エスケープ
    std::string escape_string(const std::string& s) {
        std::string result;
        size_t i = 0;
        while (i < s.length()) {
            // MIRレベルのエスケープシーケンス {{ と }} を単一の { と } に変換
            if (i + 1 < s.length()) {
                if (s[i] == '{' && s[i + 1] == '{') {
                    result += '{';
                    i += 2;
                    continue;
                } else if (s[i] == '}' && s[i + 1] == '}') {
                    result += '}';
                    i += 2;
                    continue;
                }
            }

            // 通常の文字エスケープ
            char c = s[i];
            switch (c) {
                case '"':
                    result += "\\\"";
                    break;
                case '\\':
                    result += "\\\\";
                    break;
                case '\n':
                    result += "\\n";
                    break;
                case '\r':
                    result += "\\r";
                    break;
                case '\t':
                    result += "\\t";
                    break;
                default:
                    result += c;
                    break;
            }
            i++;
        }
        return result;
    }

    // Cargo.toml生成
    void generate_cargo_toml() {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug, "Generating Cargo.toml");
        }

        std::ofstream out(opts.output_dir + "/Cargo.toml");

        out << "[package]\n";
        out << "name = \"" << opts.crate_name << "\"\n";
        out << "version = \"0.1.0\"\n";
        out << "edition = \"2021\"\n\n";

        out << "[dependencies]\n";
        for (const auto& crate_ : external_crates) {
            out << crate_ << "\n";
        }
        out << "\n";

        out << "[profile.dev]\n";
        out << "opt-level = 0\n";
        out << "incremental = true\n\n";

        out << "[profile.release]\n";
        out << "opt-level = 3\n";
        out << "lto = true\n";
    }

    // FFIバインディング生成
    void generate_ffi_bindings() {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug, "Generating FFI bindings");
        }

        std::ofstream out(opts.output_dir + "/ffi.rs");

        out << "// FFI bindings for Cm standard library\n\n";
        out << "use std::ffi::{CStr, CString};\n";
        out << "use std::os::raw::c_char;\n\n";

        // print関数の実装
        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_string(s: *const c_char) {\n";
        out << "    let s = unsafe { CStr::from_ptr(s).to_string_lossy() };\n";
        out << "    print!(\"{}\", s);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_int(n: i64) {\n";
        out << "    print!(\"{}\", n);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_float(f: f64) {\n";
        out << "    print!(\"{}\", f);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_bool(b: bool) {\n";
        out << "    print!(\"{}\", b);\n";
        out << "}\n\n";
    }

    // 行出力
    void emit_line(const std::string& line) {
        for (int i = 0; i < indent_level; ++i) {
            current_output << "    ";
        }
        current_output << line << "\n";
    }

    void emit(const std::string& str) { current_output << str; }
};

}  // namespace cm::codegen