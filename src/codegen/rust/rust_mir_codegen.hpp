#pragma once

#include "rust_mir.hpp"

#include <filesystem>
#include <fstream>
#include <sstream>

namespace cm {
namespace rust_mir {

// ============================================================
// Rust-MIR → Rustコード 生成器
// ============================================================
class RustMirCodegen {
   public:
    struct Options {
        std::string output_dir = ".tmp/rust_output";
        std::string crate_name = "cm_output";
        bool generate_cargo = true;
    };

    RustMirCodegen() = default;
    RustMirCodegen(const Options& opts) : options(opts) {}

    void generate(const Program& program, const std::string& output_path = "") {
        if (!output_path.empty()) {
            options.output_dir = output_path;
        }

        std::filesystem::create_directories(options.output_dir);

        // main.rs を生成
        std::ofstream out(options.output_dir + "/main.rs");
        out << generateCode(program);
        out.close();

        // Cargo.toml を生成
        if (options.generate_cargo) {
            generateCargoToml();
        }
    }

    std::string generateCode(const Program& program) {
        std::ostringstream out;

        // ヘッダコメント
        out << "// Generated by Cm compiler\n";
        out << "// Do not edit manually\n\n";

        // 関数を生成
        for (const auto& func : program.functions) {
            out << generateFunction(func);
            out << "\n";
        }

        return out.str();
    }

   private:
    Options options;
    int indent_level = 0;

    std::string generateFunction(const Function& func) {
        std::ostringstream out;

        // 関数シグネチャ
        out << "fn " << func.name << "(";

        // パラメータ
        for (size_t i = 0; i < func.parameters.size(); ++i) {
            if (i > 0)
                out << ", ";
            out << func.parameters[i].second << ": " << typeToString(func.parameters[i].first);
        }

        out << ")";

        // 戻り値型 (mainは特別扱い)
        if (func.is_main) {
            // Rustのmainは -> () または戻り値なし
            out << " {\n";
        } else if (func.return_type != Type::VOID) {
            out << " -> " << typeToString(func.return_type) << " {\n";
        } else {
            out << " {\n";
        }

        indent_level++;

        // 本体
        for (const auto& stmt : func.body) {
            // main関数の場合、return 0; はスキップ（Rustのmainはvoid）
            if (func.is_main && stmt.kind == StatementKind::RETURN) {
                if (stmt.return_data.value) {
                    // return 0; の場合はスキップ
                    const auto& val = stmt.return_data.value.value();
                    if (val.kind == Expression::LITERAL && val.value == "0") {
                        continue;
                    }
                    // それ以外の値の場合はstd::process::exit()を使用
                    out << std::string(indent_level * 4, ' ');
                    out << "std::process::exit(" << exprToString(val) << ");\n";
                    continue;
                }
            }
            out << generateStatement(stmt);
        }

        indent_level--;
        out << "}\n";

        return out.str();
    }

    std::string generateStatement(const Statement& stmt) {
        std::ostringstream out;
        std::string indent(indent_level * 4, ' ');

        switch (stmt.kind) {
            case StatementKind::LET:
            case StatementKind::LET_MUT: {
                out << indent;
                out << "let ";
                if (stmt.let_data.is_mutable) {
                    out << "mut ";
                }
                out << stmt.let_data.name;

                // 型アノテーション (必要な場合のみ)
                if (stmt.let_data.type != Type::I32 || !stmt.let_data.init) {
                    out << ": " << typeToString(stmt.let_data.type);
                }

                if (stmt.let_data.init) {
                    std::string val = exprToString(stmt.let_data.init.value());
                    // String型に&strリテラルを代入する場合は.to_string()を追加
                    if (stmt.let_data.type == Type::STRING &&
                        stmt.let_data.init->kind == Expression::LITERAL &&
                        (stmt.let_data.init->type == Type::STR_SLICE ||
                         stmt.let_data.init->type == Type::STR_REF)) {
                        val += ".to_string()";
                    }
                    out << " = " << val;
                }
                out << ";\n";
                break;
            }

            case StatementKind::ASSIGNMENT: {
                out << indent << stmt.assign_data.target << " = "
                    << exprToString(stmt.assign_data.value) << ";\n";
                break;
            }

            case StatementKind::PRINTLN: {
                out << indent;
                if (stmt.println_data.with_newline) {
                    out << "println!(";
                } else {
                    out << "print!(";
                }

                // フォーマット文字列
                out << "\"" << stmt.println_data.format << "\"";

                // 引数
                for (const auto& arg : stmt.println_data.args) {
                    out << ", " << exprToString(arg);
                }

                out << ");\n";
                break;
            }

            case StatementKind::EXPRESSION: {
                out << indent << exprToString(stmt.expr_data) << ";\n";
                break;
            }

            case StatementKind::IF_ELSE: {
                out << indent << "if " << exprToString(stmt.if_data->condition) << " {\n";
                indent_level++;
                for (const auto& inner : stmt.if_data->then_body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                if (!stmt.if_data->else_body.empty()) {
                    out << indent << "} else {\n";
                    indent_level++;
                    for (const auto& inner : stmt.if_data->else_body) {
                        out << generateStatement(*inner);
                    }
                    indent_level--;
                }
                out << indent << "}\n";
                break;
            }

            case StatementKind::WHILE: {
                out << indent << "while " << exprToString(stmt.while_data->condition) << " {\n";
                indent_level++;
                for (const auto& inner : stmt.while_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::FOR: {
                out << indent << "for " << stmt.for_data->var_name << " in "
                    << exprToString(stmt.for_data->range_start);
                if (stmt.for_data->inclusive) {
                    out << "..=";
                } else {
                    out << "..";
                }
                out << exprToString(stmt.for_data->range_end) << " {\n";
                indent_level++;
                for (const auto& inner : stmt.for_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::LOOP: {
                out << indent << "loop {\n";
                indent_level++;
                for (const auto& inner : stmt.loop_data->body) {
                    out << generateStatement(*inner);
                }
                indent_level--;
                out << indent << "}\n";
                break;
            }

            case StatementKind::RETURN: {
                out << indent;
                if (stmt.return_data.value) {
                    out << "return " << exprToString(stmt.return_data.value.value());
                } else {
                    out << "return";
                }
                out << ";\n";
                break;
            }

            case StatementKind::BREAK: {
                out << indent << "break;\n";
                break;
            }

            case StatementKind::CONTINUE: {
                out << indent << "continue;\n";
                break;
            }
        }

        return out.str();
    }

    std::string exprToString(const Expression& expr) {
        switch (expr.kind) {
            case Expression::LITERAL:
            case Expression::VARIABLE:
            case Expression::BINARY_OP:
            case Expression::UNARY_OP:
                return expr.value;

            case Expression::CALL: {
                std::ostringstream out;
                out << expr.func_name << "(";
                for (size_t i = 0; i < expr.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(expr.args[i]);
                }
                out << ")";
                return out.str();
            }

            case Expression::MACRO_CALL: {
                std::ostringstream out;
                out << expr.func_name << "!(";
                for (size_t i = 0; i < expr.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(expr.args[i]);
                }
                out << ")";
                return out.str();
            }

            case Expression::METHOD_CALL: {
                std::ostringstream out;
                if (expr.receiver) {
                    out << exprToString(*expr.receiver) << ".";
                }
                out << expr.method_name << "(";
                for (size_t i = 0; i < expr.args.size(); ++i) {
                    if (i > 0)
                        out << ", ";
                    out << exprToString(expr.args[i]);
                }
                out << ")";
                return out.str();
            }

            default:
                return expr.value;
        }
    }

    std::string typeToString(Type type) {
        switch (type) {
            case Type::VOID:
                return "()";
            case Type::BOOL:
                return "bool";
            case Type::CHAR:
                return "char";
            case Type::I8:
                return "i8";
            case Type::I16:
                return "i16";
            case Type::I32:
                return "i32";
            case Type::I64:
                return "i64";
            case Type::U8:
                return "u8";
            case Type::U16:
                return "u16";
            case Type::U32:
                return "u32";
            case Type::U64:
                return "u64";
            case Type::F32:
                return "f32";
            case Type::F64:
                return "f64";
            case Type::STRING:
                return "String";
            case Type::STR_REF:
                return "&str";
            case Type::STR_SLICE:
                return "&'static str";
            default:
                return "i32";
        }
    }

    void generateCargoToml() {
        std::ofstream out(options.output_dir + "/Cargo.toml");
        out << "[package]\n";
        out << "name = \"" << options.crate_name << "\"\n";
        out << "version = \"0.1.0\"\n";
        out << "edition = \"2021\"\n\n";
        out << "[dependencies]\n";
    }
};

}  // namespace rust_mir
}  // namespace cm
