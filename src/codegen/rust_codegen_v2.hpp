#pragma once

#include "../mir/mir_nodes.hpp"

#include <fstream>
#include <iostream>
#include <set>
#include <sstream>
#include <string>

namespace cm::codegen {

class RustCodeGeneratorV2 {
   private:
    std::stringstream output;
    int indent_level = 0;
    std::set<size_t> declared_locals;  // 既に宣言されたローカル変数を追跡

    void emit(const std::string& code) { output << std::string(indent_level * 4, ' ') << code; }

    void emit_line(const std::string& code = "") {
        if (!code.empty()) {
            emit(code);
        }
        output << "\n";
    }

    void emit_raw(const std::string& code) { output << code; }

   public:
    std::string generate(const mir::MirProgram& mir_program) {
        // ヘッダー
        emit_line("// Generated by Cm compiler V2");
        emit_line("// State machine based code generation");
        emit_line();
        emit_line("#![allow(dead_code)]");
        emit_line("#![allow(unused_variables)]");
        emit_line("#![allow(non_snake_case)]");
        emit_line("#![allow(unused_assignments)]");
        emit_line("#![allow(unused_mut)]");
        emit_line();

        // 各関数を生成
        for (const auto& func : mir_program.functions) {
            if (func) {
                generate_function(*func);
            }
        }

        return output.str();
    }

   private:
    void generate_function(const mir::MirFunction& func) {
        // 宣言済みローカル変数を関数ごとにリセット
        declared_locals.clear();

        // 関数シグネチャ
        if (func.name == "main") {
            emit_line("fn main() {");
        } else {
            emit("fn " + func.name + "(");
            for (size_t i = 0; i < func.arg_locals.size(); i++) {
                if (i > 0)
                    emit(", ");
                emit("_" + std::to_string(func.arg_locals[i]) + ": " +
                     type_to_rust(*func.locals[func.arg_locals[i]].type));
            }
            emit(") -> " + type_to_rust(*func.locals[func.return_local].type));
            emit_line(" {");
        }
        indent_level++;

        // ローカル変数の宣言（型推論を利用）
        // 注意：使用されない変数は宣言しない方が良いが、
        // 今は簡単のため全て宣言する
        std::set<size_t> void_vars;  // void型の変数を記録
        for (size_t i = 0; i < func.locals.size(); i++) {
            // 最初の使用時に宣言されるため、ここでは宣言をスキップ
        }
        emit_line();

        // ステートマシンによる基本ブロックの実行
        emit_line("let mut _current_bb = 0usize;");
        emit_line("loop {");
        indent_level++;
        emit_line("match _current_bb {");
        indent_level++;

        // 各基本ブロックをmatchのアームとして生成
        for (const auto& block : func.basic_blocks) {
            if (!block)
                continue;

            emit_line(std::to_string(block->id) + " => {");
            indent_level++;

            // ブロック内の文を生成
            for (const auto& stmt : block->statements) {
                if (stmt) {
                    generate_statement(*stmt, func);
                }
            }

            // ターミネータを生成（次のブロックを決定）
            if (block->terminator) {
                generate_terminator_v2(*block->terminator, func);
            }

            indent_level--;
            emit_line("}");
        }

        // 無効なブロックIDの場合
        emit_line("_ => {");
        indent_level++;
        emit_line("panic!(\"Invalid basic block: {}\", _current_bb);");
        indent_level--;
        emit_line("}");

        indent_level--;
        emit_line("}");
        indent_level--;
        emit_line("}");

        indent_level--;
        emit_line("}");
        emit_line();
    }

    void generate_terminator_v2(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                if (func.name == "main" && func.return_local < func.locals.size()) {
                    auto return_type = func.locals[func.return_local].type;
                    if (return_type && return_type->name != "void") {
                        emit_line("std::process::exit(_" + std::to_string(func.return_local) +
                                  ");");
                    } else {
                        emit_line("return;");
                    }
                } else {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                }
                break;

            case mir::MirTerminator::Goto:
                emit_line("_current_bb = " +
                          std::to_string(std::get<mir::MirTerminator::GotoData>(term.data).target) +
                          ";");
                break;

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("match " + operand_to_rust(*data.discriminant) + " {");
                indent_level++;

                // 各ケース
                for (const auto& [value, target] : data.targets) {
                    emit_line(std::to_string(value) + " => {");
                    indent_level++;
                    emit_line("_current_bb = " + std::to_string(target) + ";");
                    indent_level--;
                    emit_line("}");
                }

                // デフォルトケース
                emit_line("_ => {");
                indent_level++;
                emit_line("_current_bb = " + std::to_string(data.otherwise) + ";");
                indent_level--;
                emit_line("}");

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);

                // 関数名を取得（定数の場合は文字列を抽出）
                std::string func_name;
                if (data.func->kind == mir::MirOperand::Constant) {
                    auto& constant = std::get<mir::MirConstant>(data.func->data);
                    if (std::holds_alternative<std::string>(constant.value)) {
                        func_name = std::get<std::string>(constant.value);
                    } else {
                        func_name = operand_to_rust(*data.func);
                    }
                } else {
                    func_name = operand_to_rust(*data.func);
                }

                // std::io::println を Rust の println! マクロにマップ
                // 注意: printlnはbuiltinではなく、必ずstd::ioからインポートする必要があります
                if (func_name == "std::io::println") {
                    if (data.args.size() == 1) {
                        emit_line("println!(\"{}\", " + operand_to_rust(*data.args[0]) + ");");
                    } else {
                        emit_line("println!(\"\");");
                    }
                } else if (func_name == "std::io::print") {
                    if (data.args.size() == 1) {
                        emit_line("print!(\"{}\", " + operand_to_rust(*data.args[0]) + ");");
                    } else {
                        emit_line("print!(\"\");");
                    }
                } else {
                    // 通常の関数呼び出し
                    if (data.destination) {
                        emit("_" + std::to_string(data.destination->local) + " = ");
                    }
                    emit(func_name + "(");
                    for (size_t i = 0; i < data.args.size(); i++) {
                        if (i > 0)
                            emit(", ");
                        emit(operand_to_rust(*data.args[i]));
                    }
                    emit_line(");");
                }

                // 次のブロックへ
                emit_line("_current_bb = " + std::to_string(data.success) + ";");
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("unreachable!();");
                break;
        }
    }

    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                // 最初の代入時に`let`を追加
                if (!declared_locals.count(data.place.local)) {
                    emit("let mut ");
                    declared_locals.insert(data.place.local);
                }
                emit(place_to_rust(data.place) + " = ");
                if (data.rvalue) {
                    generate_rvalue(*data.rvalue);
                }
                emit_line(";");
                break;
            }

            case mir::MirStatement::StorageLive:
            case mir::MirStatement::StorageDead:
            case mir::MirStatement::Nop:
                // Rustでは特に処理不要
                break;
        }
    }

    void generate_rvalue(const mir::MirRvalue& rvalue) {
        switch (rvalue.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rvalue.data);
                if (data.operand) {
                    emit(operand_to_rust(*data.operand));
                }
                break;
            }

            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rvalue.data);
                emit("(");
                if (data.lhs)
                    emit(operand_to_rust(*data.lhs));
                emit(" " + binary_op_to_rust(data.op) + " ");
                if (data.rhs)
                    emit(operand_to_rust(*data.rhs));
                emit(")");
                break;
            }

            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rvalue.data);
                emit(unary_op_to_rust(data.op));
                if (data.operand) {
                    emit(operand_to_rust(*data.operand));
                }
                break;
            }

            case mir::MirRvalue::Ref: {
                auto& data = std::get<mir::MirRvalue::RefData>(rvalue.data);
                if (data.borrow == mir::BorrowKind::Mutable) {
                    emit("&mut ");
                } else {
                    emit("&");
                }
                emit(place_to_rust(data.place));
                break;
            }

            case mir::MirRvalue::Aggregate: {
                auto& data = std::get<mir::MirRvalue::AggregateData>(rvalue.data);
                emit("(");
                for (size_t i = 0; i < data.operands.size(); i++) {
                    if (i > 0)
                        emit(", ");
                    if (data.operands[i]) {
                        emit(operand_to_rust(*data.operands[i]));
                    }
                }
                emit(")");
                break;
            }

            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rvalue.data);
                emit("(");
                if (data.operand) {
                    emit(operand_to_rust(*data.operand));
                }
                emit(" as ");
                if (data.target_type) {
                    emit(type_to_rust(*data.target_type));
                }
                emit(")");
                break;
            }
        }
    }

    std::string place_to_rust(const mir::MirPlace& place) {
        return "_" + std::to_string(place.local);
    }

    std::string operand_to_rust(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Copy:
            case mir::MirOperand::Move:
                return place_to_rust(std::get<mir::MirPlace>(op.data));
            case mir::MirOperand::Constant:
                return constant_to_rust(std::get<mir::MirConstant>(op.data));
            case mir::MirOperand::FunctionRef:
                // 関数参照の場合は関数名を返す
                if (std::holds_alternative<std::string>(op.data)) {
                    return std::get<std::string>(op.data);
                }
                return "???";
        }
        return "???";
    }

    std::string constant_to_rust(const mir::MirConstant& constant) {
        return std::visit(
            [](const auto& val) -> std::string {
                using T = std::decay_t<decltype(val)>;
                if constexpr (std::is_same_v<T, std::monostate>) {
                    return "()";
                } else if constexpr (std::is_same_v<T, bool>) {
                    return val ? "true" : "false";
                } else if constexpr (std::is_same_v<T, int64_t>) {
                    return std::to_string(val);
                } else if constexpr (std::is_same_v<T, double>) {
                    return std::to_string(val);
                } else if constexpr (std::is_same_v<T, char>) {
                    return "'" + std::string(1, val) + "'";
                } else if constexpr (std::is_same_v<T, std::string>) {
                    return "\"" + val + "\".to_string()";
                }
                return "???";
            },
            constant.value);
    }

    std::string binary_op_to_rust(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add:
                return "+";
            case mir::MirBinaryOp::Sub:
                return "-";
            case mir::MirBinaryOp::Mul:
                return "*";
            case mir::MirBinaryOp::Div:
                return "/";
            case mir::MirBinaryOp::Mod:
                return "%";
            case mir::MirBinaryOp::BitAnd:
                return "&";
            case mir::MirBinaryOp::BitOr:
                return "|";
            case mir::MirBinaryOp::BitXor:
                return "^";
            case mir::MirBinaryOp::Shl:
                return "<<";
            case mir::MirBinaryOp::Shr:
                return ">>";
            case mir::MirBinaryOp::Eq:
                return "==";
            case mir::MirBinaryOp::Ne:
                return "!=";
            case mir::MirBinaryOp::Lt:
                return "<";
            case mir::MirBinaryOp::Le:
                return "<=";
            case mir::MirBinaryOp::Gt:
                return ">";
            case mir::MirBinaryOp::Ge:
                return ">=";
            case mir::MirBinaryOp::And:
                return "&&";
            case mir::MirBinaryOp::Or:
                return "||";
        }
        return "???";
    }

    std::string unary_op_to_rust(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg:
                return "-";
            case mir::MirUnaryOp::Not:
                return "!";
            case mir::MirUnaryOp::BitNot:
                return "!";
        }
        return "???";
    }

    std::string type_to_rust(const hir::Type& type) {
        if (type.name == "int")
            return "i32";
        if (type.name == "bool")
            return "bool";
        if (type.name == "char")
            return "char";
        if (type.name == "float")
            return "f64";
        if (type.name == "string")
            return "String";
        if (type.name == "void")
            return "()";
        if (type.name.empty())
            return "()";  // 空の型名もvoidとして扱う
        return type.name;
    }
};

}  // namespace cm::codegen