#pragma once

#include "../common/debug.hpp"
#include "../common/debug_messages.hpp"
#include "../frontend/ast/module.hpp"
#include "../mir/mir_nodes.hpp"

#include <cmath>
#include <filesystem>
#include <fstream>
#include <iostream>
#include <map>
#include <sstream>
#include <unordered_map>

namespace cm::codegen {

// ============================================================
// Rustコード生成器（FFI対応）
// ============================================================
class RustCodegen {
   private:
    struct Options {
        bool use_ffi = true;         // FFIを使用
        bool generate_cargo = true;  // Cargo.tomlを生成
        bool split_modules = true;   // モジュール分割
        std::string output_dir = ".tmp/rust_build";
        std::string crate_name = "cm_app";
    };

    Options opts;
    std::ostringstream current_output;
    std::unordered_map<std::string, std::string> module_outputs;
    std::vector<std::string> external_crates;
    std::vector<std::string> ffi_functions;
    int indent_level = 0;
    std::map<size_t, std::string> inferred_types;  // 型推論結果を保持

   public:
    RustCodegen() = default;
    RustCodegen(const Options& options) : opts(options) {}

    // MIRプログラムをRustコードに変換
    void generate(const mir::MirProgram& program, const std::string& output_path = "") {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Info,
                       debug::msg(new const char* [] {
                           "Starting Rust code generation", "Rustコード生成を開始"
                       }));
        }

        // output_pathが指定されていればそれを使用
        if (!output_path.empty()) {
            opts.output_dir = output_path;
        }

        std::filesystem::create_directories(opts.output_dir);

        if (opts.split_modules) {
            generate_split_modules(program);
        } else {
            generate_single_file(program);
        }

        if (opts.generate_cargo) {
            generate_cargo_toml();
        }

        if (opts.use_ffi) {
            generate_ffi_bindings();
        }

        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Info,
                       "Generated Rust code at: " + opts.output_dir);
        }
    }

   private:
    // 単一ファイル生成
    void generate_single_file(const mir::MirProgram& program) {
        emit_header();
        emit_imports();

        for (const auto& func : program.functions) {
            generate_function(*func);
        }

        std::ofstream out(opts.output_dir + "/main.rs");
        out << current_output.str();
    }

    // モジュール分割生成
    void generate_split_modules(const mir::MirProgram& program) {
        // メインモジュール
        current_output.str("");
        emit_header();
        emit_module_imports();

        // main関数を探す
        for (const auto& func : program.functions) {
            if (func->name == "main") {
                generate_function(*func);
                break;
            }
        }

        std::ofstream main_out(opts.output_dir + "/main.rs");
        main_out << current_output.str();

        // その他の関数をlibに
        current_output.str("");
        emit_header();
        for (const auto& func : program.functions) {
            if (func->name != "main") {
                generate_function_as_pub(*func);
            }
        }

        std::ofstream lib_out(opts.output_dir + "/lib.rs");
        lib_out << current_output.str();
    }

    // ヘッダーコメント
    void emit_header() {
        emit_line("// Generated by Cm compiler");
        emit_line("// WARNING: Do not edit manually");
        emit_line("");
        emit_line("#![allow(dead_code)]");
        emit_line("#![allow(unused_variables)]");
        emit_line("#![allow(non_snake_case)]");
        emit_line("");
    }

    // インポート
    void emit_imports() {
        emit_line("use std::ffi::{CStr, CString};");
        emit_line("use std::os::raw::c_char;");
        emit_line("");

        if (opts.use_ffi) {
            emit_ffi_imports();
        }
    }

    // モジュールインポート
    void emit_module_imports() {
        for (const auto& module : module_outputs) {
            emit_line("mod " + module.first + ";");
        }
        emit_line("");
    }

    // FFIインポート
    void emit_ffi_imports() {
        emit_line("// FFI imports");
        emit_line("extern \"C\" {");
        indent_level++;

        // 標準ライブラリFFI
        emit_line("fn cm_print_string(s: *const c_char);");
        emit_line("fn cm_print_int(n: i64);");
        emit_line("fn cm_print_float(f: f64);");
        emit_line("fn cm_print_bool(b: bool);");

        // カスタムFFI関数
        for (const auto& ffi : ffi_functions) {
            emit_line(ffi);
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数生成
    void generate_function(const mir::MirFunction& func) {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug,
                       "Generating function: " + func.name);
        }

        std::string signature = build_function_signature(func, false);
        emit_line(signature + " {");
        indent_level++;

        // ローカル変数宣言
        generate_locals(func);

        // 基本ブロック生成
        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // パブリック関数生成（FFI用）
    void generate_function_as_pub(const mir::MirFunction& func) {
        // FFIエクスポート用
        if (opts.use_ffi) {
            emit_line("#[no_mangle]");
            emit_line("pub extern \"C\" " + build_ffi_signature(func) + " {");
        } else {
            emit_line("pub " + build_function_signature(func, true) + " {");
        }

        indent_level++;
        generate_locals(func);

        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数シグネチャ構築
    std::string build_function_signature(const mir::MirFunction& func, bool is_pub) {
        std::ostringstream sig;

        if (is_pub)
            sig << "pub ";
        sig << "fn " << mangle_name(func.name) << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first)
                sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_rust(local.type);
        }

        // main関数の特別処理 - Rustのmainは常に()を返す
        if (func.name == "main") {
            sig << ")";  // Rustのmainは()を返す
        } else {
            sig << ") -> " << type_to_rust(func.locals[func.return_local].type);
        }
        return sig.str();
    }

    // FFIシグネチャ構築
    std::string build_ffi_signature(const mir::MirFunction& func) {
        std::ostringstream sig;
        sig << "fn cm_" << func.name << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first)
                sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_ffi(local.type);
        }

        sig << ") -> " << type_to_ffi(func.locals[func.return_local].type);
        return sig.str();
    }

    // ローカル変数生成（型推論機能付き）
    void generate_locals(const mir::MirFunction& func) {
        // 型推論のために文を先読みして定数の型を推定
        // inferred_types はクラスメンバとして保持
        inferred_types.clear();  // 関数ごとにクリア

        // 複数パス: 定数から直接型を推論、その後伝播
        for (int pass = 0; pass < 3; pass++) {
            for (const auto& block : func.basic_blocks) {
                if (!block)
                    continue;
                for (const auto& stmt : block->statements) {
                    if (!stmt)
                        continue;
                    if (stmt->kind == mir::MirStatement::Assign) {
                        auto& data = std::get<mir::MirStatement::AssignData>(stmt->data);
                        size_t dest_local = data.place.local;

                        // RValueがUseの場合
                        if (data.rvalue && data.rvalue->kind == mir::MirRvalue::Use) {
                            auto& use_data = std::get<mir::MirRvalue::UseData>(data.rvalue->data);
                            if (use_data.operand) {
                                // 定数から型を推論
                                if (use_data.operand->kind == mir::MirOperand::Constant) {
                                    auto& constant =
                                        std::get<mir::MirConstant>(use_data.operand->data);

                                    if (std::holds_alternative<bool>(constant.value)) {
                                        inferred_types[dest_local] = "bool";
                                    } else if (std::holds_alternative<double>(constant.value)) {
                                        double val = std::get<double>(constant.value);
                                        // 浮動小数点リテラルの判定
                                        if (constant.type && constant.type->name == "double") {
                                            inferred_types[dest_local] = "f64";
                                        } else if (constant.type &&
                                                   constant.type->name == "float") {
                                            inferred_types[dest_local] = "f32";
                                        } else if (val != std::floor(val)) {
                                            // 小数点を含む値はデフォルトでf64
                                            inferred_types[dest_local] = "f64";
                                        } else {
                                            // 整数値でも明示的にdouble型の場合はf64
                                            inferred_types[dest_local] = "f64";
                                        }
                                    } else if (std::holds_alternative<char>(constant.value)) {
                                        inferred_types[dest_local] = "char";
                                    } else if (std::holds_alternative<std::string>(
                                                   constant.value)) {
                                        inferred_types[dest_local] = "String";
                                    }
                                }
                                // 変数から変数への代入で型を伝播
                                else if (use_data.operand->kind == mir::MirOperand::Copy ||
                                         use_data.operand->kind == mir::MirOperand::Move) {
                                    if (auto* place =
                                            std::get_if<mir::MirPlace>(&use_data.operand->data)) {
                                        size_t src_local = place->local;
                                        if (inferred_types.count(src_local)) {
                                            inferred_types[dest_local] = inferred_types[src_local];
                                        }
                                    }
                                }
                            }
                        }
                        // 比較演算の結果はbool
                        else if (data.rvalue && data.rvalue->kind == mir::MirRvalue::BinaryOp) {
                            auto& binop_data =
                                std::get<mir::MirRvalue::BinaryOpData>(data.rvalue->data);
                            if (binop_data.op >= mir::MirBinaryOp::Eq &&
                                binop_data.op <= mir::MirBinaryOp::Ge) {
                                inferred_types[dest_local] = "bool";
                            }
                            // 論理演算の結果もbool
                            if (binop_data.op == mir::MirBinaryOp::And ||
                                binop_data.op == mir::MirBinaryOp::Or) {
                                inferred_types[dest_local] = "bool";
                            }
                        }
                    }
                }
            }
        }

        // mainの戻り値変数を明示的に宣言（main関数の特別処理）
        if (func.name == "main") {
            // _0は常にi32型として宣言（exit code用）
            emit_line("let mut _0: i32;");
        }

        for (const auto& local : func.locals) {
            // 引数とreturn値以外を宣言
            bool is_arg = false;
            for (auto arg_id : func.arg_locals) {
                if (arg_id == local.id) {
                    is_arg = true;
                    break;
                }
            }

            if (!is_arg && local.id != func.return_local) {
                std::string mut_str = local.is_mutable ? "mut " : "";
                std::string type_str;

                // 型情報がある場合はそれを使用
                if (local.type) {
                    type_str = type_to_rust(local.type);
                    // "()"が返ってきた場合は型情報なし
                    if (type_str == "()") {
                        type_str.clear();
                    }
                }

                // 型推論の結果がある場合はそれを使用
                if (type_str.empty() && inferred_types.count(local.id)) {
                    type_str = inferred_types[local.id];
                }

                // どちらもない場合はデフォルトでi32
                if (type_str.empty()) {
                    type_str = "i32";
                }

                emit_line("let " + mut_str + "_" + std::to_string(local.id) + ": " + type_str +
                          ";");
            }
        }

        if (!func.locals.empty()) {
            emit_line("");
        }
    }

    // 基本ブロック生成
    void generate_basic_block(const mir::BasicBlock& block, const mir::MirFunction& func) {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Trace,
                       "Generating basic block: bb" + std::to_string(block.id));
        }

        // ブロックラベル（将来のgoto用）
        emit_line("// bb" + std::to_string(block.id) + ":");

        // 文を生成
        for (const auto& stmt : block.statements) {
            generate_statement(*stmt, func);
        }

        // 終端命令を生成
        if (block.terminator) {
            generate_terminator(*block.terminator, func);
        }
    }

    // 文の生成
    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                std::string lhs = place_to_rust(data.place);
                std::string rhs = rvalue_to_rust(*data.rvalue);

                // 文字列リテラルをString型に代入する場合の特別処理
                if (data.rvalue && data.rvalue->kind == mir::MirRvalue::Use) {
                    auto& use_data = std::get<mir::MirRvalue::UseData>(data.rvalue->data);
                    if (use_data.operand && use_data.operand->kind == mir::MirOperand::Constant) {
                        auto& constant = std::get<mir::MirConstant>(use_data.operand->data);
                        if (std::holds_alternative<std::string>(constant.value)) {
                            // 対象変数の型を確認
                            mir::LocalId dest_local = data.place.local;
                            if (inferred_types.count(dest_local) &&
                                inferred_types[dest_local] == "String") {
                                rhs += ".to_string()";
                            }
                        }
                    }
                }

                emit_line(lhs + " = " + rhs + ";");
                break;
            }
            case mir::MirStatement::StorageLive: {
                // Rustでは明示的なStorageLiveは不要
                break;
            }
            case mir::MirStatement::StorageDead: {
                // Rustでは明示的なStorageDeadは不要
                break;
            }
            case mir::MirStatement::Nop: {
                emit_line("// nop");
                break;
            }
        }
    }

    // 終端命令の生成
    void generate_terminator(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                // main関数の特別処理 - 戻り値をexit codeとして使用
                if (func.name == "main" && func.return_local < func.locals.size()) {
                    auto return_type = func.locals[func.return_local].type;
                    if (return_type && return_type->name != "void") {
                        emit_line("std::process::exit(_" + std::to_string(func.return_local) +
                                  ");");
                    } else {
                        emit_line("return;");
                    }
                } else if (func.return_local != 0) {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                } else {
                    emit_line("return;");
                }
                break;

            case mir::MirTerminator::Goto:
                // 単純なgotoは次のブロックへのフォールスルー
                emit_line("// goto bb" +
                          std::to_string(std::get<mir::MirTerminator::GotoData>(term.data).target));
                break;

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("match " + operand_to_rust(*data.discriminant) + " {");
                indent_level++;

                for (const auto& [value, target] : data.targets) {
                    emit_line(std::to_string(value) + " => {");
                    indent_level++;
                    emit_line("// goto bb" + std::to_string(target));
                    indent_level--;
                    emit_line("},");
                }

                emit_line("_ => {");
                indent_level++;
                emit_line("// goto bb" + std::to_string(data.otherwise));
                indent_level--;
                emit_line("}");

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);

                // 関数名を取得（組み込み関数の特別処理）
                std::string func_name;
                if (data.func && data.func->kind == mir::MirOperand::Constant) {
                    if (auto* constant = std::get_if<mir::MirConstant>(&data.func->data)) {
                        if (auto* s = std::get_if<std::string>(&constant->value)) {
                            // 組み込み関数の特別処理
                            if (*s == "println") {
                                func_name = "println!";  // Rustのマクロに変換
                            } else if (*s == "print") {
                                func_name = "print!";  // Rustのマクロに変換
                            } else {
                                func_name = *s;  // 通常の関数名
                            }
                        }
                    }
                }

                // 関数名が取得できなかった場合はデフォルト処理
                if (func_name.empty()) {
                    func_name = operand_to_rust(*data.func);
                }

                // 引数リストを構築
                std::string call;

                // println!/print!の特別処理
                if (func_name == "println!" || func_name == "print!") {
                    if (!data.args.empty()) {
                        // 複数引数の場合（文字列補間を使用している場合）
                        if (data.args.size() > 1) {
                            // 第1引数の文字列から{変数名}を{}に置換したフォーマット文字列を作成
                            // 第1引数の元の値を取得して処理（変数の場合は型推論結果から復元）
                            std::string format_str = "";
                            bool has_format_str = false;

                            // 第1引数が定数文字列の場合
                            if (data.args[0]->kind == mir::MirOperand::Constant) {
                                if (auto* constant =
                                        std::get_if<mir::MirConstant>(&data.args[0]->data)) {
                                    if (auto* str_val =
                                            std::get_if<std::string>(&constant->value)) {
                                        format_str = *str_val;
                                        has_format_str = true;
                                    }
                                }
                            }

                            // フォーマット文字列が取得できた場合、{変数名}を{}に置換
                            if (has_format_str) {
                                size_t pos = 0;
                                while ((pos = format_str.find('{', pos)) != std::string::npos) {
                                    size_t end = format_str.find('}', pos);
                                    if (end != std::string::npos) {
                                        // {{や}}はエスケープなのでスキップ
                                        if (pos + 1 < format_str.size() &&
                                            format_str[pos + 1] == '{') {
                                            pos += 2;
                                            continue;
                                        }
                                        std::string placeholder =
                                            format_str.substr(pos + 1, end - pos - 1);
                                        // 変数名のプレースホルダーを{}に置換
                                        if (!placeholder.empty() &&
                                            placeholder.find(':') == std::string::npos &&
                                            !std::isdigit(placeholder[0])) {
                                            format_str.replace(pos, end - pos + 1, "{}");
                                            pos += 2;  // {}の長さ
                                        } else {
                                            pos = end + 1;
                                        }
                                    } else {
                                        break;
                                    }
                                }
                            } else {
                                // フォーマット文字列が取得できない場合、引数の数だけ{}を作成
                                for (size_t i = 1; i < data.args.size(); ++i) {
                                    if (i > 1)
                                        format_str += " ";
                                    format_str += "{}";
                                }
                            }

                            // println!マクロの呼び出しを生成
                            call = func_name + "(\"" + format_str + "\"";
                            for (size_t i = 1; i < data.args.size(); ++i) {
                                call += ", " + operand_to_rust(*data.args[i]);
                            }
                            call += ")";
                        } else {
                            // 単一引数の場合
                            if (data.args[0]->kind == mir::MirOperand::Constant) {
                                if (auto* constant =
                                        std::get_if<mir::MirConstant>(&data.args[0]->data)) {
                                    if (std::holds_alternative<std::string>(constant->value)) {
                                        // 文字列リテラルはそのまま
                                        call = func_name + "(" + constant_to_rust(*constant) + ")";
                                    } else {
                                        // その他の定数は"{}"フォーマットで
                                        call = func_name + "(\"{}\", " +
                                               operand_to_rust(*data.args[0]) + ")";
                                    }
                                }
                            } else {
                                // 変数の場合は"{}"フォーマットで
                                call =
                                    func_name + "(\"{}\", " + operand_to_rust(*data.args[0]) + ")";
                            }
                        }
                    } else {
                        // 引数なし
                        call = func_name + "()";
                    }
                } else {
                    // 通常の関数呼び出し
                    call = func_name + "(";
                    bool first = true;
                    for (const auto& arg : data.args) {
                        if (!first)
                            call += ", ";
                        first = false;
                        call += operand_to_rust(*arg);
                    }
                    call += ")";
                }

                // println!/print!は値を返さないので、代入はスキップ
                if (data.destination && func_name != "println!" && func_name != "print!") {
                    emit_line(place_to_rust(*data.destination) + " = " + call + ";");
                } else {
                    emit_line(call + ";");
                }
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("unreachable!();");
                break;
        }
    }

    // Place → Rust
    std::string place_to_rust(const mir::MirPlace& place) {
        std::string result = "_" + std::to_string(place.local);

        for (const auto& proj : place.projections) {
            switch (proj.kind) {
                case mir::ProjectionKind::Field:
                    result += "." + std::to_string(proj.field_id);
                    break;
                case mir::ProjectionKind::Index:
                    result += "[_" + std::to_string(proj.index_local) + "]";
                    break;
                case mir::ProjectionKind::Deref:
                    result = "(*" + result + ")";
                    break;
            }
        }

        return result;
    }

    // Operand → Rust
    std::string operand_to_rust(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Move:
            case mir::MirOperand::Copy:
                if (auto* place = std::get_if<mir::MirPlace>(&op.data)) {
                    return place_to_rust(*place);
                }
                break;
            case mir::MirOperand::Constant:
                if (auto* constant = std::get_if<mir::MirConstant>(&op.data)) {
                    return constant_to_rust(*constant);
                }
                break;
            case mir::MirOperand::FunctionRef:
                if (auto* func_name = std::get_if<std::string>(&op.data)) {
                    // 組み込み関数の特別処理
                    if (*func_name == "println") {
                        return "println!";
                    } else if (*func_name == "print") {
                        return "print!";
                    }
                    // 通常の関数名
                    return *func_name;
                }
                break;
        }
        return "()";
    }

    // Rvalue → Rust
    std::string rvalue_to_rust(const mir::MirRvalue& rv) {
        switch (rv.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rv.data);
                return operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rv.data);
                return "(" + operand_to_rust(*data.lhs) + " " + binary_op_to_rust(data.op) + " " +
                       operand_to_rust(*data.rhs) + ")";
            }
            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rv.data);
                return unary_op_to_rust(data.op) + operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::Ref: {
                auto& data = std::get<mir::MirRvalue::RefData>(rv.data);
                std::string prefix = data.borrow == mir::BorrowKind::Shared ? "&" : "&mut ";
                return prefix + place_to_rust(data.place);
            }
            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rv.data);
                return operand_to_rust(*data.operand) + " as " + type_to_rust(data.target_type);
            }
            default:
                return "()";
        }
    }

    // 定数 → Rust
    std::string constant_to_rust(const mir::MirConstant& constant) {
        if (std::holds_alternative<std::monostate>(constant.value)) {
            return "()";
        } else if (auto* b = std::get_if<bool>(&constant.value)) {
            return *b ? "true" : "false";
        } else if (auto* i = std::get_if<int64_t>(&constant.value)) {
            return std::to_string(*i);
        } else if (auto* d = std::get_if<double>(&constant.value)) {
            return std::to_string(*d);
        } else if (auto* c = std::get_if<char>(&constant.value)) {
            return "'" + std::string(1, *c) + "'";
        } else if (auto* s = std::get_if<std::string>(&constant.value)) {
            return "\"" + escape_string(*s) + "\"";
        }
        return "()";
    }

    // 型 → Rust
    std::string type_to_rust(hir::TypePtr type) {
        if (!type) {
            // 型情報がない場合はエラー
            if (debug::g_debug_mode) {
                debug::log(debug::Stage::CodegenRust, debug::Level::Error,
                           "Missing type information - this is a compiler bug!");
            }
            return "()";  // Unit型を返す（本来はエラーとすべき）
        }

        if (type->name == "int")
            return "i32";
        if (type->name == "uint")
            return "u32";
        if (type->name == "long")
            return "i64";
        if (type->name == "ulong")
            return "u64";
        if (type->name == "float")
            return "f32";
        if (type->name == "double")
            return "f64";
        if (type->name == "bool")
            return "bool";
        if (type->name == "char")
            return "char";
        if (type->name == "void")
            return "()";
        if (type->name == "string")
            return "String";

        return type->name;
    }

    // 型 → FFI
    std::string type_to_ffi(hir::TypePtr type) {
        if (!type)
            return "()";

        if (type->name == "string")
            return "*const c_char";
        // その他は通常のRust型と同じ
        return type_to_rust(type);
    }

    // 二項演算子 → Rust
    std::string binary_op_to_rust(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add:
                return "+";
            case mir::MirBinaryOp::Sub:
                return "-";
            case mir::MirBinaryOp::Mul:
                return "*";
            case mir::MirBinaryOp::Div:
                return "/";
            case mir::MirBinaryOp::Mod:
                return "%";
            case mir::MirBinaryOp::BitAnd:
                return "&";
            case mir::MirBinaryOp::BitOr:
                return "|";
            case mir::MirBinaryOp::BitXor:
                return "^";
            case mir::MirBinaryOp::Shl:
                return "<<";
            case mir::MirBinaryOp::Shr:
                return ">>";
            case mir::MirBinaryOp::Eq:
                return "==";
            case mir::MirBinaryOp::Ne:
                return "!=";
            case mir::MirBinaryOp::Lt:
                return "<";
            case mir::MirBinaryOp::Le:
                return "<=";
            case mir::MirBinaryOp::Gt:
                return ">";
            case mir::MirBinaryOp::Ge:
                return ">=";
            case mir::MirBinaryOp::And:
                return "&&";
            case mir::MirBinaryOp::Or:
                return "||";
            default:
                return "?";
        }
    }

    // 単項演算子 → Rust
    std::string unary_op_to_rust(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg:
                return "-";
            case mir::MirUnaryOp::Not:
                return "!";
            case mir::MirUnaryOp::BitNot:
                return "!";  // Rustでは!がビット反転
            default:
                return "?";
        }
    }

    // 名前マングリング
    std::string mangle_name(const std::string& name) {
        // main関数は特別扱い
        if (name == "main")
            return "main";

        // Cm_ プレフィックスを付ける
        return "cm_" + name;
    }

    // 文字列エスケープ
    std::string escape_string(const std::string& s) {
        std::string result;
        for (char c : s) {
            switch (c) {
                case '"':
                    result += "\\\"";
                    break;
                case '\\':
                    result += "\\\\";
                    break;
                case '\n':
                    result += "\\n";
                    break;
                case '\r':
                    result += "\\r";
                    break;
                case '\t':
                    result += "\\t";
                    break;
                default:
                    result += c;
                    break;
            }
        }
        return result;
    }

    // Cargo.toml生成
    void generate_cargo_toml() {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug, "Generating Cargo.toml");
        }

        std::ofstream out(opts.output_dir + "/Cargo.toml");

        out << "[package]\n";
        out << "name = \"" << opts.crate_name << "\"\n";
        out << "version = \"0.1.0\"\n";
        out << "edition = \"2021\"\n\n";

        out << "[dependencies]\n";
        for (const auto& crate_ : external_crates) {
            out << crate_ << "\n";
        }
        out << "\n";

        out << "[profile.dev]\n";
        out << "opt-level = 0\n";
        out << "incremental = true\n\n";

        out << "[profile.release]\n";
        out << "opt-level = 3\n";
        out << "lto = true\n";
    }

    // FFIバインディング生成
    void generate_ffi_bindings() {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenRust, debug::Level::Debug, "Generating FFI bindings");
        }

        std::ofstream out(opts.output_dir + "/ffi.rs");

        out << "// FFI bindings for Cm standard library\n\n";
        out << "use std::ffi::{CStr, CString};\n";
        out << "use std::os::raw::c_char;\n\n";

        // print関数の実装
        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_string(s: *const c_char) {\n";
        out << "    let s = unsafe { CStr::from_ptr(s).to_string_lossy() };\n";
        out << "    print!(\"{}\", s);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_int(n: i64) {\n";
        out << "    print!(\"{}\", n);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_float(f: f64) {\n";
        out << "    print!(\"{}\", f);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_bool(b: bool) {\n";
        out << "    print!(\"{}\", b);\n";
        out << "}\n\n";
    }

    // 行出力
    void emit_line(const std::string& line) {
        for (int i = 0; i < indent_level; ++i) {
            current_output << "    ";
        }
        current_output << line << "\n";
    }

    void emit(const std::string& str) { current_output << str; }
};

}  // namespace cm::codegen