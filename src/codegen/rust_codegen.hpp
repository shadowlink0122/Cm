#pragma once

#include "../mir/mir_nodes.hpp"
#include "../frontend/ast/module.hpp"
#include <iostream>
#include <sstream>
#include <fstream>
#include <unordered_map>
#include <filesystem>

namespace cm::codegen {

// ============================================================
// Rustコード生成器（FFI対応）
// ============================================================
class RustCodegen {
private:
    struct Options {
        bool use_ffi = true;           // FFIを使用
        bool generate_cargo = true;     // Cargo.tomlを生成
        bool split_modules = true;      // モジュール分割
        std::string output_dir = "target/rust";
        std::string crate_name = "cm_app";
    };

    Options opts;
    std::ostringstream current_output;
    std::unordered_map<std::string, std::string> module_outputs;
    std::vector<std::string> external_crates;
    std::vector<std::string> ffi_functions;
    int indent_level = 0;

public:
    RustCodegen(const Options& options = {}) : opts(options) {}

    // MIRプログラムをRustコードに変換
    void generate(const mir::MirProgram& program, const std::string& output_path = "") {
        std::filesystem::create_directories(opts.output_dir);

        if (opts.split_modules) {
            generate_split_modules(program);
        } else {
            generate_single_file(program);
        }

        if (opts.generate_cargo) {
            generate_cargo_toml();
        }

        if (opts.use_ffi) {
            generate_ffi_bindings();
        }
    }

private:
    // 単一ファイル生成
    void generate_single_file(const mir::MirProgram& program) {
        emit_header();
        emit_imports();

        for (const auto& func : program.functions) {
            generate_function(*func);
        }

        std::ofstream out(opts.output_dir + "/main.rs");
        out << current_output.str();
    }

    // モジュール分割生成
    void generate_split_modules(const mir::MirProgram& program) {
        // メインモジュール
        current_output.str("");
        emit_header();
        emit_module_imports();

        // main関数を探す
        for (const auto& func : program.functions) {
            if (func->name == "main") {
                generate_function(*func);
                break;
            }
        }

        std::ofstream main_out(opts.output_dir + "/main.rs");
        main_out << current_output.str();

        // その他の関数をlibに
        current_output.str("");
        emit_header();
        for (const auto& func : program.functions) {
            if (func->name != "main") {
                generate_function_as_pub(*func);
            }
        }

        std::ofstream lib_out(opts.output_dir + "/lib.rs");
        lib_out << current_output.str();
    }

    // ヘッダーコメント
    void emit_header() {
        emit_line("// Generated by Cm compiler");
        emit_line("// WARNING: Do not edit manually");
        emit_line("");
        emit_line("#![allow(dead_code)]");
        emit_line("#![allow(unused_variables)]");
        emit_line("#![allow(non_snake_case)]");
        emit_line("");
    }

    // インポート
    void emit_imports() {
        emit_line("use std::ffi::{CStr, CString};");
        emit_line("use std::os::raw::c_char;");
        emit_line("");

        if (opts.use_ffi) {
            emit_ffi_imports();
        }
    }

    // モジュールインポート
    void emit_module_imports() {
        for (const auto& module : module_outputs) {
            emit_line("mod " + module.first + ";");
        }
        emit_line("");
    }

    // FFIインポート
    void emit_ffi_imports() {
        emit_line("// FFI imports");
        emit_line("extern \"C\" {");
        indent_level++;

        // 標準ライブラリFFI
        emit_line("fn cm_print_string(s: *const c_char);");
        emit_line("fn cm_print_int(n: i64);");
        emit_line("fn cm_print_float(f: f64);");
        emit_line("fn cm_print_bool(b: bool);");

        // カスタムFFI関数
        for (const auto& ffi : ffi_functions) {
            emit_line(ffi);
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数生成
    void generate_function(const mir::MirFunction& func) {
        std::string signature = build_function_signature(func, false);
        emit_line(signature + " {");
        indent_level++;

        // ローカル変数宣言
        generate_locals(func);

        // 基本ブロック生成
        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // パブリック関数生成（FFI用）
    void generate_function_as_pub(const mir::MirFunction& func) {
        // FFIエクスポート用
        if (opts.use_ffi) {
            emit_line("#[no_mangle]");
            emit_line("pub extern \"C\" " + build_ffi_signature(func) + " {");
        } else {
            emit_line("pub " + build_function_signature(func, true) + " {");
        }

        indent_level++;
        generate_locals(func);

        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    // 関数シグネチャ構築
    std::string build_function_signature(const mir::MirFunction& func, bool is_pub) {
        std::ostringstream sig;

        if (is_pub) sig << "pub ";
        sig << "fn " << mangle_name(func.name) << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first) sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_rust(local.type);
        }

        sig << ") -> " << type_to_rust(func.locals[func.return_local].type);
        return sig.str();
    }

    // FFIシグネチャ構築
    std::string build_ffi_signature(const mir::MirFunction& func) {
        std::ostringstream sig;
        sig << "fn cm_" << func.name << "(";

        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first) sig << ", ";
            first = false;

            const auto& local = func.locals[func.arg_locals[i]];
            sig << "_" << local.id << ": " << type_to_ffi(local.type);
        }

        sig << ") -> " << type_to_ffi(func.locals[func.return_local].type);
        return sig.str();
    }

    // ローカル変数生成
    void generate_locals(const mir::MirFunction& func) {
        for (const auto& local : func.locals) {
            // 引数とreturn値以外を宣言
            bool is_arg = false;
            for (auto arg_id : func.arg_locals) {
                if (arg_id == local.id) {
                    is_arg = true;
                    break;
                }
            }

            if (!is_arg && local.id != func.return_local) {
                std::string mut_str = local.is_mutable ? "mut " : "";
                emit_line("let " + mut_str + "_" + std::to_string(local.id) +
                         ": " + type_to_rust(local.type) + ";");
            }
        }

        if (!func.locals.empty()) {
            emit_line("");
        }
    }

    // 基本ブロック生成
    void generate_basic_block(const mir::BasicBlock& block, const mir::MirFunction& func) {
        // ブロックラベル（将来のgoto用）
        emit_line("// bb" + std::to_string(block.id) + ":");

        // 文を生成
        for (const auto& stmt : block.statements) {
            generate_statement(*stmt, func);
        }

        // 終端命令を生成
        if (block.terminator) {
            generate_terminator(*block.terminator, func);
        }
    }

    // 文の生成
    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                std::string lhs = place_to_rust(data.place);
                std::string rhs = rvalue_to_rust(*data.rvalue);
                emit_line(lhs + " = " + rhs + ";");
                break;
            }
            case mir::MirStatement::StorageLive: {
                // Rustでは明示的なStorageLiveは不要
                break;
            }
            case mir::MirStatement::StorageDead: {
                // Rustでは明示的なStorageDeadは不要
                break;
            }
            case mir::MirStatement::Nop: {
                emit_line("// nop");
                break;
            }
        }
    }

    // 終端命令の生成
    void generate_terminator(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                if (func.return_local != 0) {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                } else {
                    emit_line("return;");
                }
                break;

            case mir::MirTerminator::Goto:
                // 単純なgotoは次のブロックへのフォールスルー
                emit_line("// goto bb" +
                    std::to_string(std::get<mir::MirTerminator::GotoData>(term.data).target));
                break;

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("match " + operand_to_rust(*data.discriminant) + " {");
                indent_level++;

                for (const auto& [value, target] : data.targets) {
                    emit_line(std::to_string(value) + " => {");
                    indent_level++;
                    emit_line("// goto bb" + std::to_string(target));
                    indent_level--;
                    emit_line("},");
                }

                emit_line("_ => {");
                indent_level++;
                emit_line("// goto bb" + std::to_string(data.otherwise));
                indent_level--;
                emit_line("}");

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);
                std::string call = operand_to_rust(*data.func) + "(";

                bool first = true;
                for (const auto& arg : data.args) {
                    if (!first) call += ", ";
                    first = false;
                    call += operand_to_rust(*arg);
                }
                call += ")";

                if (data.destination) {
                    emit_line(place_to_rust(*data.destination) + " = " + call + ";");
                } else {
                    emit_line(call + ";");
                }
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("unreachable!();");
                break;
        }
    }

    // Place → Rust
    std::string place_to_rust(const mir::MirPlace& place) {
        std::string result = "_" + std::to_string(place.local);

        for (const auto& proj : place.projections) {
            switch (proj.kind) {
                case mir::ProjectionKind::Field:
                    result += "." + std::to_string(proj.field_id);
                    break;
                case mir::ProjectionKind::Index:
                    result += "[_" + std::to_string(proj.index_local) + "]";
                    break;
                case mir::ProjectionKind::Deref:
                    result = "(*" + result + ")";
                    break;
            }
        }

        return result;
    }

    // Operand → Rust
    std::string operand_to_rust(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Move:
            case mir::MirOperand::Copy:
                if (auto* place = std::get_if<mir::MirPlace>(&op.data)) {
                    return place_to_rust(*place);
                }
                break;
            case mir::MirOperand::Constant:
                if (auto* constant = std::get_if<mir::MirConstant>(&op.data)) {
                    return constant_to_rust(*constant);
                }
                break;
        }
        return "()";
    }

    // Rvalue → Rust
    std::string rvalue_to_rust(const mir::MirRvalue& rv) {
        switch (rv.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rv.data);
                return operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rv.data);
                return "(" + operand_to_rust(*data.lhs) + " " +
                       binary_op_to_rust(data.op) + " " +
                       operand_to_rust(*data.rhs) + ")";
            }
            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rv.data);
                return unary_op_to_rust(data.op) + operand_to_rust(*data.operand);
            }
            case mir::MirRvalue::Ref: {
                auto& data = std::get<mir::MirRvalue::RefData>(rv.data);
                std::string prefix = data.borrow == mir::BorrowKind::Shared ? "&" : "&mut ";
                return prefix + place_to_rust(data.place);
            }
            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rv.data);
                return operand_to_rust(*data.operand) + " as " + type_to_rust(data.target_type);
            }
            default:
                return "()";
        }
    }

    // 定数 → Rust
    std::string constant_to_rust(const mir::MirConstant& constant) {
        if (std::holds_alternative<std::monostate>(constant.value)) {
            return "()";
        } else if (auto* b = std::get_if<bool>(&constant.value)) {
            return *b ? "true" : "false";
        } else if (auto* i = std::get_if<int64_t>(&constant.value)) {
            return std::to_string(*i);
        } else if (auto* d = std::get_if<double>(&constant.value)) {
            return std::to_string(*d);
        } else if (auto* c = std::get_if<char>(&constant.value)) {
            return "'" + std::string(1, *c) + "'";
        } else if (auto* s = std::get_if<std::string>(&constant.value)) {
            return "\"" + escape_string(*s) + "\"";
        }
        return "()";
    }

    // 型 → Rust
    std::string type_to_rust(hir::TypePtr type) {
        if (!type) return "()";

        if (type->name == "int") return "i32";
        if (type->name == "uint") return "u32";
        if (type->name == "long") return "i64";
        if (type->name == "ulong") return "u64";
        if (type->name == "float") return "f32";
        if (type->name == "double") return "f64";
        if (type->name == "bool") return "bool";
        if (type->name == "char") return "char";
        if (type->name == "void") return "()";
        if (type->name == "string") return "String";

        return type->name;
    }

    // 型 → FFI
    std::string type_to_ffi(hir::TypePtr type) {
        if (!type) return "()";

        if (type->name == "string") return "*const c_char";
        // その他は通常のRust型と同じ
        return type_to_rust(type);
    }

    // 二項演算子 → Rust
    std::string binary_op_to_rust(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add: return "+";
            case mir::MirBinaryOp::Sub: return "-";
            case mir::MirBinaryOp::Mul: return "*";
            case mir::MirBinaryOp::Div: return "/";
            case mir::MirBinaryOp::Mod: return "%";
            case mir::MirBinaryOp::BitAnd: return "&";
            case mir::MirBinaryOp::BitOr: return "|";
            case mir::MirBinaryOp::BitXor: return "^";
            case mir::MirBinaryOp::Shl: return "<<";
            case mir::MirBinaryOp::Shr: return ">>";
            case mir::MirBinaryOp::Eq: return "==";
            case mir::MirBinaryOp::Ne: return "!=";
            case mir::MirBinaryOp::Lt: return "<";
            case mir::MirBinaryOp::Le: return "<=";
            case mir::MirBinaryOp::Gt: return ">";
            case mir::MirBinaryOp::Ge: return ">=";
            case mir::MirBinaryOp::And: return "&&";
            case mir::MirBinaryOp::Or: return "||";
            default: return "?";
        }
    }

    // 単項演算子 → Rust
    std::string unary_op_to_rust(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg: return "-";
            case mir::MirUnaryOp::Not: return "!";
            case mir::MirUnaryOp::BitNot: return "!";  // Rustでは!がビット反転
            default: return "?";
        }
    }

    // 名前マングリング
    std::string mangle_name(const std::string& name) {
        // main関数は特別扱い
        if (name == "main") return "main";

        // Cm_ プレフィックスを付ける
        return "cm_" + name;
    }

    // 文字列エスケープ
    std::string escape_string(const std::string& s) {
        std::string result;
        for (char c : s) {
            switch (c) {
                case '"': result += "\\\""; break;
                case '\\': result += "\\\\"; break;
                case '\n': result += "\\n"; break;
                case '\r': result += "\\r"; break;
                case '\t': result += "\\t"; break;
                default: result += c; break;
            }
        }
        return result;
    }

    // Cargo.toml生成
    void generate_cargo_toml() {
        std::ofstream out(opts.output_dir + "/Cargo.toml");

        out << "[package]\n";
        out << "name = \"" << opts.crate_name << "\"\n";
        out << "version = \"0.1.0\"\n";
        out << "edition = \"2021\"\n\n";

        out << "[dependencies]\n";
        for (const auto& crate_ : external_crates) {
            out << crate_ << "\n";
        }
        out << "\n";

        out << "[profile.dev]\n";
        out << "opt-level = 0\n";
        out << "incremental = true\n\n";

        out << "[profile.release]\n";
        out << "opt-level = 3\n";
        out << "lto = true\n";
    }

    // FFIバインディング生成
    void generate_ffi_bindings() {
        std::ofstream out(opts.output_dir + "/ffi.rs");

        out << "// FFI bindings for Cm standard library\n\n";
        out << "use std::ffi::{CStr, CString};\n";
        out << "use std::os::raw::c_char;\n\n";

        // print関数の実装
        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_string(s: *const c_char) {\n";
        out << "    let s = unsafe { CStr::from_ptr(s).to_string_lossy() };\n";
        out << "    print!(\"{}\", s);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_int(n: i64) {\n";
        out << "    print!(\"{}\", n);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_float(f: f64) {\n";
        out << "    print!(\"{}\", f);\n";
        out << "}\n\n";

        out << "#[no_mangle]\n";
        out << "pub extern \"C\" fn cm_print_bool(b: bool) {\n";
        out << "    print!(\"{}\", b);\n";
        out << "}\n\n";
    }

    // 行出力
    void emit_line(const std::string& line) {
        for (int i = 0; i < indent_level; ++i) {
            current_output << "    ";
        }
        current_output << line << "\n";
    }

    void emit(const std::string& str) {
        current_output << str;
    }
};

}  // namespace cm::codegen