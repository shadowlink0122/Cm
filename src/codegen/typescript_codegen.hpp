#pragma once

#include "../common/debug.hpp"
#include "../hir/hir_types.hpp"
#include "../mir/mir_nodes.hpp"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <string>

namespace cm::codegen {

// ============================================================
// TypeScriptコード生成器
// ============================================================
class TypeScriptCodegen {
   public:
    TypeScriptCodegen() = default;

    // MIRプログラムをTypeScriptコードに変換
    void generate(const mir::MirProgram& program, const std::string& output_path = "") {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenTs, debug::Level::Info,
                       "Starting TypeScript code generation");
        }

        std::string out_dir = output_path.empty() ? ".tmp/ts_build" : output_path;
        std::filesystem::create_directories(out_dir);

        // TypeScriptコードを生成
        generate_typescript_code(program, out_dir);

        // package.jsonを生成
        generate_package_json(out_dir);

        // tsconfig.jsonを生成
        generate_tsconfig(out_dir);

        // ビルドスクリプトを生成
        generate_build_script(out_dir);

        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenTs, debug::Level::Info,
                       "TypeScript generation complete: " + out_dir);
        }
    }

   private:
    int indent_level = 0;
    std::ostringstream output;

    void generate_typescript_code(const mir::MirProgram& program, const std::string& out_dir) {
        output.str("");
        output.clear();
        indent_level = 0;

        // ヘッダー
        emit_line("// Generated by Cm TypeScript Codegen");
        emit_line("// Target: TypeScript 5.0+, Node.js 18+");
        emit_line("");

        // 標準ライブラリ関数
        emit_line("// Standard library functions");
        emit_line("const print = (...args: any[]): void => {");
        indent_level++;
        emit_line("process.stdout.write(args.join(''));");
        indent_level--;
        emit_line("};");
        emit_line("");
        emit_line("const println = (...args: any[]): void => {");
        indent_level++;
        emit_line("console.log(...args);");
        indent_level--;
        emit_line("};");
        emit_line("");

        // 各関数を生成
        for (const auto& func : program.functions) {
            if (func) {
                generate_function(*func);
            }
        }

        // エントリーポイント
        emit_line("// Entry point");
        emit_line("if (require.main === module) {");
        indent_level++;
        emit_line("const exitCode = main();");
        emit_line("process.exit(exitCode || 0);");
        indent_level--;
        emit_line("}");

        // ファイルに書き込み
        std::ofstream main_file(out_dir + "/main.ts");
        main_file << output.str();
        main_file.close();
    }

    void generate_function(const mir::MirFunction& func) {
        if (debug::g_debug_mode) {
            debug::log(debug::Stage::CodegenTs, debug::Level::Debug,
                       "Generating function: " + func.name);
        }

        // 関数シグネチャ
        std::string params = "";
        bool first = true;
        for (size_t i = 0; i < func.arg_locals.size(); ++i) {
            if (!first)
                params += ", ";
            first = false;
            params += "_" + std::to_string(func.arg_locals[i]) + ": " +
                      type_to_ts(func.locals[func.arg_locals[i]].type);
        }

        std::string return_type = type_to_ts(func.locals[func.return_local].type);

        emit_line("function " + mangle_name(func.name) + "(" + params + "): " + return_type + " {");
        indent_level++;

        // ローカル変数の宣言（戻り値変数を含む）
        for (const auto& local : func.locals) {
            // 引数以外を宣言
            bool is_arg = false;
            for (auto arg_id : func.arg_locals) {
                if (arg_id == local.id) {
                    is_arg = true;
                    break;
                }
            }

            if (!is_arg) {
                emit_line("let _" + std::to_string(local.id) + ": " + type_to_ts(local.type) + ";");
            }
        }

        if (!func.locals.empty()) {
            emit_line("");
        }

        // 基本ブロックの処理
        for (const auto& block : func.basic_blocks) {
            if (block) {
                generate_basic_block(*block, func);
            }
        }

        indent_level--;
        emit_line("}");
        emit_line("");
    }

    void generate_basic_block(const mir::BasicBlock& block, const mir::MirFunction& func) {
        // ブロックコメント
        emit_line("// bb" + std::to_string(block.id));

        // 文の生成
        for (const auto& stmt : block.statements) {
            generate_statement(*stmt, func);
        }

        // 終端命令の生成
        if (block.terminator) {
            generate_terminator(*block.terminator, func);
        }
    }

    void generate_statement(const mir::MirStatement& stmt, const mir::MirFunction& func) {
        switch (stmt.kind) {
            case mir::MirStatement::Assign: {
                auto& data = std::get<mir::MirStatement::AssignData>(stmt.data);
                std::string lhs = place_to_ts(data.place);
                std::string rhs = rvalue_to_ts(*data.rvalue);
                emit_line(lhs + " = " + rhs + ";");
                break;
            }
            case mir::MirStatement::StorageLive:
            case mir::MirStatement::StorageDead:
                // TypeScriptでは不要
                break;
            case mir::MirStatement::Nop:
                emit_line("// nop");
                break;
        }
    }

    void generate_terminator(const mir::MirTerminator& term, const mir::MirFunction& func) {
        switch (term.kind) {
            case mir::MirTerminator::Return:
                if (func.locals[func.return_local].type &&
                    func.locals[func.return_local].type->name != "void") {
                    emit_line("return _" + std::to_string(func.return_local) + ";");
                } else {
                    emit_line("return;");
                }
                break;

            case mir::MirTerminator::Goto:
                emit_line("// goto bb" +
                          std::to_string(std::get<mir::MirTerminator::GotoData>(term.data).target));
                break;

            case mir::MirTerminator::SwitchInt: {
                auto& data = std::get<mir::MirTerminator::SwitchIntData>(term.data);
                emit_line("switch (" + operand_to_ts(*data.discriminant) + ") {");
                indent_level++;

                for (const auto& [value, target] : data.targets) {
                    emit_line("case " + std::to_string(value) + ":");
                    indent_level++;
                    emit_line("// goto bb" + std::to_string(target));
                    emit_line("break;");
                    indent_level--;
                }

                emit_line("default:");
                indent_level++;
                emit_line("// goto bb" + std::to_string(data.otherwise));
                emit_line("break;");
                indent_level--;

                indent_level--;
                emit_line("}");
                break;
            }

            case mir::MirTerminator::Call: {
                auto& data = std::get<mir::MirTerminator::CallData>(term.data);

                // 関数名を取得
                std::string func_name = operand_to_ts(*data.func);

                // println/print の特別処理（文字列補間）
                if ((func_name == "println" || func_name == "print") && data.args.size() > 1) {
                    // 第1引数がフォーマット文字列
                    std::string format_str = "";
                    bool has_format = false;

                    if (data.args[0]->kind == mir::MirOperand::Constant) {
                        if (auto* constant = std::get_if<mir::MirConstant>(&data.args[0]->data)) {
                            if (auto* str_val = std::get_if<std::string>(&constant->value)) {
                                format_str = *str_val;
                                has_format = true;
                            }
                        }
                    }

                    if (has_format) {
                        // {変数名}を${変数}に置換してテンプレートリテラルを作成
                        std::vector<std::string> args_to_interpolate;
                        for (size_t i = 1; i < data.args.size(); ++i) {
                            args_to_interpolate.push_back(operand_to_ts(*data.args[i]));
                        }

                        std::string template_literal = format_str;
                        size_t arg_index = 0;
                        size_t pos = 0;

                        while ((pos = template_literal.find('{', pos)) != std::string::npos) {
                            size_t end = template_literal.find('}', pos);
                            if (end != std::string::npos) {
                                // {{や}}はエスケープなのでスキップ
                                if (pos + 1 < template_literal.size() &&
                                    template_literal[pos + 1] == '{') {
                                    pos += 2;
                                    continue;
                                }

                                std::string placeholder =
                                    template_literal.substr(pos + 1, end - pos - 1);
                                // 変数名のプレースホルダーを${変数}に置換
                                if (!placeholder.empty() &&
                                    placeholder.find(':') == std::string::npos &&
                                    !std::isdigit(placeholder[0]) &&
                                    arg_index < args_to_interpolate.size()) {
                                    template_literal.replace(
                                        pos, end - pos + 1,
                                        "${" + args_to_interpolate[arg_index] + "}");
                                    pos += args_to_interpolate[arg_index].length() +
                                           3;  // ${}の長さを考慮
                                    arg_index++;
                                } else {
                                    pos = end + 1;
                                }
                            } else {
                                break;
                            }
                        }

                        // バッククォートを使ったテンプレートリテラルとして出力
                        emit_line(func_name + "(`" + template_literal + "`);");
                    } else {
                        // フォーマット文字列が取得できない場合は通常の呼び出し
                        std::string call = func_name + "(";
                        bool first = true;
                        for (const auto& arg : data.args) {
                            if (!first)
                                call += ", ";
                            first = false;
                            call += operand_to_ts(*arg);
                        }
                        call += ")";
                        emit_line(call + ";");
                    }
                } else {
                    // 通常の関数呼び出し
                    std::string call = func_name + "(";
                    bool first = true;
                    for (const auto& arg : data.args) {
                        if (!first)
                            call += ", ";
                        first = false;
                        call += operand_to_ts(*arg);
                    }
                    call += ")";

                    if (data.destination) {
                        emit_line(place_to_ts(*data.destination) + " = " + call + ";");
                    } else {
                        emit_line(call + ";");
                    }
                }
                break;
            }

            case mir::MirTerminator::Unreachable:
                emit_line("throw new Error('Unreachable code');");
                break;
        }
    }

    std::string place_to_ts(const mir::MirPlace& place) {
        std::string result = "_" + std::to_string(place.local);

        for (const auto& proj : place.projections) {
            switch (proj.kind) {
                case mir::ProjectionKind::Field:
                    result += "." + std::to_string(proj.field_id);
                    break;
                case mir::ProjectionKind::Index:
                    result += "[_" + std::to_string(proj.index_local) + "]";
                    break;
                case mir::ProjectionKind::Deref:
                    // TypeScriptでは参照外しは不要
                    break;
            }
        }

        return result;
    }

    std::string operand_to_ts(const mir::MirOperand& op) {
        switch (op.kind) {
            case mir::MirOperand::Move:
            case mir::MirOperand::Copy:
                if (auto* place = std::get_if<mir::MirPlace>(&op.data)) {
                    return place_to_ts(*place);
                }
                break;
            case mir::MirOperand::Constant:
                if (auto* constant = std::get_if<mir::MirConstant>(&op.data)) {
                    return constant_to_ts(*constant);
                }
                break;
            case mir::MirOperand::FunctionRef:
                if (auto* func_name = std::get_if<std::string>(&op.data)) {
                    // TypeScriptでは通常の関数呼び出し
                    return *func_name;
                }
                break;
        }
        return "undefined";
    }

    std::string rvalue_to_ts(const mir::MirRvalue& rv) {
        switch (rv.kind) {
            case mir::MirRvalue::Use: {
                auto& data = std::get<mir::MirRvalue::UseData>(rv.data);
                return operand_to_ts(*data.operand);
            }
            case mir::MirRvalue::BinaryOp: {
                auto& data = std::get<mir::MirRvalue::BinaryOpData>(rv.data);
                return "(" + operand_to_ts(*data.lhs) + " " + binary_op_to_ts(data.op) + " " +
                       operand_to_ts(*data.rhs) + ")";
            }
            case mir::MirRvalue::UnaryOp: {
                auto& data = std::get<mir::MirRvalue::UnaryOpData>(rv.data);
                return unary_op_to_ts(data.op) + operand_to_ts(*data.operand);
            }
            case mir::MirRvalue::Ref: {
                // TypeScriptでは参照は不要
                auto& data = std::get<mir::MirRvalue::RefData>(rv.data);
                return place_to_ts(data.place);
            }
            case mir::MirRvalue::Cast: {
                auto& data = std::get<mir::MirRvalue::CastData>(rv.data);
                // TypeScriptでは型キャストはas演算子を使用
                return operand_to_ts(*data.operand);
            }
            default:
                return "undefined";
        }
    }

    std::string constant_to_ts(const mir::MirConstant& constant) {
        if (std::holds_alternative<std::monostate>(constant.value)) {
            return "undefined";
        } else if (auto* b = std::get_if<bool>(&constant.value)) {
            return *b ? "true" : "false";
        } else if (auto* i = std::get_if<int64_t>(&constant.value)) {
            return std::to_string(*i);
        } else if (auto* d = std::get_if<double>(&constant.value)) {
            return std::to_string(*d);
        } else if (auto* c = std::get_if<char>(&constant.value)) {
            return "'" + std::string(1, *c) + "'";
        } else if (auto* s = std::get_if<std::string>(&constant.value)) {
            return "\"" + escape_string(*s) + "\"";
        }
        return "undefined";
    }

    std::string type_to_ts(hir::TypePtr type) {
        if (!type)
            return "any";

        if (type->name == "int" || type->name == "long" || type->name == "uint" ||
            type->name == "ulong") {
            return "number";
        }
        if (type->name == "float" || type->name == "double") {
            return "number";
        }
        if (type->name == "bool") {
            return "boolean";
        }
        if (type->name == "char" || type->name == "string") {
            return "string";
        }
        if (type->name == "void") {
            return "void";
        }

        return "any";
    }

    std::string binary_op_to_ts(mir::MirBinaryOp op) {
        switch (op) {
            case mir::MirBinaryOp::Add:
                return "+";
            case mir::MirBinaryOp::Sub:
                return "-";
            case mir::MirBinaryOp::Mul:
                return "*";
            case mir::MirBinaryOp::Div:
                return "/";
            case mir::MirBinaryOp::Mod:
                return "%";
            case mir::MirBinaryOp::BitAnd:
                return "&";
            case mir::MirBinaryOp::BitOr:
                return "|";
            case mir::MirBinaryOp::BitXor:
                return "^";
            case mir::MirBinaryOp::Shl:
                return "<<";
            case mir::MirBinaryOp::Shr:
                return ">>";
            case mir::MirBinaryOp::Eq:
                return "===";
            case mir::MirBinaryOp::Ne:
                return "!==";
            case mir::MirBinaryOp::Lt:
                return "<";
            case mir::MirBinaryOp::Le:
                return "<=";
            case mir::MirBinaryOp::Gt:
                return ">";
            case mir::MirBinaryOp::Ge:
                return ">=";
            case mir::MirBinaryOp::And:
                return "&&";
            case mir::MirBinaryOp::Or:
                return "||";
            default:
                return "+";
        }
    }

    std::string unary_op_to_ts(mir::MirUnaryOp op) {
        switch (op) {
            case mir::MirUnaryOp::Neg:
                return "-";
            case mir::MirUnaryOp::Not:
                return "!";
            case mir::MirUnaryOp::BitNot:
                return "~";
            default:
                return "";
        }
    }

    std::string mangle_name(const std::string& name) {
        if (name == "main")
            return "main";
        if (name == "println" || name == "print")
            return name;
        return "cm_" + name;
    }

    std::string escape_string(const std::string& s) {
        std::string result;
        for (char c : s) {
            switch (c) {
                case '"':
                    result += "\\\"";
                    break;
                case '\\':
                    result += "\\\\";
                    break;
                case '\n':
                    result += "\\n";
                    break;
                case '\r':
                    result += "\\r";
                    break;
                case '\t':
                    result += "\\t";
                    break;
                default:
                    result += c;
                    break;
            }
        }
        return result;
    }

    void emit_line(const std::string& line) {
        for (int i = 0; i < indent_level; ++i) {
            output << "    ";
        }
        output << line << "\n";
    }

    void generate_package_json(const std::string& out_dir) {
        std::ofstream pkg_file(out_dir + "/package.json");
        pkg_file << "{\n";
        pkg_file << "  \"name\": \"cm-generated\",\n";
        pkg_file << "  \"version\": \"1.0.0\",\n";
        pkg_file << "  \"description\": \"Generated from Cm compiler\",\n";
        pkg_file << "  \"main\": \"main.js\",\n";
        pkg_file << "  \"engines\": {\n";
        pkg_file << "    \"node\": \">=18.0.0\"\n";
        pkg_file << "  },\n";
        // packageManagerフィールドを一時的にコメントアウト（pnpmのバグ回避）
        // pkg_file << "  \"packageManager\": \"pnpm@8.0.0\",\n";
        pkg_file << "  \"scripts\": {\n";
        pkg_file << "    \"build\": \"tsc\",\n";
        pkg_file << "    \"start\": \"node main.js\",\n";
        pkg_file << "    \"dev\": \"ts-node main.ts\"\n";
        pkg_file << "  },\n";
        pkg_file << "  \"devDependencies\": {\n";
        pkg_file << "    \"@types/node\": \"^20.0.0\",\n";
        pkg_file << "    \"typescript\": \"^5.0.0\",\n";
        pkg_file << "    \"ts-node\": \"^10.9.0\"\n";
        pkg_file << "  }\n";
        pkg_file << "}\n";
        pkg_file.close();
    }

    void generate_tsconfig(const std::string& out_dir) {
        std::ofstream ts_file(out_dir + "/tsconfig.json");
        ts_file << "{\n";
        ts_file << "  \"compilerOptions\": {\n";
        ts_file << "    \"target\": \"ES2022\",\n";
        ts_file << "    \"module\": \"commonjs\",\n";
        ts_file << "    \"lib\": [\"ES2022\"],\n";
        ts_file << "    \"outDir\": \"./\",\n";
        ts_file << "    \"rootDir\": \"./\",\n";
        ts_file << "    \"strict\": true,\n";
        ts_file << "    \"esModuleInterop\": true,\n";
        ts_file << "    \"skipLibCheck\": true,\n";
        ts_file << "    \"forceConsistentCasingInFileNames\": true\n";
        ts_file << "  },\n";
        ts_file << "  \"include\": [\"*.ts\"],\n";
        ts_file << "  \"exclude\": [\"node_modules\"]\n";
        ts_file << "}\n";
        ts_file.close();
    }

    void generate_build_script(const std::string& out_dir) {
        // build.shを生成
        std::ofstream build_file(out_dir + "/build.sh");
        build_file << "#!/bin/bash\n";
        build_file << "# Build and run TypeScript code\n";
        build_file << "pnpm install\n";
        build_file << "pnpm run build\n";
        build_file << "node main.js\n";
        build_file.close();

        // 実行権限を設定
        std::filesystem::permissions(out_dir + "/build.sh",
                                     std::filesystem::perms::owner_exec |
                                         std::filesystem::perms::owner_read |
                                         std::filesystem::perms::owner_write);
    }
};

}  // namespace cm::codegen